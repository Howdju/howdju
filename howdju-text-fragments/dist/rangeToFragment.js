"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a3, b3) => {
    for (var prop in b3 || (b3 = {}))
      if (__hasOwnProp.call(b3, prop))
        __defNormalProp(a3, prop, b3[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b3)) {
        if (__propIsEnum.call(b3, prop))
          __defNormalProp(a3, prop, b3[prop]);
      }
    return a3;
  };
  var __spreadProps = (a3, b3) => __defProps(a3, __getOwnPropDescs(b3));
  var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
    get: (a3, b3) => (typeof require !== "undefined" ? require : a3)[b3]
  }) : x3)(function(x3) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x3 + '" is not supported');
  });
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod2, secondTarget) => (__copyProps(target, mod2, "default"), secondTarget && __copyProps(secondTarget, mod2, "default"));
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject2) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject2(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject2(e2);
        }
      };
      var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // ../node_modules/lodash/_arrayEach.js
  var require_arrayEach = __commonJS({
    "../node_modules/lodash/_arrayEach.js"(exports, module) {
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      module.exports = arrayEach;
    }
  });

  // ../node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "../node_modules/lodash/_createBaseFor.js"(exports, module) {
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      module.exports = createBaseFor;
    }
  });

  // ../node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "../node_modules/lodash/_baseFor.js"(exports, module) {
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module.exports = baseFor;
    }
  });

  // ../node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "../node_modules/lodash/_baseTimes.js"(exports, module) {
      function baseTimes(n3, iteratee) {
        var index = -1, result = Array(n3);
        while (++index < n3) {
          result[index] = iteratee(index);
        }
        return result;
      }
      module.exports = baseTimes;
    }
  });

  // ../node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "../node_modules/lodash/_freeGlobal.js"(exports, module) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module.exports = freeGlobal;
    }
  });

  // ../node_modules/lodash/_root.js
  var require_root = __commonJS({
    "../node_modules/lodash/_root.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module.exports = root;
    }
  });

  // ../node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "../node_modules/lodash/_Symbol.js"(exports, module) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module.exports = Symbol2;
    }
  });

  // ../node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "../node_modules/lodash/_getRawTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // ../node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "../node_modules/lodash/_objectToString.js"(exports, module) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString;
    }
  });

  // ../node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "../node_modules/lodash/_baseGetTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module.exports = baseGetTag;
    }
  });

  // ../node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "../node_modules/lodash/isObjectLike.js"(exports, module) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike;
    }
  });

  // ../node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "../node_modules/lodash/_baseIsArguments.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module.exports = baseIsArguments;
    }
  });

  // ../node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "../node_modules/lodash/isArguments.js"(exports, module) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module.exports = isArguments;
    }
  });

  // ../node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "../node_modules/lodash/isArray.js"(exports, module) {
      var isArray3 = Array.isArray;
      module.exports = isArray3;
    }
  });

  // ../node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "../node_modules/lodash/stubFalse.js"(exports, module) {
      function stubFalse() {
        return false;
      }
      module.exports = stubFalse;
    }
  });

  // ../node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "../node_modules/lodash/isBuffer.js"(exports, module) {
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module.exports = isBuffer;
    }
  });

  // ../node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "../node_modules/lodash/_isIndex.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module.exports = isIndex;
    }
  });

  // ../node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "../node_modules/lodash/isLength.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module.exports = isLength;
    }
  });

  // ../node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "../node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module.exports = baseIsTypedArray;
    }
  });

  // ../node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "../node_modules/lodash/_baseUnary.js"(exports, module) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module.exports = baseUnary;
    }
  });

  // ../node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "../node_modules/lodash/_nodeUtil.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      module.exports = nodeUtil;
    }
  });

  // ../node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "../node_modules/lodash/isTypedArray.js"(exports, module) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module.exports = isTypedArray;
    }
  });

  // ../node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "../node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray3 = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray3(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = arrayLikeKeys;
    }
  });

  // ../node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "../node_modules/lodash/_isPrototype.js"(exports, module) {
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      module.exports = isPrototype;
    }
  });

  // ../node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "../node_modules/lodash/_overArg.js"(exports, module) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module.exports = overArg;
    }
  });

  // ../node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "../node_modules/lodash/_nativeKeys.js"(exports, module) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module.exports = nativeKeys;
    }
  });

  // ../node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "../node_modules/lodash/_baseKeys.js"(exports, module) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeys;
    }
  });

  // ../node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "../node_modules/lodash/isObject.js"(exports, module) {
      function isObject3(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module.exports = isObject3;
    }
  });

  // ../node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "../node_modules/lodash/isFunction.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObject3 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction2(value) {
        if (!isObject3(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module.exports = isFunction2;
    }
  });

  // ../node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "../node_modules/lodash/isArrayLike.js"(exports, module) {
      var isFunction2 = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      module.exports = isArrayLike;
    }
  });

  // ../node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "../node_modules/lodash/keys.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys4(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      module.exports = keys4;
    }
  });

  // ../node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "../node_modules/lodash/_baseForOwn.js"(exports, module) {
      var baseFor = require_baseFor();
      var keys4 = require_keys();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys4);
      }
      module.exports = baseForOwn;
    }
  });

  // ../node_modules/lodash/_createBaseEach.js
  var require_createBaseEach = __commonJS({
    "../node_modules/lodash/_createBaseEach.js"(exports, module) {
      var isArrayLike = require_isArrayLike();
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      module.exports = createBaseEach;
    }
  });

  // ../node_modules/lodash/_baseEach.js
  var require_baseEach = __commonJS({
    "../node_modules/lodash/_baseEach.js"(exports, module) {
      var baseForOwn = require_baseForOwn();
      var createBaseEach = require_createBaseEach();
      var baseEach = createBaseEach(baseForOwn);
      module.exports = baseEach;
    }
  });

  // ../node_modules/lodash/identity.js
  var require_identity = __commonJS({
    "../node_modules/lodash/identity.js"(exports, module) {
      function identity(value) {
        return value;
      }
      module.exports = identity;
    }
  });

  // ../node_modules/lodash/_castFunction.js
  var require_castFunction = __commonJS({
    "../node_modules/lodash/_castFunction.js"(exports, module) {
      var identity = require_identity();
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      module.exports = castFunction;
    }
  });

  // ../node_modules/lodash/forEach.js
  var require_forEach = __commonJS({
    "../node_modules/lodash/forEach.js"(exports, module) {
      var arrayEach = require_arrayEach();
      var baseEach = require_baseEach();
      var castFunction = require_castFunction();
      var isArray3 = require_isArray();
      function forEach3(collection, iteratee) {
        var func = isArray3(collection) ? arrayEach : baseEach;
        return func(collection, castFunction(iteratee));
      }
      module.exports = forEach3;
    }
  });

  // ../node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "../node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e2) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values2) {
          var index = -1, length = values2.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values2[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n3, iteratee) {
          var index = -1, result = Array(n3);
          while (++index < n3) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map4) {
          var index = -1, result = Array(map4.size);
          map4.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set2) {
          var index = -1, result = Array(set2.size);
          set2.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set2) {
          var index = -1, result = Array(set2.size);
          set2.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _3.defaults(root.Object(), context, _3.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e2) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap && new WeakMap();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray3(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject3(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray3(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values3) {
            var index = -1, length = values3 == null ? 0 : values3.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values3[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray3(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n3) {
            return shuffleSelf(copyArray(array), baseClamp(n3, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys4(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject3(value)) {
              return value;
            }
            var isArr = isArray3(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys4;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys4(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values3, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values3.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values3 = arrayMap(values3, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values3.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values3 = new SetCache(values3);
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values3[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values3, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys4);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys4);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction2(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray3(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray3(object), othIsArr = isArray3(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject3(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject3(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject3(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray3(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray3(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject3(objValue) || isFunction2(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n3) {
            var length = array.length;
            if (!length) {
              return;
            }
            n3 += n3 < 0 ? length : 0;
            return isIndex(n3, length) ? array[n3] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray3(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values3, iteratee2, comparator) {
            var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values3.length, seen = array;
            if (array === values3) {
              values3 = copyArray(values3);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values3[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf3(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n3) {
            var result2 = "";
            if (!string || n3 < 1 || n3 > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n3 % 2) {
                result2 += string;
              }
              n3 = nativeFloor(n3 / 2);
              if (n3) {
                string += string;
              }
            } while (n3);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values2(collection));
          }
          function baseSampleSize(collection, n3) {
            var array = values2(collection);
            return shuffleSelf(array, baseClamp(n3, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject3(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject3(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values2(collection));
          }
          function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array[index + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray3(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set3 = iteratee2 ? null : createSet(array);
              if (set3) {
                return setToArray(set3);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values3, assignFunc) {
            var index = -1, length = props.length, valsLength = values3.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values3[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray3(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString3(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array2(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray3(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn2.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString3(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr2(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject3(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn2, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys4(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray3(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn2 = Ctor || createCtor(fn2);
              }
              return fn2.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn2, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString3(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString3(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values3) {
            return new Set2(values3);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject3(objValue) && isObject3(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject2(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys4, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map5, key) {
            var data = map5.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys4(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e2) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray3(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray3(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject3(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray3(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction2 : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject3(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e2) {
              }
              try {
                return func + "";
              } catch (e2) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray3(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values3) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values3) {
            var iteratee2 = last(values3);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values3) {
            var comparator = last(values3);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n3, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            return baseSlice(array, n3 < 0 ? 0 : n3, length);
          }
          function dropRight(array, n3, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            n3 = length - n3;
            return baseSlice(array, 0, n3 < 0 ? 0 : n3);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head2(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf2(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join3(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n3) {
            return array && array.length ? baseNth(array, toInteger(n3)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values3) {
            return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
          }
          function pullAllBy(array, values3, iteratee2) {
            return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values3, comparator) {
            return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse2(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n3, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            return baseSlice(array, 0, n3 < 0 ? 0 : n3);
          }
          function takeRight(array, n3, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            n3 = length - n3;
            return baseSlice(array, n3 < 0 ? 0 : n3, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith2(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values3) {
            return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values3) {
            return baseZipObject(props || [], values3 || [], assignValue);
          }
          function zipObjectDeep(props, values3) {
            return baseZipObject(props || [], values3 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse2],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse2);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray3(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter3(collection, predicate) {
            var func = isArray3(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map4(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map4(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map4(collection, iteratee2), depth);
          }
          function forEach3(collection, iteratee2) {
            var func = isArray3(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray3(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values2(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map4(collection, iteratee2) {
            var func = isArray3(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray3(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray3(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce3(collection, iteratee2, accumulator) {
            var func = isArray3(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray3(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject2(collection, predicate) {
            var func = isArray3(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray3(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n3, guard) {
            if (guard ? isIterateeCall(collection, n3, guard) : n3 === undefined2) {
              n3 = 1;
            } else {
              n3 = toInteger(n3);
            }
            var func = isArray3(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n3);
          }
          function shuffle(collection) {
            var func = isArray3(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString3(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some2(collection, predicate, guard) {
            var func = isArray3(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n3, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n3 = toInteger(n3);
            return function() {
              if (--n3 < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n3, guard) {
            n3 = guard ? undefined2 : n3;
            n3 = func && n3 == null ? func.length : n3;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n3);
          }
          function before(n3, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n3 = toInteger(n3);
            return function() {
              if (--n3 > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n3 <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject3(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray3(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject3(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray3(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep5(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith2(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys4(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray3 = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction2(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray3(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual2(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction2(value) {
            if (!isObject3(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject3(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN3(value) {
            return isNumber2(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber2(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject2(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString3(value) {
            return typeof value == "string" || !isArray3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined2(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString3(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject3(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject3(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString3(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign4 = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys4(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys4(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys4(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert2 = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys4(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues3(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge4 = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit2 = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy2(object, negate(getIteratee(predicate)));
          }
          var pick3 = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy2(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction2(value) ? value.call(object) : value;
            }
            return object;
          }
          function set2(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys4);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray3(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject3(object)) {
                accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values2(object) {
            return object == null ? [] : baseValues(object, keys4(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase2 = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString3(string).toLowerCase());
          }
          function deburr2(string) {
            string = toString3(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString3(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString3(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString3(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString3(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString3(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString3(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt3(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n3, guard) {
            if (guard ? isIterateeCall(string, n3, guard) : n3 === undefined2) {
              n3 = 1;
            } else {
              n3 = toInteger(n3);
            }
            return baseRepeat(toString3(string), n3);
          }
          function replace2() {
            var args = arguments, string = toString3(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split2(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString3(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase2 = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString3(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString3(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys4(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower2(value) {
            return toString3(value).toLowerCase();
          }
          function toUpper(value) {
            return toString3(value).toUpperCase();
          }
          function trim2(string, chars, guard) {
            string = toString3(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString3(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString3(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject3(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString3(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape(string) {
            string = toString3(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString3(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e2) {
              return isError(e2) ? e2 : new Error2(e2);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys4(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject3(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys4(source));
            }
            var chain2 = !(isObject3(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop() {
          }
          function nthArg(n3) {
            n3 = toInteger(n3);
            return baseRest(function(args) {
              return baseNth(args, n3);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n3, iteratee2) {
            n3 = toInteger(n3);
            if (n3 < 1 || n3 > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n3, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n3 -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n3) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray3(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString3(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString3(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign4;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter3;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert2;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys4;
          lodash.keysIn = keysIn;
          lodash.map = map4;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues3;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge4;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit2;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick3;
          lodash.pickBy = pickBy2;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject2;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse2;
          lodash.sampleSize = sampleSize;
          lodash.set = set2;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split2;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith2;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values2;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase2;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep5;
          lodash.cloneDeepWith = cloneDeepWith2;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr2;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach3;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head2;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf2;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray3;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual2;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction2;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN3;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber2;
          lodash.isObject = isObject3;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject2;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString3;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined2;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join3;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt3;
          lodash.random = random;
          lodash.reduce = reduce3;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace2;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some2;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase2;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower2;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString3;
          lodash.toUpper = toUpper;
          lodash.trim = trim2;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach3;
          lodash.eachRight = forEachRight;
          lodash.first = head2;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n3) {
              n3 = n3 === undefined2 ? 1 : nativeMax(toInteger(n3), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n3, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n3, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n3) {
              return this.reverse()[methodName](n3).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray3(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray3(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray3(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _3 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _3;
          define(function() {
            return _3;
          });
        } else if (freeModule) {
          (freeModule.exports = _3)._ = _3;
          freeExports._ = _3;
        } else {
          root._ = _3;
        }
      }).call(exports);
    }
  });

  // ../howdju-common/lib/commonErrors.ts
  function isCustomError(err) {
    return err instanceof Error && "errorType" in err;
  }
  function newCustomError(errorType, message, sourceError, props) {
    const error = new Error(message);
    error.errorType = errorType;
    if (sourceError) {
      error.sourceError = sourceError;
    }
    (0, import_lodash.assign)(error, props);
    return error;
  }
  var import_lodash, commonErrorTypes, newImpossibleError, newProgrammingError, newExhaustedEnumError, newUnimplementedError;
  var init_commonErrors = __esm({
    "../howdju-common/lib/commonErrors.ts"() {
      "use strict";
      import_lodash = __toESM(require_lodash());
      commonErrorTypes = {
        /** Something happened that should have been avoidable (how does this differ from impossible?) */
        PROGRAMMING_ERROR: "PROGRAMMING_ERROR",
        /** Something happened that should not have been possible. */
        IMPOSSIBLE_ERROR: "IMPOSSIBLE_ERROR",
        /** We exhausted an enums values, but shouldn't have been able to.  This is a type of programming error. */
        EXHAUSTED_ENUM: "EXHAUSTED_ENUM",
        /** The required code path is purposefully unimplemented currently. */
        UNIMPLEMENTED_ERROR: "UNIMPLEMENTED_ERROR"
      };
      newImpossibleError = (value) => {
        throw newCustomError(
          commonErrorTypes.IMPOSSIBLE_ERROR,
          `Impossible value: ${value}`
        );
      };
      newProgrammingError = (message) => newCustomError(commonErrorTypes.PROGRAMMING_ERROR, message);
      newExhaustedEnumError = (value) => {
        throw newCustomError(
          commonErrorTypes.EXHAUSTED_ENUM,
          `Exhausted enum ${value}`
        );
      };
      newUnimplementedError = (message) => newCustomError(commonErrorTypes.UNIMPLEMENTED_ERROR, message);
    }
  });

  // ../node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "../node_modules/lodash/_listCacheClear.js"(exports, module) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module.exports = listCacheClear;
    }
  });

  // ../node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "../node_modules/lodash/eq.js"(exports, module) {
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module.exports = eq;
    }
  });

  // ../node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "../node_modules/lodash/_assocIndexOf.js"(exports, module) {
      var eq = require_eq();
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module.exports = assocIndexOf;
    }
  });

  // ../node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "../node_modules/lodash/_listCacheDelete.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module.exports = listCacheDelete;
    }
  });

  // ../node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "../node_modules/lodash/_listCacheGet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module.exports = listCacheGet;
    }
  });

  // ../node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "../node_modules/lodash/_listCacheHas.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module.exports = listCacheHas;
    }
  });

  // ../node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "../node_modules/lodash/_listCacheSet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module.exports = listCacheSet;
    }
  });

  // ../node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "../node_modules/lodash/_ListCache.js"(exports, module) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module.exports = ListCache;
    }
  });

  // ../node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "../node_modules/lodash/_stackClear.js"(exports, module) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module.exports = stackClear;
    }
  });

  // ../node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "../node_modules/lodash/_stackDelete.js"(exports, module) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module.exports = stackDelete;
    }
  });

  // ../node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "../node_modules/lodash/_stackGet.js"(exports, module) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module.exports = stackGet;
    }
  });

  // ../node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "../node_modules/lodash/_stackHas.js"(exports, module) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module.exports = stackHas;
    }
  });

  // ../node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "../node_modules/lodash/_coreJsData.js"(exports, module) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module.exports = coreJsData;
    }
  });

  // ../node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "../node_modules/lodash/_isMasked.js"(exports, module) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module.exports = isMasked;
    }
  });

  // ../node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "../node_modules/lodash/_toSource.js"(exports, module) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      module.exports = toSource;
    }
  });

  // ../node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "../node_modules/lodash/_baseIsNative.js"(exports, module) {
      var isFunction2 = require_isFunction();
      var isMasked = require_isMasked();
      var isObject3 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject3(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module.exports = baseIsNative;
    }
  });

  // ../node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "../node_modules/lodash/_getValue.js"(exports, module) {
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      module.exports = getValue;
    }
  });

  // ../node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "../node_modules/lodash/_getNative.js"(exports, module) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      module.exports = getNative;
    }
  });

  // ../node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "../node_modules/lodash/_Map.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module.exports = Map2;
    }
  });

  // ../node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "../node_modules/lodash/_nativeCreate.js"(exports, module) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module.exports = nativeCreate;
    }
  });

  // ../node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "../node_modules/lodash/_hashClear.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module.exports = hashClear;
    }
  });

  // ../node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "../node_modules/lodash/_hashDelete.js"(exports, module) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = hashDelete;
    }
  });

  // ../node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "../node_modules/lodash/_hashGet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      module.exports = hashGet;
    }
  });

  // ../node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "../node_modules/lodash/_hashHas.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      module.exports = hashHas;
    }
  });

  // ../node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "../node_modules/lodash/_hashSet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module.exports = hashSet;
    }
  });

  // ../node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "../node_modules/lodash/_Hash.js"(exports, module) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module.exports = Hash;
    }
  });

  // ../node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "../node_modules/lodash/_mapCacheClear.js"(exports, module) {
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      module.exports = mapCacheClear;
    }
  });

  // ../node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "../node_modules/lodash/_isKeyable.js"(exports, module) {
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      module.exports = isKeyable;
    }
  });

  // ../node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "../node_modules/lodash/_getMapData.js"(exports, module) {
      var isKeyable = require_isKeyable();
      function getMapData(map4, key) {
        var data = map4.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module.exports = getMapData;
    }
  });

  // ../node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "../node_modules/lodash/_mapCacheDelete.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = mapCacheDelete;
    }
  });

  // ../node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "../node_modules/lodash/_mapCacheGet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module.exports = mapCacheGet;
    }
  });

  // ../node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "../node_modules/lodash/_mapCacheHas.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module.exports = mapCacheHas;
    }
  });

  // ../node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "../node_modules/lodash/_mapCacheSet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module.exports = mapCacheSet;
    }
  });

  // ../node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "../node_modules/lodash/_MapCache.js"(exports, module) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module.exports = MapCache;
    }
  });

  // ../node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "../node_modules/lodash/_stackSet.js"(exports, module) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module.exports = stackSet;
    }
  });

  // ../node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "../node_modules/lodash/_Stack.js"(exports, module) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      module.exports = Stack;
    }
  });

  // ../node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "../node_modules/lodash/_defineProperty.js"(exports, module) {
      var getNative = require_getNative();
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      module.exports = defineProperty;
    }
  });

  // ../node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "../node_modules/lodash/_baseAssignValue.js"(exports, module) {
      var defineProperty = require_defineProperty();
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      module.exports = baseAssignValue;
    }
  });

  // ../node_modules/lodash/_assignValue.js
  var require_assignValue = __commonJS({
    "../node_modules/lodash/_assignValue.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module.exports = assignValue;
    }
  });

  // ../node_modules/lodash/_copyObject.js
  var require_copyObject = __commonJS({
    "../node_modules/lodash/_copyObject.js"(exports, module) {
      var assignValue = require_assignValue();
      var baseAssignValue = require_baseAssignValue();
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      module.exports = copyObject;
    }
  });

  // ../node_modules/lodash/_baseAssign.js
  var require_baseAssign = __commonJS({
    "../node_modules/lodash/_baseAssign.js"(exports, module) {
      var copyObject = require_copyObject();
      var keys4 = require_keys();
      function baseAssign(object, source) {
        return object && copyObject(source, keys4(source), object);
      }
      module.exports = baseAssign;
    }
  });

  // ../node_modules/lodash/_nativeKeysIn.js
  var require_nativeKeysIn = __commonJS({
    "../node_modules/lodash/_nativeKeysIn.js"(exports, module) {
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = nativeKeysIn;
    }
  });

  // ../node_modules/lodash/_baseKeysIn.js
  var require_baseKeysIn = __commonJS({
    "../node_modules/lodash/_baseKeysIn.js"(exports, module) {
      var isObject3 = require_isObject();
      var isPrototype = require_isPrototype();
      var nativeKeysIn = require_nativeKeysIn();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject3(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeysIn;
    }
  });

  // ../node_modules/lodash/keysIn.js
  var require_keysIn = __commonJS({
    "../node_modules/lodash/keysIn.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeysIn = require_baseKeysIn();
      var isArrayLike = require_isArrayLike();
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      module.exports = keysIn;
    }
  });

  // ../node_modules/lodash/_baseAssignIn.js
  var require_baseAssignIn = __commonJS({
    "../node_modules/lodash/_baseAssignIn.js"(exports, module) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      module.exports = baseAssignIn;
    }
  });

  // ../node_modules/lodash/_cloneBuffer.js
  var require_cloneBuffer = __commonJS({
    "../node_modules/lodash/_cloneBuffer.js"(exports, module) {
      var root = require_root();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      module.exports = cloneBuffer;
    }
  });

  // ../node_modules/lodash/_copyArray.js
  var require_copyArray = __commonJS({
    "../node_modules/lodash/_copyArray.js"(exports, module) {
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      module.exports = copyArray;
    }
  });

  // ../node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "../node_modules/lodash/_arrayFilter.js"(exports, module) {
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module.exports = arrayFilter;
    }
  });

  // ../node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "../node_modules/lodash/stubArray.js"(exports, module) {
      function stubArray() {
        return [];
      }
      module.exports = stubArray;
    }
  });

  // ../node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "../node_modules/lodash/_getSymbols.js"(exports, module) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      module.exports = getSymbols;
    }
  });

  // ../node_modules/lodash/_copySymbols.js
  var require_copySymbols = __commonJS({
    "../node_modules/lodash/_copySymbols.js"(exports, module) {
      var copyObject = require_copyObject();
      var getSymbols = require_getSymbols();
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      module.exports = copySymbols;
    }
  });

  // ../node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "../node_modules/lodash/_arrayPush.js"(exports, module) {
      function arrayPush(array, values2) {
        var index = -1, length = values2.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values2[index];
        }
        return array;
      }
      module.exports = arrayPush;
    }
  });

  // ../node_modules/lodash/_getPrototype.js
  var require_getPrototype = __commonJS({
    "../node_modules/lodash/_getPrototype.js"(exports, module) {
      var overArg = require_overArg();
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      module.exports = getPrototype;
    }
  });

  // ../node_modules/lodash/_getSymbolsIn.js
  var require_getSymbolsIn = __commonJS({
    "../node_modules/lodash/_getSymbolsIn.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var getPrototype = require_getPrototype();
      var getSymbols = require_getSymbols();
      var stubArray = require_stubArray();
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      module.exports = getSymbolsIn;
    }
  });

  // ../node_modules/lodash/_copySymbolsIn.js
  var require_copySymbolsIn = __commonJS({
    "../node_modules/lodash/_copySymbolsIn.js"(exports, module) {
      var copyObject = require_copyObject();
      var getSymbolsIn = require_getSymbolsIn();
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      module.exports = copySymbolsIn;
    }
  });

  // ../node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "../node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var isArray3 = require_isArray();
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray3(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      module.exports = baseGetAllKeys;
    }
  });

  // ../node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "../node_modules/lodash/_getAllKeys.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys4 = require_keys();
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys4, getSymbols);
      }
      module.exports = getAllKeys;
    }
  });

  // ../node_modules/lodash/_getAllKeysIn.js
  var require_getAllKeysIn = __commonJS({
    "../node_modules/lodash/_getAllKeysIn.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbolsIn = require_getSymbolsIn();
      var keysIn = require_keysIn();
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      module.exports = getAllKeysIn;
    }
  });

  // ../node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "../node_modules/lodash/_DataView.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var DataView = getNative(root, "DataView");
      module.exports = DataView;
    }
  });

  // ../node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "../node_modules/lodash/_Promise.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module.exports = Promise2;
    }
  });

  // ../node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "../node_modules/lodash/_Set.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module.exports = Set2;
    }
  });

  // ../node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "../node_modules/lodash/_WeakMap.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap = getNative(root, "WeakMap");
      module.exports = WeakMap;
    }
  });

  // ../node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "../node_modules/lodash/_getTag.js"(exports, module) {
      var DataView = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap);
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module.exports = getTag;
    }
  });

  // ../node_modules/lodash/_initCloneArray.js
  var require_initCloneArray = __commonJS({
    "../node_modules/lodash/_initCloneArray.js"(exports, module) {
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      module.exports = initCloneArray;
    }
  });

  // ../node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "../node_modules/lodash/_Uint8Array.js"(exports, module) {
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module.exports = Uint8Array2;
    }
  });

  // ../node_modules/lodash/_cloneArrayBuffer.js
  var require_cloneArrayBuffer = __commonJS({
    "../node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
      var Uint8Array2 = require_Uint8Array();
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      module.exports = cloneArrayBuffer;
    }
  });

  // ../node_modules/lodash/_cloneDataView.js
  var require_cloneDataView = __commonJS({
    "../node_modules/lodash/_cloneDataView.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      module.exports = cloneDataView;
    }
  });

  // ../node_modules/lodash/_cloneRegExp.js
  var require_cloneRegExp = __commonJS({
    "../node_modules/lodash/_cloneRegExp.js"(exports, module) {
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      module.exports = cloneRegExp;
    }
  });

  // ../node_modules/lodash/_cloneSymbol.js
  var require_cloneSymbol = __commonJS({
    "../node_modules/lodash/_cloneSymbol.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      module.exports = cloneSymbol;
    }
  });

  // ../node_modules/lodash/_cloneTypedArray.js
  var require_cloneTypedArray = __commonJS({
    "../node_modules/lodash/_cloneTypedArray.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      module.exports = cloneTypedArray;
    }
  });

  // ../node_modules/lodash/_initCloneByTag.js
  var require_initCloneByTag = __commonJS({
    "../node_modules/lodash/_initCloneByTag.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      var cloneDataView = require_cloneDataView();
      var cloneRegExp = require_cloneRegExp();
      var cloneSymbol = require_cloneSymbol();
      var cloneTypedArray = require_cloneTypedArray();
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      module.exports = initCloneByTag;
    }
  });

  // ../node_modules/lodash/_baseCreate.js
  var require_baseCreate = __commonJS({
    "../node_modules/lodash/_baseCreate.js"(exports, module) {
      var isObject3 = require_isObject();
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject3(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      module.exports = baseCreate;
    }
  });

  // ../node_modules/lodash/_initCloneObject.js
  var require_initCloneObject = __commonJS({
    "../node_modules/lodash/_initCloneObject.js"(exports, module) {
      var baseCreate = require_baseCreate();
      var getPrototype = require_getPrototype();
      var isPrototype = require_isPrototype();
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      module.exports = initCloneObject;
    }
  });

  // ../node_modules/lodash/_baseIsMap.js
  var require_baseIsMap = __commonJS({
    "../node_modules/lodash/_baseIsMap.js"(exports, module) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var mapTag = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      module.exports = baseIsMap;
    }
  });

  // ../node_modules/lodash/isMap.js
  var require_isMap = __commonJS({
    "../node_modules/lodash/isMap.js"(exports, module) {
      var baseIsMap = require_baseIsMap();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      module.exports = isMap;
    }
  });

  // ../node_modules/lodash/_baseIsSet.js
  var require_baseIsSet = __commonJS({
    "../node_modules/lodash/_baseIsSet.js"(exports, module) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var setTag = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      module.exports = baseIsSet;
    }
  });

  // ../node_modules/lodash/isSet.js
  var require_isSet = __commonJS({
    "../node_modules/lodash/isSet.js"(exports, module) {
      var baseIsSet = require_baseIsSet();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      module.exports = isSet;
    }
  });

  // ../node_modules/lodash/_baseClone.js
  var require_baseClone = __commonJS({
    "../node_modules/lodash/_baseClone.js"(exports, module) {
      var Stack = require_Stack();
      var arrayEach = require_arrayEach();
      var assignValue = require_assignValue();
      var baseAssign = require_baseAssign();
      var baseAssignIn = require_baseAssignIn();
      var cloneBuffer = require_cloneBuffer();
      var copyArray = require_copyArray();
      var copySymbols = require_copySymbols();
      var copySymbolsIn = require_copySymbolsIn();
      var getAllKeys = require_getAllKeys();
      var getAllKeysIn = require_getAllKeysIn();
      var getTag = require_getTag();
      var initCloneArray = require_initCloneArray();
      var initCloneByTag = require_initCloneByTag();
      var initCloneObject = require_initCloneObject();
      var isArray3 = require_isArray();
      var isBuffer = require_isBuffer();
      var isMap = require_isMap();
      var isObject3 = require_isObject();
      var isSet = require_isSet();
      var keys4 = require_keys();
      var keysIn = require_keysIn();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_FLAT_FLAG = 2;
      var CLONE_SYMBOLS_FLAG = 4;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject3(value)) {
          return value;
        }
        var isArr = isArray3(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys4;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      module.exports = baseClone;
    }
  });

  // ../node_modules/lodash/cloneDeepWith.js
  var require_cloneDeepWith = __commonJS({
    "../node_modules/lodash/cloneDeepWith.js"(exports, module) {
      var baseClone = require_baseClone();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_SYMBOLS_FLAG = 4;
      function cloneDeepWith2(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : void 0;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      module.exports = cloneDeepWith2;
    }
  });

  // ../node_modules/lodash/isUndefined.js
  var require_isUndefined = __commonJS({
    "../node_modules/lodash/isUndefined.js"(exports, module) {
      function isUndefined2(value) {
        return value === void 0;
      }
      module.exports = isUndefined2;
    }
  });

  // ../node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "../node_modules/lodash/_arrayMap.js"(exports, module) {
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      module.exports = arrayMap;
    }
  });

  // ../node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "../node_modules/lodash/_setCacheAdd.js"(exports, module) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module.exports = setCacheAdd;
    }
  });

  // ../node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "../node_modules/lodash/_setCacheHas.js"(exports, module) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module.exports = setCacheHas;
    }
  });

  // ../node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "../node_modules/lodash/_SetCache.js"(exports, module) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module.exports = SetCache;
    }
  });

  // ../node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "../node_modules/lodash/_arraySome.js"(exports, module) {
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      module.exports = arraySome;
    }
  });

  // ../node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "../node_modules/lodash/_cacheHas.js"(exports, module) {
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      module.exports = cacheHas;
    }
  });

  // ../node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "../node_modules/lodash/_equalArrays.js"(exports, module) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      module.exports = equalArrays;
    }
  });

  // ../node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "../node_modules/lodash/_mapToArray.js"(exports, module) {
      function mapToArray(map4) {
        var index = -1, result = Array(map4.size);
        map4.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      module.exports = mapToArray;
    }
  });

  // ../node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "../node_modules/lodash/_setToArray.js"(exports, module) {
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      module.exports = setToArray;
    }
  });

  // ../node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "../node_modules/lodash/_equalByTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module.exports = equalByTag;
    }
  });

  // ../node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "../node_modules/lodash/_equalObjects.js"(exports, module) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      module.exports = equalObjects;
    }
  });

  // ../node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "../node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
      var Stack = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray3 = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray3(object), othIsArr = isArray3(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      module.exports = baseIsEqualDeep;
    }
  });

  // ../node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "../node_modules/lodash/_baseIsEqual.js"(exports, module) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike = require_isObjectLike();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module.exports = baseIsEqual;
    }
  });

  // ../node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "../node_modules/lodash/_baseIsMatch.js"(exports, module) {
      var Stack = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module.exports = baseIsMatch;
    }
  });

  // ../node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "../node_modules/lodash/_isStrictComparable.js"(exports, module) {
      var isObject3 = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject3(value);
      }
      module.exports = isStrictComparable;
    }
  });

  // ../node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "../node_modules/lodash/_getMatchData.js"(exports, module) {
      var isStrictComparable = require_isStrictComparable();
      var keys4 = require_keys();
      function getMatchData(object) {
        var result = keys4(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module.exports = getMatchData;
    }
  });

  // ../node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "../node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      module.exports = matchesStrictComparable;
    }
  });

  // ../node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "../node_modules/lodash/_baseMatches.js"(exports, module) {
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      module.exports = baseMatches;
    }
  });

  // ../node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "../node_modules/lodash/isSymbol.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module.exports = isSymbol;
    }
  });

  // ../node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "../node_modules/lodash/_isKey.js"(exports, module) {
      var isArray3 = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray3(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      module.exports = isKey;
    }
  });

  // ../node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "../node_modules/lodash/memoize.js"(exports, module) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      module.exports = memoize;
    }
  });

  // ../node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "../node_modules/lodash/_memoizeCapped.js"(exports, module) {
      var memoize = require_memoize();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      module.exports = memoizeCapped;
    }
  });

  // ../node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "../node_modules/lodash/_stringToPath.js"(exports, module) {
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      module.exports = stringToPath;
    }
  });

  // ../node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "../node_modules/lodash/_baseToString.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray3 = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray3(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = baseToString;
    }
  });

  // ../node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "../node_modules/lodash/toString.js"(exports, module) {
      var baseToString = require_baseToString();
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      module.exports = toString3;
    }
  });

  // ../node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "../node_modules/lodash/_castPath.js"(exports, module) {
      var isArray3 = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString3 = require_toString();
      function castPath(value, object) {
        if (isArray3(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString3(value));
      }
      module.exports = castPath;
    }
  });

  // ../node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "../node_modules/lodash/_toKey.js"(exports, module) {
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = toKey;
    }
  });

  // ../node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "../node_modules/lodash/_baseGet.js"(exports, module) {
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      module.exports = baseGet;
    }
  });

  // ../node_modules/lodash/get.js
  var require_get = __commonJS({
    "../node_modules/lodash/get.js"(exports, module) {
      var baseGet = require_baseGet();
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      module.exports = get;
    }
  });

  // ../node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "../node_modules/lodash/_baseHasIn.js"(exports, module) {
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      module.exports = baseHasIn;
    }
  });

  // ../node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "../node_modules/lodash/_hasPath.js"(exports, module) {
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray3 = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray3(object) || isArguments(object));
      }
      module.exports = hasPath;
    }
  });

  // ../node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "../node_modules/lodash/hasIn.js"(exports, module) {
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      module.exports = hasIn;
    }
  });

  // ../node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "../node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
      var baseIsEqual = require_baseIsEqual();
      var get = require_get();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module.exports = baseMatchesProperty;
    }
  });

  // ../node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "../node_modules/lodash/_baseProperty.js"(exports, module) {
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      module.exports = baseProperty;
    }
  });

  // ../node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "../node_modules/lodash/_basePropertyDeep.js"(exports, module) {
      var baseGet = require_baseGet();
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      module.exports = basePropertyDeep;
    }
  });

  // ../node_modules/lodash/property.js
  var require_property = __commonJS({
    "../node_modules/lodash/property.js"(exports, module) {
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      module.exports = property;
    }
  });

  // ../node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "../node_modules/lodash/_baseIteratee.js"(exports, module) {
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity = require_identity();
      var isArray3 = require_isArray();
      var property = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      module.exports = baseIteratee;
    }
  });

  // ../node_modules/lodash/_baseMap.js
  var require_baseMap = __commonJS({
    "../node_modules/lodash/_baseMap.js"(exports, module) {
      var baseEach = require_baseEach();
      var isArrayLike = require_isArrayLike();
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      module.exports = baseMap;
    }
  });

  // ../node_modules/lodash/map.js
  var require_map = __commonJS({
    "../node_modules/lodash/map.js"(exports, module) {
      var arrayMap = require_arrayMap();
      var baseIteratee = require_baseIteratee();
      var baseMap = require_baseMap();
      var isArray3 = require_isArray();
      function map4(collection, iteratee) {
        var func = isArray3(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee, 3));
      }
      module.exports = map4;
    }
  });

  // ../node_modules/lodash/_arrayReduce.js
  var require_arrayReduce = __commonJS({
    "../node_modules/lodash/_arrayReduce.js"(exports, module) {
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      module.exports = arrayReduce;
    }
  });

  // ../node_modules/lodash/_baseReduce.js
  var require_baseReduce = __commonJS({
    "../node_modules/lodash/_baseReduce.js"(exports, module) {
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      module.exports = baseReduce;
    }
  });

  // ../node_modules/lodash/reduce.js
  var require_reduce = __commonJS({
    "../node_modules/lodash/reduce.js"(exports, module) {
      var arrayReduce = require_arrayReduce();
      var baseEach = require_baseEach();
      var baseIteratee = require_baseIteratee();
      var baseReduce = require_baseReduce();
      var isArray3 = require_isArray();
      function reduce3(collection, iteratee, accumulator) {
        var func = isArray3(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
      }
      module.exports = reduce3;
    }
  });

  // ../node_modules/lodash/_baseFilter.js
  var require_baseFilter = __commonJS({
    "../node_modules/lodash/_baseFilter.js"(exports, module) {
      var baseEach = require_baseEach();
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result.push(value);
          }
        });
        return result;
      }
      module.exports = baseFilter;
    }
  });

  // ../node_modules/lodash/negate.js
  var require_negate = __commonJS({
    "../node_modules/lodash/negate.js"(exports, module) {
      var FUNC_ERROR_TEXT = "Expected a function";
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      module.exports = negate;
    }
  });

  // ../node_modules/lodash/reject.js
  var require_reject = __commonJS({
    "../node_modules/lodash/reject.js"(exports, module) {
      var arrayFilter = require_arrayFilter();
      var baseFilter = require_baseFilter();
      var baseIteratee = require_baseIteratee();
      var isArray3 = require_isArray();
      var negate = require_negate();
      function reject2(collection, predicate) {
        var func = isArray3(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(baseIteratee(predicate, 3)));
      }
      module.exports = reject2;
    }
  });

  // ../node_modules/lodash/replace.js
  var require_replace = __commonJS({
    "../node_modules/lodash/replace.js"(exports, module) {
      var toString3 = require_toString();
      function replace2() {
        var args = arguments, string = toString3(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      module.exports = replace2;
    }
  });

  // ../node_modules/lodash/_trimmedEndIndex.js
  var require_trimmedEndIndex = __commonJS({
    "../node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      module.exports = trimmedEndIndex;
    }
  });

  // ../node_modules/lodash/_baseTrim.js
  var require_baseTrim = __commonJS({
    "../node_modules/lodash/_baseTrim.js"(exports, module) {
      var trimmedEndIndex = require_trimmedEndIndex();
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      module.exports = baseTrim;
    }
  });

  // ../node_modules/lodash/_baseSlice.js
  var require_baseSlice = __commonJS({
    "../node_modules/lodash/_baseSlice.js"(exports, module) {
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start];
        }
        return result;
      }
      module.exports = baseSlice;
    }
  });

  // ../node_modules/lodash/_castSlice.js
  var require_castSlice = __commonJS({
    "../node_modules/lodash/_castSlice.js"(exports, module) {
      var baseSlice = require_baseSlice();
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      module.exports = castSlice;
    }
  });

  // ../node_modules/lodash/_baseFindIndex.js
  var require_baseFindIndex = __commonJS({
    "../node_modules/lodash/_baseFindIndex.js"(exports, module) {
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      module.exports = baseFindIndex;
    }
  });

  // ../node_modules/lodash/_baseIsNaN.js
  var require_baseIsNaN = __commonJS({
    "../node_modules/lodash/_baseIsNaN.js"(exports, module) {
      function baseIsNaN(value) {
        return value !== value;
      }
      module.exports = baseIsNaN;
    }
  });

  // ../node_modules/lodash/_strictIndexOf.js
  var require_strictIndexOf = __commonJS({
    "../node_modules/lodash/_strictIndexOf.js"(exports, module) {
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      module.exports = strictIndexOf;
    }
  });

  // ../node_modules/lodash/_baseIndexOf.js
  var require_baseIndexOf = __commonJS({
    "../node_modules/lodash/_baseIndexOf.js"(exports, module) {
      var baseFindIndex = require_baseFindIndex();
      var baseIsNaN = require_baseIsNaN();
      var strictIndexOf = require_strictIndexOf();
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      module.exports = baseIndexOf;
    }
  });

  // ../node_modules/lodash/_charsEndIndex.js
  var require_charsEndIndex = __commonJS({
    "../node_modules/lodash/_charsEndIndex.js"(exports, module) {
      var baseIndexOf = require_baseIndexOf();
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      module.exports = charsEndIndex;
    }
  });

  // ../node_modules/lodash/_charsStartIndex.js
  var require_charsStartIndex = __commonJS({
    "../node_modules/lodash/_charsStartIndex.js"(exports, module) {
      var baseIndexOf = require_baseIndexOf();
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      module.exports = charsStartIndex;
    }
  });

  // ../node_modules/lodash/_asciiToArray.js
  var require_asciiToArray = __commonJS({
    "../node_modules/lodash/_asciiToArray.js"(exports, module) {
      function asciiToArray(string) {
        return string.split("");
      }
      module.exports = asciiToArray;
    }
  });

  // ../node_modules/lodash/_hasUnicode.js
  var require_hasUnicode = __commonJS({
    "../node_modules/lodash/_hasUnicode.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      module.exports = hasUnicode;
    }
  });

  // ../node_modules/lodash/_unicodeToArray.js
  var require_unicodeToArray = __commonJS({
    "../node_modules/lodash/_unicodeToArray.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      module.exports = unicodeToArray;
    }
  });

  // ../node_modules/lodash/_stringToArray.js
  var require_stringToArray = __commonJS({
    "../node_modules/lodash/_stringToArray.js"(exports, module) {
      var asciiToArray = require_asciiToArray();
      var hasUnicode = require_hasUnicode();
      var unicodeToArray = require_unicodeToArray();
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      module.exports = stringToArray;
    }
  });

  // ../node_modules/lodash/trim.js
  var require_trim = __commonJS({
    "../node_modules/lodash/trim.js"(exports, module) {
      var baseToString = require_baseToString();
      var baseTrim = require_baseTrim();
      var castSlice = require_castSlice();
      var charsEndIndex = require_charsEndIndex();
      var charsStartIndex = require_charsStartIndex();
      var stringToArray = require_stringToArray();
      var toString3 = require_toString();
      function trim2(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === void 0)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      module.exports = trim2;
    }
  });

  // ../node_modules/moment/moment.js
  var require_moment = __commonJS({
    "../node_modules/moment/moment.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
      })(exports, function() {
        "use strict";
        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray3(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
        }
        function isObject3(input) {
          return input != null && Object.prototype.toString.call(input) === "[object Object]";
        }
        function hasOwnProp(a3, b3) {
          return Object.prototype.hasOwnProperty.call(a3, b3);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k3;
            for (k3 in obj) {
              if (hasOwnProp(obj, k3)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined2(input) {
          return input === void 0;
        }
        function isNumber2(input) {
          return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
        }
        function map4(arr, fn2) {
          var res = [], i3, arrLen = arr.length;
          for (i3 = 0; i3 < arrLen; ++i3) {
            res.push(fn2(arr[i3], i3));
          }
          return res;
        }
        function extend(a3, b3) {
          for (var i3 in b3) {
            if (hasOwnProp(b3, i3)) {
              a3[i3] = b3[i3];
            }
          }
          if (hasOwnProp(b3, "toString")) {
            a3.toString = b3.toString;
          }
          if (hasOwnProp(b3, "valueOf")) {
            a3.valueOf = b3.valueOf;
          }
          return a3;
        }
        function createUTC(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, true).utc();
        }
        function defaultParsingFlags() {
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m3) {
          if (m3._pf == null) {
            m3._pf = defaultParsingFlags();
          }
          return m3._pf;
        }
        var some2;
        if (Array.prototype.some) {
          some2 = Array.prototype.some;
        } else {
          some2 = function(fun) {
            var t3 = Object(this), len = t3.length >>> 0, i3;
            for (i3 = 0; i3 < len; i3++) {
              if (i3 in t3 && fun.call(this, t3[i3], i3, t3)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid2(m3) {
          if (m3._isValid == null) {
            var flags = getParsingFlags(m3), parsedParts = some2.call(flags.parsedDateParts, function(i3) {
              return i3 != null;
            }), isNowValid = !isNaN(m3._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m3._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m3)) {
              m3._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m3._isValid;
        }
        function createInvalid(flags) {
          var m3 = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m3), flags);
          } else {
            getParsingFlags(m3).userInvalidated = true;
          }
          return m3;
        }
        var momentProperties = hooks.momentProperties = [], updateInProgress = false;
        function copyConfig(to2, from2) {
          var i3, prop, val, momentPropertiesLen = momentProperties.length;
          if (!isUndefined2(from2._isAMomentObject)) {
            to2._isAMomentObject = from2._isAMomentObject;
          }
          if (!isUndefined2(from2._i)) {
            to2._i = from2._i;
          }
          if (!isUndefined2(from2._f)) {
            to2._f = from2._f;
          }
          if (!isUndefined2(from2._l)) {
            to2._l = from2._l;
          }
          if (!isUndefined2(from2._strict)) {
            to2._strict = from2._strict;
          }
          if (!isUndefined2(from2._tzm)) {
            to2._tzm = from2._tzm;
          }
          if (!isUndefined2(from2._isUTC)) {
            to2._isUTC = from2._isUTC;
          }
          if (!isUndefined2(from2._offset)) {
            to2._offset = from2._offset;
          }
          if (!isUndefined2(from2._pf)) {
            to2._pf = getParsingFlags(from2);
          }
          if (!isUndefined2(from2._locale)) {
            to2._locale = from2._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i3 = 0; i3 < momentPropertiesLen; i3++) {
              prop = momentProperties[i3];
              val = from2[prop];
              if (!isUndefined2(val)) {
                to2[prop] = val;
              }
            }
          }
          return to2;
        }
        function Moment3(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = /* @__PURE__ */ new Date(NaN);
          }
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment3 || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
          }
        }
        function deprecate(msg, fn2) {
          var firstTime = true;
          return extend(function() {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [], arg, i3, key, argLen = arguments.length;
              for (i3 = 0; i3 < argLen; i3++) {
                arg = "";
                if (typeof arguments[i3] === "object") {
                  arg += "\n[" + i3 + "] ";
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                  }
                  arg = arg.slice(0, -2);
                } else {
                  arg = arguments[i3];
                }
                args.push(arg);
              }
              warn(
                msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
              );
              firstTime = false;
            }
            return fn2.apply(this, arguments);
          }, fn2);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction2(input) {
          return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
        }
        function set2(config) {
          var prop, i3;
          for (i3 in config) {
            if (hasOwnProp(config, i3)) {
              prop = config[i3];
              if (isFunction2(prop)) {
                this[i3] = prop;
              } else {
                this["_" + i3] = prop;
              }
            }
          }
          this._config = config;
          this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
          );
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject3(parentConfig[prop]) && isObject3(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject3(parentConfig[prop])) {
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys4;
        if (Object.keys) {
          keys4 = Object.keys;
        } else {
          keys4 = function(obj) {
            var i3, res = [];
            for (i3 in obj) {
              if (hasOwnProp(obj, i3)) {
                res.push(i3);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        };
        function calendar(key, mom, now2) {
          var output = this._calendar[key] || this._calendar["sameElse"];
          return isFunction2(output) ? output.call(mom, now2) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
          return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
        function addFormatToken(token2, padded, ordinal2, callback) {
          var func = callback;
          if (typeof callback === "string") {
            func = function() {
              return this[callback]();
            };
          }
          if (token2) {
            formatTokenFunctions[token2] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function() {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal2) {
            formatTokenFunctions[ordinal2] = function() {
              return this.localeData().ordinal(
                func.apply(this, arguments),
                token2
              );
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
          }
          return input.replace(/\\/g, "");
        }
        function makeFormatFunction(format2) {
          var array = format2.match(formattingTokens), i3, length;
          for (i3 = 0, length = array.length; i3 < length; i3++) {
            if (formatTokenFunctions[array[i3]]) {
              array[i3] = formatTokenFunctions[array[i3]];
            } else {
              array[i3] = removeFormattingTokens(array[i3]);
            }
          }
          return function(mom) {
            var output = "", i4;
            for (i4 = 0; i4 < length; i4++) {
              output += isFunction2(array[i4]) ? array[i4].call(mom, format2) : array[i4];
            }
            return output;
          };
        }
        function formatMoment(m3, format2) {
          if (!m3.isValid()) {
            return m3.localeData().invalidDate();
          }
          format2 = expandFormat(format2, m3.localeData());
          formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
          return formatFunctions[format2](m3);
        }
        function expandFormat(format2, locale2) {
          var i3 = 5;
          function replaceLongDateFormatTokens(input) {
            return locale2.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i3 >= 0 && localFormattingTokens.test(format2)) {
            format2 = format2.replace(
              localFormattingTokens,
              replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i3 -= 1;
          }
          return format2;
        }
        var defaultLongDateFormat = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        };
        function longDateFormat(key) {
          var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format2 || !formatUpper) {
            return format2;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
              return tok.slice(1);
            }
            return tok;
          }).join("");
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = "Invalid date";
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace("%d", number);
        }
        var defaultRelativeTime = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction2(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff2, output) {
          var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
          return isFunction2(format2) ? format2(output) : format2.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {}, normalizedProp, prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [], u3;
          for (u3 in unitsObj) {
            if (hasOwnProp(unitsObj, u3)) {
              units.push({ unit: u3, priority: priorities[u3] });
            }
          }
          units.sort(function(a3, b3) {
            return a3.priority - b3.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number) {
          if (number < 0) {
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion, value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        function makeGetSet(unit, keepTime) {
          return function(value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get(this, unit);
            }
          };
        }
        function get(mom, unit) {
          return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
        }
        function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
                value,
                mom.month(),
                daysInMonth(value, mom.month())
              );
            } else {
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
            }
          }
        }
        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction2(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i3, prioritizedLen = prioritized.length;
            for (i3 = 0; i3 < prioritizedLen; i3++) {
              this[prioritized[i3].unit](units[prioritized[i3].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction2(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
        regexes = {};
        function addRegexToken(token2, regex, strictRegex) {
          regexes[token2] = isFunction2(regex) ? regex : function(isStrict, localeData2) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token2, config) {
          if (!hasOwnProp(regexes, token2)) {
            return new RegExp(unescapeFormat(token2));
          }
          return regexes[token2](config._strict, config._locale);
        }
        function unescapeFormat(s3) {
          return regexEscape(
            s3.replace("\\", "").replace(
              /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
              function(matched, p1, p22, p3, p4) {
                return p1 || p22 || p3 || p4;
              }
            )
          );
        }
        function regexEscape(s3) {
          return s3.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        var tokens = {};
        function addParseToken(token2, callback) {
          var i3, func = callback, tokenLen;
          if (typeof token2 === "string") {
            token2 = [token2];
          }
          if (isNumber2(callback)) {
            func = function(input, array) {
              array[callback] = toInt(input);
            };
          }
          tokenLen = token2.length;
          for (i3 = 0; i3 < tokenLen; i3++) {
            tokens[token2[i3]] = func;
          }
        }
        function addWeekParseToken(token2, callback) {
          addParseToken(token2, function(input, array, config, token3) {
            config._w = config._w || {};
            callback(input, config._w, config, token3);
          });
        }
        function addTimeToArrayFromToken(token2, input, config) {
          if (input != null && hasOwnProp(tokens, token2)) {
            tokens[token2](input, config._a, config, token2);
          }
        }
        var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
        function mod2(n3, x3) {
          return (n3 % x3 + x3) % x3;
        }
        var indexOf2;
        if (Array.prototype.indexOf) {
          indexOf2 = Array.prototype.indexOf;
        } else {
          indexOf2 = function(o3) {
            var i3;
            for (i3 = 0; i3 < this.length; ++i3) {
              if (this[i3] === o3) {
                return i3;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod2(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }
        addFormatToken("M", ["MM", 2], "Mo", function() {
          return this.month() + 1;
        });
        addFormatToken("MMM", 0, 0, function(format2) {
          return this.localeData().monthsShort(this, format2);
        });
        addFormatToken("MMMM", 0, 0, function(format2) {
          return this.localeData().months(this, format2);
        });
        addUnitAlias("month", "M");
        addUnitPriority("month", 8);
        addRegexToken("M", match1to2);
        addRegexToken("MM", match1to2, match2);
        addRegexToken("MMM", function(isStrict, locale2) {
          return locale2.monthsShortRegex(isStrict);
        });
        addRegexToken("MMMM", function(isStrict, locale2) {
          return locale2.monthsRegex(isStrict);
        });
        addParseToken(["M", "MM"], function(input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
          var month = config._locale.monthsParse(input, token2, config._strict);
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });
        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
        function localeMonths(m3, format2) {
          if (!m3) {
            return isArray3(this._months) ? this._months : this._months["standalone"];
          }
          return isArray3(this._months) ? this._months[m3.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m3.month()];
        }
        function localeMonthsShort(m3, format2) {
          if (!m3) {
            return isArray3(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
          }
          return isArray3(this._monthsShort) ? this._monthsShort[m3.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m3.month()];
        }
        function handleStrictParse(monthName, format2, strict) {
          var i3, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i3 = 0; i3 < 12; ++i3) {
              mom = createUTC([2e3, i3]);
              this._shortMonthsParse[i3] = this.monthsShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._longMonthsParse[i3] = this.months(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "MMM") {
              ii = indexOf2.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "MMM") {
              ii = indexOf2.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format2, strict) {
          var i3, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format2, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i3 = 0; i3 < 12; i3++) {
            mom = createUTC([2e3, i3]);
            if (strict && !this._longMonthsParse[i3]) {
              this._longMonthsParse[i3] = new RegExp(
                "^" + this.months(mom, "").replace(".", "") + "$",
                "i"
              );
              this._shortMonthsParse[i3] = new RegExp(
                "^" + this.monthsShort(mom, "").replace(".", "") + "$",
                "i"
              );
            }
            if (!strict && !this._monthsParse[i3]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i3] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "MMMM" && this._longMonthsParse[i3].test(monthName)) {
              return i3;
            } else if (strict && format2 === "MMM" && this._shortMonthsParse[i3].test(monthName)) {
              return i3;
            } else if (!strict && this._monthsParse[i3].test(monthName)) {
              return i3;
            }
          }
        }
        function setMonth(mom, value) {
          var dayOfMonth;
          if (!mom.isValid()) {
            return mom;
          }
          if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              if (!isNumber2(value)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get(this, "Month");
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a3, b3) {
            return b3.length - a3.length;
          }
          var shortPieces = [], longPieces = [], mixedPieces = [], i3, mom;
          for (i3 = 0; i3 < 12; i3++) {
            mom = createUTC([2e3, i3]);
            shortPieces.push(this.monthsShort(mom, ""));
            longPieces.push(this.months(mom, ""));
            mixedPieces.push(this.months(mom, ""));
            mixedPieces.push(this.monthsShort(mom, ""));
          }
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i3 = 0; i3 < 12; i3++) {
            shortPieces[i3] = regexEscape(shortPieces[i3]);
            longPieces[i3] = regexEscape(longPieces[i3]);
          }
          for (i3 = 0; i3 < 24; i3++) {
            mixedPieces[i3] = regexEscape(mixedPieces[i3]);
          }
          this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._monthsShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken("Y", 0, 0, function() {
          var y3 = this.year();
          return y3 <= 9999 ? zeroFill(y3, 4) : "+" + y3;
        });
        addFormatToken(0, ["YY", 2], 0, function() {
          return this.year() % 100;
        });
        addFormatToken(0, ["YYYY", 4], 0, "year");
        addFormatToken(0, ["YYYYY", 5], 0, "year");
        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
        addUnitAlias("year", "y");
        addUnitPriority("year", 1);
        addRegexToken("Y", matchSigned);
        addRegexToken("YY", match1to2, match2);
        addRegexToken("YYYY", match1to4, match4);
        addRegexToken("YYYYY", match1to6, match6);
        addRegexToken("YYYYYY", match1to6, match6);
        addParseToken(["YYYYY", "YYYYYY"], YEAR);
        addParseToken("YYYY", function(input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken("YY", function(input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken("Y", function(input, array) {
          array[YEAR] = parseInt(input, 10);
        });
        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }
        hooks.parseTwoDigitYear = function(input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
        };
        var getSetYear = makeGetSet("FullYear", true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y3, m3, d3, h3, M3, s3, ms) {
          var date;
          if (y3 < 100 && y3 >= 0) {
            date = new Date(y3 + 400, m3, d3, h3, M3, s3, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y3);
            }
          } else {
            date = new Date(y3, m3, d3, h3, M3, s3, ms);
          }
          return date;
        }
        function createUTCDate(y3) {
          var date, args;
          if (y3 < 100 && y3 >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y3 + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y3);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }
        function firstWeekOffset(year, dow, doy) {
          var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }
        addFormatToken("w", ["ww", 2], "wo", "week");
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
        addUnitAlias("week", "w");
        addUnitAlias("isoWeek", "W");
        addUnitPriority("week", 5);
        addUnitPriority("isoWeek", 5);
        addRegexToken("w", match1to2);
        addRegexToken("ww", match1to2, match2);
        addRegexToken("W", match1to2);
        addRegexToken("WW", match1to2, match2);
        addWeekParseToken(
          ["w", "ww", "W", "WW"],
          function(input, week, config, token2) {
            week[token2.substr(0, 1)] = toInt(input);
          }
        );
        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }
        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        addFormatToken("d", 0, "do", "day");
        addFormatToken("dd", 0, 0, function(format2) {
          return this.localeData().weekdaysMin(this, format2);
        });
        addFormatToken("ddd", 0, 0, function(format2) {
          return this.localeData().weekdaysShort(this, format2);
        });
        addFormatToken("dddd", 0, 0, function(format2) {
          return this.localeData().weekdays(this, format2);
        });
        addFormatToken("e", 0, 0, "weekday");
        addFormatToken("E", 0, 0, "isoWeekday");
        addUnitAlias("day", "d");
        addUnitAlias("weekday", "e");
        addUnitAlias("isoWeekday", "E");
        addUnitPriority("day", 11);
        addUnitPriority("weekday", 11);
        addUnitPriority("isoWeekday", 11);
        addRegexToken("d", match1to2);
        addRegexToken("e", match1to2);
        addRegexToken("E", match1to2);
        addRegexToken("dd", function(isStrict, locale2) {
          return locale2.weekdaysMinRegex(isStrict);
        });
        addRegexToken("ddd", function(isStrict, locale2) {
          return locale2.weekdaysShortRegex(isStrict);
        });
        addRegexToken("dddd", function(isStrict, locale2) {
          return locale2.weekdaysRegex(isStrict);
        });
        addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
          var weekday = config._locale.weekdaysParse(input, token2, config._strict);
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
          week[token2] = toInt(input);
        });
        function parseWeekday(input, locale2) {
          if (typeof input !== "string") {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale2.weekdaysParse(input);
          if (typeof input === "number") {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale2) {
          if (typeof input === "string") {
            return locale2.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }
        function shiftWeekdays(ws, n3) {
          return ws.slice(n3, 7).concat(ws.slice(0, n3));
        }
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m3, format2) {
          var weekdays = isArray3(this._weekdays) ? this._weekdays : this._weekdays[m3 && m3 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
          return m3 === true ? shiftWeekdays(weekdays, this._week.dow) : m3 ? weekdays[m3.day()] : weekdays;
        }
        function localeWeekdaysShort(m3) {
          return m3 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m3 ? this._weekdaysShort[m3.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m3) {
          return m3 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m3 ? this._weekdaysMin[m3.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format2, strict) {
          var i3, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i3 = 0; i3 < 7; ++i3) {
              mom = createUTC([2e3, 1]).day(i3);
              this._minWeekdaysParse[i3] = this.weekdaysMin(
                mom,
                ""
              ).toLocaleLowerCase();
              this._shortWeekdaysParse[i3] = this.weekdaysShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._weekdaysParse[i3] = this.weekdays(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "dddd") {
              ii = indexOf2.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "dddd") {
              ii = indexOf2.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format2, strict) {
          var i3, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format2, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i3 = 0; i3 < 7; i3++) {
            mom = createUTC([2e3, 1]).day(i3);
            if (strict && !this._fullWeekdaysParse[i3]) {
              this._fullWeekdaysParse[i3] = new RegExp(
                "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._shortWeekdaysParse[i3] = new RegExp(
                "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._minWeekdaysParse[i3] = new RegExp(
                "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
            }
            if (!this._weekdaysParse[i3]) {
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i3] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "dddd" && this._fullWeekdaysParse[i3].test(weekdayName)) {
              return i3;
            } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i3].test(weekdayName)) {
              return i3;
            } else if (strict && format2 === "dd" && this._minWeekdaysParse[i3].test(weekdayName)) {
              return i3;
            } else if (!strict && this._weekdaysParse[i3].test(weekdayName)) {
              return i3;
            }
          }
        }
        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a3, b3) {
            return b3.length - a3.length;
          }
          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i3, mom, minp, shortp, longp;
          for (i3 = 0; i3 < 7; i3++) {
            mom = createUTC([2e3, 1]).day(i3);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._weekdaysShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
          this._weekdaysMinStrictRegex = new RegExp(
            "^(" + minPieces.join("|") + ")",
            "i"
          );
        }
        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken("H", ["HH", 2], 0, "hour");
        addFormatToken("h", ["hh", 2], 0, hFormat);
        addFormatToken("k", ["kk", 2], 0, kFormat);
        addFormatToken("hmm", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken("hmmss", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken("Hmm", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken("Hmmss", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token2, lowercase) {
          addFormatToken(token2, 0, 0, function() {
            return this.localeData().meridiem(
              this.hours(),
              this.minutes(),
              lowercase
            );
          });
        }
        meridiem("a", true);
        meridiem("A", false);
        addUnitAlias("hour", "h");
        addUnitPriority("hour", 13);
        function matchMeridiem(isStrict, locale2) {
          return locale2._meridiemParse;
        }
        addRegexToken("a", matchMeridiem);
        addRegexToken("A", matchMeridiem);
        addRegexToken("H", match1to2);
        addRegexToken("h", match1to2);
        addRegexToken("k", match1to2);
        addRegexToken("HH", match1to2, match2);
        addRegexToken("hh", match1to2, match2);
        addRegexToken("kk", match1to2, match2);
        addRegexToken("hmm", match3to4);
        addRegexToken("hmmss", match5to6);
        addRegexToken("Hmm", match3to4);
        addRegexToken("Hmmss", match5to6);
        addParseToken(["H", "HH"], HOUR);
        addParseToken(["k", "kk"], function(input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(["a", "A"], function(input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(["h", "hh"], function(input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("Hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken("Hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });
        function localeIsPM(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
        function localeMeridiem(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };
        var locales = {}, localeFamilies = {}, globalLocale;
        function commonPrefix(arr1, arr2) {
          var i3, minl = Math.min(arr1.length, arr2.length);
          for (i3 = 0; i3 < minl; i3 += 1) {
            if (arr1[i3] !== arr2[i3]) {
              return i3;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace("_", "-") : key;
        }
        function chooseLocale(names) {
          var i3 = 0, j3, next, locale2, split2;
          while (i3 < names.length) {
            split2 = normalizeLocale(names[i3]).split("-");
            j3 = split2.length;
            next = normalizeLocale(names[i3 + 1]);
            next = next ? next.split("-") : null;
            while (j3 > 0) {
              locale2 = loadLocale(split2.slice(0, j3).join("-"));
              if (locale2) {
                return locale2;
              }
              if (next && next.length >= j3 && commonPrefix(split2, next) >= j3 - 1) {
                break;
              }
              j3--;
            }
            i3++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          return name.match("^[^/\\\\]*$") != null;
        }
        function loadLocale(name) {
          var oldLocale = null, aliasedRequire;
          if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = __require;
              aliasedRequire("./locale/" + name);
              getSetGlobalLocale(oldLocale);
            } catch (e2) {
              locales[name] = null;
            }
          }
          return locales[name];
        }
        function getSetGlobalLocale(key, values2) {
          var data;
          if (key) {
            if (isUndefined2(values2)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values2);
            }
            if (data) {
              globalLocale = data;
            } else {
              if (typeof console !== "undefined" && console.warn) {
                console.warn(
                  "Locale " + key + " not found. Did you forget to load it?"
                );
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale2, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple(
                "defineLocaleOverride",
                "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
              );
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale2 = loadLocale(config.parentLocale);
                if (locale2 != null) {
                  parentConfig = locale2._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name,
                    config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function(x3) {
                defineLocale(x3.name, x3.config);
              });
            }
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale2, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                config.abbr = name;
              }
              locale2 = new Locale(config);
              locale2.parentLocale = locales[name];
              locales[name] = locale2;
            }
            getSetGlobalLocale(name);
          } else {
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }
        function getLocale(key) {
          var locale2;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray3(key)) {
            locale2 = loadLocale(key);
            if (locale2) {
              return locale2;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys4(locales);
        }
        function checkOverflow(m3) {
          var overflow, a3 = m3._a;
          if (a3 && getParsingFlags(m3).overflow === -2) {
            overflow = a3[MONTH] < 0 || a3[MONTH] > 11 ? MONTH : a3[DATE] < 1 || a3[DATE] > daysInMonth(a3[YEAR], a3[MONTH]) ? DATE : a3[HOUR] < 0 || a3[HOUR] > 24 || a3[HOUR] === 24 && (a3[MINUTE] !== 0 || a3[SECOND] !== 0 || a3[MILLISECOND] !== 0) ? HOUR : a3[MINUTE] < 0 || a3[MINUTE] > 59 ? MINUTE : a3[SECOND] < 0 || a3[SECOND] > 59 ? SECOND : a3[MILLISECOND] < 0 || a3[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m3)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m3)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m3)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m3).overflow = overflow;
          }
          return m3;
        }
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
          ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
          ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
          ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
          ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
          ["YYYY-DDD", /\d{4}-\d{3}/],
          ["YYYY-MM", /\d{4}-\d\d/, false],
          ["YYYYYYMMDD", /[+-]\d{10}/],
          ["YYYYMMDD", /\d{8}/],
          ["GGGG[W]WWE", /\d{4}W\d{3}/],
          ["GGGG[W]WW", /\d{4}W\d{2}/, false],
          ["YYYYDDD", /\d{7}/],
          ["YYYYMM", /\d{6}/, false],
          ["YYYY", /\d{4}/, false]
        ], isoTimes = [
          ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
          ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
          ["HH:mm:ss", /\d\d:\d\d:\d\d/],
          ["HH:mm", /\d\d:\d\d/],
          ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
          ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
          ["HHmmss", /\d\d\d\d\d\d/],
          ["HHmm", /\d\d\d\d/],
          ["HH", /\d\d/]
        ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };
        function configFromISO(config) {
          var i3, l3, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i3 = 0, l3 = isoDatesLen; i3 < l3; i3++) {
              if (isoDates[i3][1].exec(match[1])) {
                dateFormat = isoDates[i3][0];
                allowTime = isoDates[i3][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i3 = 0, l3 = isoTimesLen; i3 < l3; i3++) {
                if (isoTimes[i3][1].exec(match[3])) {
                  timeFormat = (match[2] || " ") + isoTimes[i3][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = "Z";
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
          ];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2e3 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s3) {
          return s3.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
              parsedInput[0],
              parsedInput[1],
              parsedInput[2]
            ).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            return 0;
          } else {
            var hm = parseInt(numOffset, 10), m3 = hm % 100, h3 = (hm - m3) / 100;
            return h3 * 60 + m3;
          }
        }
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(
              match[4],
              match[3],
              match[2],
              match[5],
              match[6],
              match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = /* @__PURE__ */ new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate(
          "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
          function(config) {
            config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
          }
        );
        function defaults(a3, b3, c3) {
          if (a3 != null) {
            return a3;
          }
          if (b3 != null) {
            return b3;
          }
          return c3;
        }
        function currentDateArray(config) {
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [
              nowValue.getUTCFullYear(),
              nowValue.getUTCMonth(),
              nowValue.getUTCDate()
            ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }
        function configFromArray(config) {
          var i3, date, input = [], currentDate, expectedWeekday, yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }
          for (i3 = 0; i3 < 3 && config._a[i3] == null; ++i3) {
            config._a[i3] = input[i3] = currentDate[i3];
          }
          for (; i3 < 7; i3++) {
            config._a[i3] = input[i3] = config._a[i3] == null ? i3 === 2 ? 1 : 0 : config._a[i3];
          }
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
          );
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }
          if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w3, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w3 = config._w;
          if (w3.GG != null || w3.W != null || w3.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(
              w3.GG,
              config._a[YEAR],
              weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w3.W, 1);
            weekday = defaults(w3.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w3.gg, config._a[YEAR], curWeek.year);
            week = defaults(w3.w, curWeek.week);
            if (w3.d != null) {
              weekday = w3.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w3.e != null) {
              weekday = w3.e + dow;
              if (w3.e < 0 || w3.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }
        hooks.ISO_8601 = function() {
        };
        hooks.RFC_2822 = function() {
        };
        function configFromStringAndFormat(config) {
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;
          var string = "" + config._i, i3, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
          tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens2.length;
          for (i3 = 0; i3 < tokenLen; i3++) {
            token2 = tokens2[i3];
            parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(
                string.indexOf(parsedInput) + parsedInput.length
              );
              totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token2]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token2);
              }
              addTimeToArrayFromToken(token2, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token2);
            }
          }
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = void 0;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
          );
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale2, hour, meridiem2) {
          var isPm;
          if (meridiem2 == null) {
            return hour;
          }
          if (locale2.meridiemHour != null) {
            return locale2.meridiemHour(hour, meridiem2);
          } else if (locale2.isPM != null) {
            isPm = locale2.isPM(meridiem2);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            return hour;
          }
        }
        function configFromStringAndArray(config) {
          var tempConfig, bestMoment, scoreToBeat, i3, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
          if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = /* @__PURE__ */ new Date(NaN);
            return;
          }
          for (i3 = 0; i3 < configfLen; i3++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i3];
            configFromStringAndFormat(tempConfig);
            if (isValid2(tempConfig)) {
              validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i3 = normalizeObjectUnits(config._i), dayOrDate = i3.day === void 0 ? i3.date : i3.day;
          config._a = map4(
            [i3.year, i3.month, dayOrDate, i3.hour, i3.minute, i3.second, i3.millisecond],
            function(obj) {
              return obj && parseInt(obj, 10);
            }
          );
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment3(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = void 0;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i, format2 = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format2 === void 0 && input === "") {
            return createInvalid({ nullInput: true });
          }
          if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment3(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray3(format2)) {
            configFromStringAndArray(config);
          } else if (format2) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid2(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined2(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === "string") {
            configFromString(config);
          } else if (isArray3(input)) {
            config._a = map4(input.slice(0), function(obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject3(input)) {
            configFromObject(config);
          } else if (isNumber2(input)) {
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
          var c3 = {};
          if (format2 === true || format2 === false) {
            strict = format2;
            format2 = void 0;
          }
          if (locale2 === true || locale2 === false) {
            strict = locale2;
            locale2 = void 0;
          }
          if (isObject3(input) && isObjectEmpty(input) || isArray3(input) && input.length === 0) {
            input = void 0;
          }
          c3._isAMomentObject = true;
          c3._useUTC = c3._isUTC = isUTC;
          c3._l = locale2;
          c3._i = input;
          c3._f = format2;
          c3._strict = strict;
          return createFromConfig(c3);
        }
        function createLocal(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, false);
        }
        var prototypeMin = deprecate(
          "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }
        ), prototypeMax = deprecate(
          "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          }
        );
        function pickBy2(fn2, moments) {
          var res, i3;
          if (moments.length === 1 && isArray3(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i3 = 1; i3 < moments.length; ++i3) {
            if (!moments[i3].isValid() || moments[i3][fn2](res)) {
              res = moments[i3];
            }
          }
          return res;
        }
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy2("isBefore", args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy2("isAfter", args);
        }
        var now = function() {
          return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
        };
        var ordering = [
          "year",
          "quarter",
          "month",
          "week",
          "day",
          "hour",
          "minute",
          "second",
          "millisecond"
        ];
        function isDurationValid(m3) {
          var key, unitHasDecimal = false, i3, orderLen = ordering.length;
          for (key in m3) {
            if (hasOwnProp(m3, key) && !(indexOf2.call(ordering, key) !== -1 && (m3[key] == null || !isNaN(m3[key])))) {
              return false;
            }
          }
          for (i3 = 0; i3 < orderLen; ++i3) {
            if (m3[ordering[i3]]) {
              if (unitHasDecimal) {
                return false;
              }
              if (parseFloat(m3[ordering[i3]]) !== toInt(m3[ordering[i3]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration2(duration) {
          var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);
          this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
          minutes2 * 6e4 + // 1000 * 60
          hours2 * 1e3 * 60 * 60;
          this._days = +days2 + weeks2 * 7;
          this._months = +months2 + quarters * 3 + years2 * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration2;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i3;
          for (i3 = 0; i3 < len; i3++) {
            if (dontConvert && array1[i3] !== array2[i3] || !dontConvert && toInt(array1[i3]) !== toInt(array2[i3])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }
        function offset(token2, separator) {
          addFormatToken(token2, 0, 0, function() {
            var offset2 = this.utcOffset(), sign2 = "+";
            if (offset2 < 0) {
              offset2 = -offset2;
              sign2 = "-";
            }
            return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
          });
        }
        offset("Z", ":");
        offset("ZZ", "");
        addRegexToken("Z", matchShortOffset);
        addRegexToken("ZZ", matchShortOffset);
        addParseToken(["Z", "ZZ"], function(input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || "").match(matcher), chunk, parts, minutes2;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
          minutes2 = +(parts[1] * 60) + toInt(parts[2]);
          return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
        }
        function cloneWithOffset(input, model) {
          var res, diff2;
          if (model._isUTC) {
            res = model.clone();
            diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff2);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m3) {
          return -Math.round(m3._d.getTimezoneOffset());
        }
        hooks.updateOffset = function() {
        };
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset2 = this._offset || 0, localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === "string") {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, "m");
            }
            if (offset2 !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(
                  this,
                  createDuration(input - offset2, "m"),
                  1,
                  false
                );
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset2 : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== "string") {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), "m");
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined2(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c3 = {}, other;
          copyConfig(c3, this);
          c3 = prepareConfig(c3);
          if (c3._a) {
            other = c3._isUTC ? createUTC(c3._a) : createLocal(c3._a);
            this._isDSTShifted = this.isValid() && compareArrays(c3._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input, match = null, sign2, ret, diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber2(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign2,
              h: toInt(match[HOUR]) * sign2,
              m: toInt(match[MINUTE]) * sign2,
              s: toInt(match[SECOND]) * sign2,
              ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
              // the millisecond decimal point is included in the match
            };
          } else if (match = isoRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign2),
              M: parseIso(match[3], sign2),
              w: parseIso(match[4], sign2),
              d: parseIso(match[5], sign2),
              h: parseIso(match[6], sign2),
              m: parseIso(match[7], sign2),
              s: parseIso(match[8], sign2)
            };
          } else if (duration == null) {
            duration = {};
          } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(
              createLocal(duration.from),
              createLocal(duration.to)
            );
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration2(duration);
          if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration2.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign2) {
          var res = inp && parseFloat(inp.replace(",", "."));
          return (isNaN(res) ? 0 : res) * sign2;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, "M");
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }
        function createAdder(direction, name) {
          return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(
                name,
                "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
              );
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
          if (!mom.isValid()) {
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months2) {
            setMonth(mom, get(mom, "Month") + months2 * isAdding);
          }
          if (days2) {
            set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
          }
          if (milliseconds2) {
            mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days2 || months2);
          }
        }
        var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
        function isString3(input) {
          return typeof input === "string" || input instanceof String;
        }
        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString3(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject3(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "years",
            "year",
            "y",
            "months",
            "month",
            "M",
            "days",
            "day",
            "d",
            "dates",
            "date",
            "D",
            "hours",
            "hour",
            "h",
            "minutes",
            "minute",
            "m",
            "seconds",
            "second",
            "s",
            "milliseconds",
            "millisecond",
            "ms"
          ], i3, property, propertyLen = properties.length;
          for (i3 = 0; i3 < propertyLen; i3 += 1) {
            property = properties[i3];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray3(input), dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function(item) {
              return !isNumber2(item) && isString3(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject3(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "sameDay",
            "nextDay",
            "lastDay",
            "nextWeek",
            "lastWeek",
            "sameElse"
          ], i3, property;
          for (i3 = 0; i3 < properties.length; i3 += 1) {
            property = properties[i3];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now2) {
          var diff2 = myMoment.diff(now2, "days", true);
          return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
        }
        function calendar$1(time, formats) {
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = void 0;
              formats = void 0;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = void 0;
            }
          }
          var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction2(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
          return this.format(
            output || this.localeData().calendar(format2, this, createLocal(now2))
          );
        }
        function clone() {
          return new Moment3(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from2, to2, units, inclusivity) {
          var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || "()";
          return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input), inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              output = monthDiff(this, that) / 12;
              break;
            case "month":
              output = monthDiff(this, that);
              break;
            case "quarter":
              output = monthDiff(this, that) / 3;
              break;
            case "second":
              output = (this - that) / 1e3;
              break;
            case "minute":
              output = (this - that) / 6e4;
              break;
            case "hour":
              output = (this - that) / 36e5;
              break;
            case "day":
              output = (this - that - zoneDelta) / 864e5;
              break;
            case "week":
              output = (this - that - zoneDelta) / 6048e5;
              break;
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a3, b3) {
          if (a3.date() < b3.date()) {
            return -monthDiff(b3, a3);
          }
          var wholeMonthDiff = (b3.year() - a3.year()) * 12 + (b3.month() - a3.month()), anchor = a3.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
          if (b3 - anchor < 0) {
            anchor2 = a3.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b3 - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a3.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b3 - anchor) / (anchor2 - anchor);
          }
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        function toString3() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true, m3 = utc ? this.clone().utc() : this;
          if (m3.year() < 0 || m3.year() > 9999) {
            return formatMoment(
              m3,
              utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
            );
          }
          if (isFunction2(Date.prototype.toISOString)) {
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m3, "Z"));
            }
          }
          return formatMoment(
            m3,
            utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        function inspect() {
          if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
          }
          var func = "moment", zone = "", prefix, year, datetime, suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
          }
          prefix = "[" + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
          datetime = "-MM-DD[T]HH:mm:ss.SSS";
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }
        function locale(key) {
          var newLocaleData;
          if (key === void 0) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate(
          "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
          function(key) {
            if (key === void 0) {
              return this.localeData();
            } else {
              return this.locale(key);
            }
          }
        );
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y3, m3, d3) {
          if (y3 < 100 && y3 >= 0) {
            return new Date(y3 + 400, m3, d3) - MS_PER_400_YEARS;
          } else {
            return new Date(y3, m3, d3).valueOf();
          }
        }
        function utcStartOfDate(y3, m3, d3) {
          if (y3 < 100 && y3 >= 0) {
            return Date.UTC(y3 + 400, m3, d3) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y3, m3, d3);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year(), 0, 1);
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3,
                1
              );
              break;
            case "month":
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday()
              );
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1)
              );
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case "hour":
              time = this._d.valueOf();
              time -= mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              );
              break;
            case "minute":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case "second":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3 + 3,
                1
              ) - 1;
              break;
            case "month":
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday() + 7
              ) - 1;
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1) + 7
              ) - 1;
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              ) - 1;
              break;
            case "minute":
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case "second":
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 6e4;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1e3);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m3 = this;
          return [
            m3.year(),
            m3.month(),
            m3.date(),
            m3.hour(),
            m3.minute(),
            m3.second(),
            m3.millisecond()
          ];
        }
        function toObject() {
          var m3 = this;
          return {
            years: m3.year(),
            months: m3.month(),
            date: m3.date(),
            hours: m3.hours(),
            minutes: m3.minutes(),
            seconds: m3.seconds(),
            milliseconds: m3.milliseconds()
          };
        }
        function toJSON() {
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid2(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken("N", 0, 0, "eraAbbr");
        addFormatToken("NN", 0, 0, "eraAbbr");
        addFormatToken("NNN", 0, 0, "eraAbbr");
        addFormatToken("NNNN", 0, 0, "eraName");
        addFormatToken("NNNNN", 0, 0, "eraNarrow");
        addFormatToken("y", ["y", 1], "yo", "eraYear");
        addFormatToken("y", ["yy", 2], 0, "eraYear");
        addFormatToken("y", ["yyy", 3], 0, "eraYear");
        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
        addRegexToken("N", matchEraAbbr);
        addRegexToken("NN", matchEraAbbr);
        addRegexToken("NNN", matchEraAbbr);
        addRegexToken("NNNN", matchEraName);
        addRegexToken("NNNNN", matchEraNarrow);
        addParseToken(
          ["N", "NN", "NNN", "NNNN", "NNNNN"],
          function(input, array, config, token2) {
            var era = config._locale.erasParse(input, token2, config._strict);
            if (era) {
              getParsingFlags(config).era = era;
            } else {
              getParsingFlags(config).invalidEra = input;
            }
          }
        );
        addRegexToken("y", matchUnsigned);
        addRegexToken("yy", matchUnsigned);
        addRegexToken("yyy", matchUnsigned);
        addRegexToken("yyyy", matchUnsigned);
        addRegexToken("yo", matchEraYearOrdinal);
        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
        addParseToken(["yo"], function(input, array, config, token2) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m3, format2) {
          var i3, l3, date, eras = this._eras || getLocale("en")._eras;
          for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
            switch (typeof eras[i3].since) {
              case "string":
                date = hooks(eras[i3].since).startOf("day");
                eras[i3].since = date.valueOf();
                break;
            }
            switch (typeof eras[i3].until) {
              case "undefined":
                eras[i3].until = Infinity;
                break;
              case "string":
                date = hooks(eras[i3].until).startOf("day").valueOf();
                eras[i3].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format2, strict) {
          var i3, l3, eras = this.eras(), name, abbr, narrow;
          eraName = eraName.toUpperCase();
          for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
            name = eras[i3].name.toUpperCase();
            abbr = eras[i3].abbr.toUpperCase();
            narrow = eras[i3].narrow.toUpperCase();
            if (strict) {
              switch (format2) {
                case "N":
                case "NN":
                case "NNN":
                  if (abbr === eraName) {
                    return eras[i3];
                  }
                  break;
                case "NNNN":
                  if (name === eraName) {
                    return eras[i3];
                  }
                  break;
                case "NNNNN":
                  if (narrow === eraName) {
                    return eras[i3];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i3];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? 1 : -1;
          if (year === void 0) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i3, l3, val, eras = this.localeData().eras();
          for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i3].since <= val && val <= eras[i3].until) {
              return eras[i3].name;
            }
            if (eras[i3].until <= val && val <= eras[i3].since) {
              return eras[i3].name;
            }
          }
          return "";
        }
        function getEraNarrow() {
          var i3, l3, val, eras = this.localeData().eras();
          for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i3].since <= val && val <= eras[i3].until) {
              return eras[i3].narrow;
            }
            if (eras[i3].until <= val && val <= eras[i3].since) {
              return eras[i3].narrow;
            }
          }
          return "";
        }
        function getEraAbbr() {
          var i3, l3, val, eras = this.localeData().eras();
          for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i3].since <= val && val <= eras[i3].until) {
              return eras[i3].abbr;
            }
            if (eras[i3].until <= val && val <= eras[i3].since) {
              return eras[i3].abbr;
            }
          }
          return "";
        }
        function getEraYear() {
          var i3, l3, dir, val, eras = this.localeData().eras();
          for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
            dir = eras[i3].since <= eras[i3].until ? 1 : -1;
            val = this.clone().startOf("day").valueOf();
            if (eras[i3].since <= val && val <= eras[i3].until || eras[i3].until <= val && val <= eras[i3].since) {
              return (this.year() - hooks(eras[i3].since).year()) * dir + eras[i3].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale2) {
          return locale2.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale2) {
          return locale2.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale2) {
          return locale2.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale2) {
          return locale2._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i3, l3, eras = this.eras();
          for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
            namePieces.push(regexEscape(eras[i3].name));
            abbrPieces.push(regexEscape(eras[i3].abbr));
            narrowPieces.push(regexEscape(eras[i3].narrow));
            mixedPieces.push(regexEscape(eras[i3].name));
            mixedPieces.push(regexEscape(eras[i3].abbr));
            mixedPieces.push(regexEscape(eras[i3].narrow));
          }
          this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
          this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
          this._erasNarrowRegex = new RegExp(
            "^(" + narrowPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken(0, ["gg", 2], 0, function() {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ["GG", 2], 0, function() {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token2, getter) {
          addFormatToken(0, [token2, token2.length], 0, getter);
        }
        addWeekYearFormatToken("gggg", "weekYear");
        addWeekYearFormatToken("ggggg", "weekYear");
        addWeekYearFormatToken("GGGG", "isoWeekYear");
        addWeekYearFormatToken("GGGGG", "isoWeekYear");
        addUnitAlias("weekYear", "gg");
        addUnitAlias("isoWeekYear", "GG");
        addUnitPriority("weekYear", 1);
        addUnitPriority("isoWeekYear", 1);
        addRegexToken("G", matchSigned);
        addRegexToken("g", matchSigned);
        addRegexToken("GG", match1to2, match2);
        addRegexToken("gg", match1to2, match2);
        addRegexToken("GGGG", match1to4, match4);
        addRegexToken("gggg", match1to4, match4);
        addRegexToken("GGGGG", match1to6, match6);
        addRegexToken("ggggg", match1to6, match6);
        addWeekParseToken(
          ["gggg", "ggggg", "GGGG", "GGGGG"],
          function(input, week, config, token2) {
            week[token2.substr(0, 2)] = toInt(input);
          }
        );
        addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
          week[token2] = hooks.parseTwoDigitYear(input);
        });
        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
          );
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
          );
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }
        addFormatToken("Q", 0, "Qo", "quarter");
        addUnitAlias("quarter", "Q");
        addUnitPriority("quarter", 7);
        addRegexToken("Q", match1);
        addParseToken("Q", function(input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });
        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
        addFormatToken("D", ["DD", 2], "Do", "date");
        addUnitAlias("date", "D");
        addUnitPriority("date", 9);
        addRegexToken("D", match1to2);
        addRegexToken("DD", match1to2, match2);
        addRegexToken("Do", function(isStrict, locale2) {
          return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(["D", "DD"], DATE);
        addParseToken("Do", function(input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });
        var getSetDayOfMonth = makeGetSet("Date", true);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
        addUnitAlias("dayOfYear", "DDD");
        addUnitPriority("dayOfYear", 4);
        addRegexToken("DDD", match1to3);
        addRegexToken("DDDD", match3);
        addParseToken(["DDD", "DDDD"], function(input, array, config) {
          config._dayOfYear = toInt(input);
        });
        function getSetDayOfYear(input) {
          var dayOfYear = Math.round(
            (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
          ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        }
        addFormatToken("m", ["mm", 2], 0, "minute");
        addUnitAlias("minute", "m");
        addUnitPriority("minute", 14);
        addRegexToken("m", match1to2);
        addRegexToken("mm", match1to2, match2);
        addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", false);
        addFormatToken("s", ["ss", 2], 0, "second");
        addUnitAlias("second", "s");
        addUnitPriority("second", 15);
        addRegexToken("s", match1to2);
        addRegexToken("ss", match1to2, match2);
        addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", false);
        addFormatToken("S", 0, 0, function() {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ["SS", 2], 0, function() {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ["SSS", 3], 0, "millisecond");
        addFormatToken(0, ["SSSS", 4], 0, function() {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ["SSSSS", 5], 0, function() {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ["SSSSSS", 6], 0, function() {
          return this.millisecond() * 1e3;
        });
        addFormatToken(0, ["SSSSSSS", 7], 0, function() {
          return this.millisecond() * 1e4;
        });
        addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
          return this.millisecond() * 1e5;
        });
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
          return this.millisecond() * 1e6;
        });
        addUnitAlias("millisecond", "ms");
        addUnitPriority("millisecond", 16);
        addRegexToken("S", match1to3, match1);
        addRegexToken("SS", match1to3, match2);
        addRegexToken("SSS", match1to3, match3);
        var token, getSetMillisecond;
        for (token = "SSSS"; token.length <= 9; token += "S") {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(("0." + input) * 1e3);
        }
        for (token = "S"; token.length <= 9; token += "S") {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet("Milliseconds", false);
        addFormatToken("z", 0, 0, "zoneAbbr");
        addFormatToken("zz", 0, 0, "zoneName");
        function getZoneAbbr() {
          return this._isUTC ? "UTC" : "";
        }
        function getZoneName() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        }
        var proto = Moment3.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== "undefined" && Symbol.for != null) {
          proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString3;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
          "dates accessor is deprecated. Use date instead.",
          getSetDayOfMonth
        );
        proto.months = deprecate(
          "months accessor is deprecated. Use month instead",
          getSetMonth
        );
        proto.years = deprecate(
          "years accessor is deprecated. Use year instead",
          getSetYear
        );
        proto.zone = deprecate(
          "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
          getSetZone
        );
        proto.isDSTShifted = deprecate(
          "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
          isDaylightSavingTimeShifted
        );
        function createUnix(input) {
          return createLocal(input * 1e3);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set2;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format2, index, field, setter) {
          var locale2 = getLocale(), utc = createUTC().set(setter, index);
          return locale2[field](utc, format2);
        }
        function listMonthsImpl(format2, index, field) {
          if (isNumber2(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
          if (index != null) {
            return get$1(format2, index, field, "month");
          }
          var i3, out = [];
          for (i3 = 0; i3 < 12; i3++) {
            out[i3] = get$1(format2, i3, field, "month");
          }
          return out;
        }
        function listWeekdaysImpl(localeSorted, format2, index, field) {
          if (typeof localeSorted === "boolean") {
            if (isNumber2(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          } else {
            format2 = localeSorted;
            index = format2;
            localeSorted = false;
            if (isNumber2(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          }
          var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i3, out = [];
          if (index != null) {
            return get$1(format2, (index + shift) % 7, field, "day");
          }
          for (i3 = 0; i3 < 7; i3++) {
            out[i3] = get$1(format2, (i3 + shift) % 7, field, "day");
          }
          return out;
        }
        function listMonths(format2, index) {
          return listMonthsImpl(format2, index, "months");
        }
        function listMonthsShort(format2, index) {
          return listMonthsImpl(format2, index, "monthsShort");
        }
        function listWeekdays(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
        }
        function listWeekdaysShort(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
        }
        function listWeekdaysMin(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
        }
        getSetGlobalLocale("en", {
          eras: [
            {
              since: "0001-01-01",
              until: Infinity,
              offset: 1,
              name: "Anno Domini",
              narrow: "AD",
              abbr: "AD"
            },
            {
              since: "0000-12-31",
              until: -Infinity,
              offset: 1,
              name: "Before Christ",
              narrow: "BC",
              abbr: "BC"
            }
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function(number) {
            var b3 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b3 === 1 ? "st" : b3 === 2 ? "nd" : b3 === 3 ? "rd" : "th";
            return number + output;
          }
        });
        hooks.lang = deprecate(
          "moment.lang is deprecated. Use moment.locale instead.",
          getSetGlobalLocale
        );
        hooks.langData = deprecate(
          "moment.langData is deprecated. Use moment.localeData instead.",
          getLocale
        );
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
          if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
            milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
            days2 = 0;
            months2 = 0;
          }
          data.milliseconds = milliseconds2 % 1e3;
          seconds2 = absFloor(milliseconds2 / 1e3);
          data.seconds = seconds2 % 60;
          minutes2 = absFloor(seconds2 / 60);
          data.minutes = minutes2 % 60;
          hours2 = absFloor(minutes2 / 60);
          data.hours = hours2 % 24;
          days2 += absFloor(hours2 / 24);
          monthsFromDays = absFloor(daysToMonths(days2));
          months2 += monthsFromDays;
          days2 -= absCeil(monthsToDays(monthsFromDays));
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          data.days = days2;
          data.months = months2;
          data.years = years2;
          return this;
        }
        function daysToMonths(days2) {
          return days2 * 4800 / 146097;
        }
        function monthsToDays(months2) {
          return months2 * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days2, months2, milliseconds2 = this._milliseconds;
          units = normalizeUnits(units);
          if (units === "month" || units === "quarter" || units === "year") {
            days2 = this._days + milliseconds2 / 864e5;
            months2 = this._months + daysToMonths(days2);
            switch (units) {
              case "month":
                return months2;
              case "quarter":
                return months2 / 3;
              case "year":
                return months2 / 12;
            }
          } else {
            days2 = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days2 / 7 + milliseconds2 / 6048e5;
              case "day":
                return days2 + milliseconds2 / 864e5;
              case "hour":
                return days2 * 24 + milliseconds2 / 36e5;
              case "minute":
                return days2 * 1440 + milliseconds2 / 6e4;
              case "second":
                return days2 * 86400 + milliseconds2 / 1e3;
              case "millisecond":
                return Math.floor(days2 * 864e5) + milliseconds2;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        }
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function() {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
        function clone$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + "s"]() : NaN;
        }
        function makeGetter(name) {
          return function() {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round, thresholds = {
          ss: 44,
          // a few seconds to seconds
          s: 45,
          // seconds to minute
          m: 45,
          // minutes to hour
          h: 22,
          // hours to day
          d: 26,
          // days to month/week
          w: null,
          // weeks to month
          M: 11
          // months to year
        };
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
          return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
          var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a3 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
          if (thresholds2.w != null) {
            a3 = a3 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
          }
          a3 = a3 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
          a3[2] = withoutSuffix;
          a3[3] = +posNegDuration > 0;
          a3[4] = locale2;
          return substituteTimeAgo.apply(null, a3);
        }
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === void 0) {
            return round;
          }
          if (typeof roundingFunction === "function") {
            round = roundingFunction;
            return true;
          }
          return false;
        }
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === void 0) {
            return false;
          }
          if (limit === void 0) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === "s") {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false, th = thresholds, locale2, output;
          if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale2 = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale2);
          if (withSuffix) {
            output = locale2.pastFuture(+this, output);
          }
          return locale2.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x3) {
          return (x3 > 0) - (x3 < 0) || +x3;
        }
        function toISOString$1() {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s3, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
          if (!total) {
            return "P0D";
          }
          minutes2 = absFloor(seconds2 / 60);
          hours2 = absFloor(minutes2 / 60);
          seconds2 %= 60;
          minutes2 %= 60;
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          s3 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
          totalSign = total < 0 ? "-" : "";
          ymSign = sign(this._months) !== sign(total) ? "-" : "";
          daysSign = sign(this._days) !== sign(total) ? "-" : "";
          hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
          return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s3 + "S" : "");
        }
        var proto$2 = Duration2.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate(
          "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
          toISOString$1
        );
        proto$2.lang = lang;
        addFormatToken("X", 0, 0, "unix");
        addFormatToken("x", 0, 0, "valueOf");
        addRegexToken("x", matchSigned);
        addRegexToken("X", matchTimestamp);
        addParseToken("X", function(input, array, config) {
          config._d = new Date(parseFloat(input) * 1e3);
        });
        addParseToken("x", function(input, array, config) {
          config._d = new Date(toInt(input));
        });
        hooks.version = "2.29.4";
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          // <input type="datetime-local" step="0.001" />
          DATE: "YYYY-MM-DD",
          // <input type="date" />
          TIME: "HH:mm",
          // <input type="time" />
          TIME_SECONDS: "HH:mm:ss",
          // <input type="time" step="1" />
          TIME_MS: "HH:mm:ss.SSS",
          // <input type="time" step="0.001" />
          WEEK: "GGGG-[W]WW",
          // <input type="week" />
          MONTH: "YYYY-MM"
          // <input type="month" />
        };
        return hooks;
      });
    }
  });

  // ../howdju-common/lib/general.ts
  function mapValuesDeep(obj, fn2, options = { mapArrays: true }, key) {
    const { mapArrays } = options;
    if ((0, import_isArray.default)(obj)) {
      if (mapArrays) {
        return (0, import_map.default)(
          obj,
          (item, idx) => mapValuesDeep(item, fn2, options, idx)
        );
      }
    } else if (isPlainObject(obj)) {
      return (0, import_lodash2.mapValues)(
        obj,
        (val, key2) => mapValuesDeep(val, fn2, options, key2)
      );
    }
    return fn2(obj, key);
  }
  function camelCaseKeysDeep(val) {
    return mapKeysDeep(val, import_lodash2.camelCase);
  }
  function isPlainObject(val) {
    return (0, import_lodash2.isPlainObject)(val);
  }
  function utcNowIsAfter(dateTimeString) {
    return utcNow().isAfter(import_moment.default.utc(dateTimeString));
  }
  function decodeQueryStringObject(param, validKeys) {
    if (!param) {
      return void 0;
    }
    const keyVals = param.split(",");
    const invalidKeys = [];
    const obj = {};
    (0, import_forEach.default)(keyVals, (keyVal) => {
      const [key, val] = keyVal.split("=");
      obj[key] = val;
      if (validKeys && !validKeys.includes(key)) {
        invalidKeys.push(key);
      }
    });
    if (invalidKeys.length) {
      const invalidKeysString = invalidKeys.map((k3) => `"${k3}"`).join(",");
      const validKeysString = validKeys == null ? void 0 : validKeys.map((k3) => `"${k3}"`).join(",");
      throw new Error(
        `Invalid query string keys: [${invalidKeysString}]. Valid keys are: [${validKeysString}]`
      );
    }
    return obj;
  }
  function makeOmittingCloneDeepCustomizer(predicate) {
    return function omittingCloneDeepCustomizer(value) {
      if ((0, import_isObject.default)(value)) {
        if ((0, import_isArray.default)(value)) {
          let result = (0, import_reject.default)(value, predicate);
          result = (0, import_map.default)(
            result,
            (item) => (0, import_cloneDeepWith.default)(item, omittingCloneDeepCustomizer)
          );
          return result;
        }
        const clone = {};
        for (const subKey of Object.keys(value)) {
          if (!predicate(value[subKey])) {
            clone[subKey] = (0, import_cloneDeepWith.default)(
              value[subKey],
              omittingCloneDeepCustomizer
            );
          }
        }
        return clone;
      }
      return void 0;
    };
  }
  function toSlug(text) {
    if (!text) {
      return text;
    }
    text = (0, import_lodash2.toLower)(text);
    text = (0, import_lodash2.deburr)(text);
    return text.replace(/\s+/g, "-").replace(/[^a-zA-Z0-9_-]/g, "");
  }
  function normalizeQuotation(text) {
    text = (0, import_lodash2.toLower)(text);
    text = (0, import_replace.default)(text, /[\p{Mark}\p{Punctuation}\p{Zl}\p{Zp}\p{Other}]/gu, " ");
    text = cleanWhitespace(text);
    return text;
  }
  function filterDefined(items) {
    if ((0, import_isArray.default)(items)) {
      return (0, import_lodash2.filter)(items, (i3) => i3 !== void 0);
    }
    return (0, import_lodash2.pickBy)(items, (i3) => i3 !== void 0);
  }
  function sleep(ms) {
    return __async(this, null, function* () {
      return new Promise((resolve) => setTimeout(() => resolve(), ms));
    });
  }
  function mergeCopy(source1, source2) {
    if ((0, import_isArray.default)(source1) !== (0, import_isArray.default)(source2)) {
      throw newProgrammingError(
        `mergeCopy requires two objects or two arrays: ${typeof source1} and ${typeof source2}`
      );
    }
    const init = (0, import_isArray.default)(source1) ? [] : {};
    return (0, import_lodash2.merge)(init, source1, source2);
  }
  var import_lodash2, import_cloneDeepWith, import_forEach, import_isArray, import_isFunction, import_isObject, import_isUndefined, import_keys, import_map, import_reduce, import_reject, import_replace, import_trim, import_moment, mapKeysDeep, minDate, zeroDate, isTruthy, isFalsey, assert, isDefined, utcNow, momentAdd, momentSubtract, differenceDuration, formatDuration, timestampFormatString, utcTimestamp, arrayToObject, pushAll, insertAt, insertAllAt, removeAt, encodeQueryStringObject, encodeSorts, decodeSorts, toSingleLine, omitDeep, keysTo, toJson, fromJson, cleanWhitespace, normalizeText, toEntries;
  var init_general = __esm({
    "../howdju-common/lib/general.ts"() {
      "use strict";
      import_lodash2 = __toESM(require_lodash());
      import_cloneDeepWith = __toESM(require_cloneDeepWith());
      import_forEach = __toESM(require_forEach());
      import_isArray = __toESM(require_isArray());
      import_isFunction = __toESM(require_isFunction());
      import_isObject = __toESM(require_isObject());
      import_isUndefined = __toESM(require_isUndefined());
      import_keys = __toESM(require_keys());
      import_map = __toESM(require_map());
      import_reduce = __toESM(require_reduce());
      import_reject = __toESM(require_reject());
      import_replace = __toESM(require_replace());
      import_trim = __toESM(require_trim());
      import_moment = __toESM(require_moment());
      init_commonErrors();
      mapKeysDeep = (obj, fn2, parentKey = void 0) => {
        if ((0, import_isArray.default)(obj)) {
          return (0, import_map.default)(
            obj,
            (item, idx) => mapKeysDeep(item, fn2, idx)
          );
        }
        if (isPlainObject(obj)) {
          return Object.fromEntries(
            Object.entries(obj).map(([k3, v3]) => [
              fn2(k3, parentKey),
              mapKeysDeep(v3, fn2, k3)
            ])
          );
        }
        return obj;
      };
      minDate = () => /* @__PURE__ */ new Date(-864e13);
      zeroDate = () => /* @__PURE__ */ new Date(0);
      isTruthy = (val) => !!val;
      isFalsey = (val) => !val;
      assert = (test, message) => {
        if (process.env.DO_ASSERT !== "true") {
          return;
        }
        const makeMessage = () => (
          // If there is a message thunk, use it
          (0, import_isFunction.default)(message) ? message() : (
            // Otherwise if there is a message, use it
            message ? message : (
              // Otherwise, if the test was a thunk, use it as a description
              (0, import_isFunction.default)(test) ? test.toString().substring(0, 1024) : (
                // Otherwise, not much else we can do
                message
              )
            )
          )
        );
        const logError = () => console.error(`Failed assertion: ${makeMessage()}`);
        if ((0, import_isFunction.default)(test)) {
          if (!test()) {
            logError();
          }
        } else if (!test) {
          logError();
        }
      };
      isDefined = (val) => !(0, import_isUndefined.default)(val);
      utcNow = () => import_moment.default.utc();
      momentAdd = (momentInstance, summand) => {
        const result = momentInstance.clone();
        if ((0, import_isArray.default)(summand)) {
          result.add(summand[0], summand[1]);
        } else if ((0, import_isObject.default)(summand)) {
          result.add(summand);
        } else {
          throw newProgrammingError(
            `Invalid moment summand: ${summand} (type: ${typeof summand})`
          );
        }
        return result;
      };
      momentSubtract = (momentInstance, subtrahend) => {
        const result = momentInstance.clone();
        if ((0, import_isArray.default)(subtrahend)) {
          result.subtract(subtrahend[0], subtrahend[1]);
        } else if ((0, import_isObject.default)(subtrahend)) {
          result.subtract(subtrahend);
        } else {
          throw newProgrammingError(
            `Invalid moment subtrahend: ${subtrahend} (type: ${typeof subtrahend})`
          );
        }
        return result;
      };
      differenceDuration = (moment1, moment22) => {
        return import_moment.default.duration(moment1.diff(moment22));
      };
      formatDuration = (duration, { template, trim: trim2 }) => {
        import_moment.default.duration(duration).format(template, { trim: trim2 });
      };
      timestampFormatString = "YYYY-MM-DDTHH:mm:ss.SSS[Z]";
      utcTimestamp = () => utcNow().format(timestampFormatString);
      arrayToObject = (items, itemKey) => (0, import_reduce.default)(
        items,
        (acc, item) => {
          if (itemKey) {
            acc[item[itemKey]] = item;
          } else {
            acc[item] = item;
          }
          return acc;
        },
        {}
      );
      pushAll = (target, source) => {
        target.splice(target.length, 0, ...source);
        return target;
      };
      insertAt = (array, index, item) => {
        if (!(0, import_isArray.default)(array)) {
          throw new Error("first argument must be an array; was: " + typeof array);
        }
        if (!(0, import_lodash2.isNumber)(index)) {
          throw new Error("second argument must be number; was: " + typeof index);
        }
        array.splice(index, 0, item);
        return array;
      };
      insertAllAt = (array, index, items) => {
        if (!(0, import_isArray.default)(array)) {
          throw new Error("first argument must be an array; was: " + typeof array);
        }
        if (!(0, import_lodash2.isNumber)(index)) {
          throw new Error("second argument must be number; was: " + typeof index);
        }
        if (!(0, import_isArray.default)(items)) {
          throw new Error("third argument must be an array; was: " + typeof items);
        }
        const args = [index, 0].concat(items);
        Array.prototype.splice.apply(array, args);
        return array;
      };
      removeAt = (array, index) => {
        array.splice(index, 1);
        return array;
      };
      encodeQueryStringObject = (obj) => (0, import_map.default)(obj, (val, key) => `${key}=${val}`).join(",");
      encodeSorts = (sorts) => (0, import_map.default)(sorts, ({ property, direction }) => `${property}=${direction}`).join(",");
      decodeSorts = (param) => {
        if (!param) {
          return [];
        }
        const propertyDirections = param.split(",");
        const sorts = [];
        (0, import_forEach.default)(propertyDirections, (propertyDirection) => {
          const [property, direction] = propertyDirection.split("=");
          assert(["ascending", "descending"].indexOf(direction) > 0);
          sorts.push({
            property,
            direction
            // There is no `value` because those are not supported in query params
          });
        });
        return sorts;
      };
      toSingleLine = (val) => (0, import_lodash2.isNumber)(val) ? (0, import_lodash2.toString)(val) : val.replace(/^[\r\n]/, "").replace(/[\r\n]$/, "").replace(
        /(\s*)[\r\n]+(\s*)/,
        (_match, leadingWhitespace, trailingWhitespace) => {
          return !leadingWhitespace && !trailingWhitespace ? " " : "";
        }
      );
      omitDeep = function omitDeep2(value, predicate = (val) => !val) {
        return (0, import_cloneDeepWith.default)(value, makeOmittingCloneDeepCustomizer(predicate));
      };
      keysTo = (obj, val) => (0, import_reduce.default)(
        (0, import_keys.default)(obj),
        (acc, key) => {
          acc[key] = val;
          return acc;
        },
        {}
      );
      toJson = function toJson2(val) {
        return JSON.stringify(val);
      };
      fromJson = function fromJson2(json) {
        return JSON.parse(json);
      };
      cleanWhitespace = (text) => {
        text = (0, import_trim.default)(text);
        text = (0, import_replace.default)(text, /\s+/g, " ");
        return text;
      };
      normalizeText = (text) => {
        text = (0, import_lodash2.toLower)(text);
        text = (0, import_lodash2.deburr)(text);
        text = (0, import_replace.default)(text, /[^\w\s]/g, "");
        text = cleanWhitespace(text);
        return text;
      };
      toEntries = (obj) => {
        if (!obj) {
          return [];
        }
        return Object.entries(obj);
      };
    }
  });

  // ../howdju-common/lib/commonPaths.js
  var require_commonPaths = __commonJS({
    "../howdju-common/lib/commonPaths.js"(exports, module) {
      "use strict";
      module.exports.CommonPaths = class CommonPaths {
        confirmRegistration() {
          return "/complete-registration";
        }
        confirmPasswordReset() {
          return "/reset-password";
        }
        login() {
          return "/login";
        }
        requestPasswordReset() {
          return "/request-password-reset";
        }
      };
      module.exports.commonPaths = new module.exports.CommonPaths();
    }
  });

  // ../howdju-common/lib/consts.js
  var require_consts = __commonJS({
    "../howdju-common/lib/consts.js"(exports, module) {
      "use strict";
      module.exports.gitCommitMetadataKey = "howdju-git-commit";
    }
  });

  // ../node_modules/diff-match-patch/index.js
  var require_diff_match_patch = __commonJS({
    "../node_modules/diff-match-patch/index.js"(exports, module) {
      var diff_match_patch = function() {
        this.Diff_Timeout = 1;
        this.Diff_EditCost = 4;
        this.Match_Threshold = 0.5;
        this.Match_Distance = 1e3;
        this.Patch_DeleteThreshold = 0.5;
        this.Patch_Margin = 4;
        this.Match_MaxBits = 32;
      };
      var DIFF_DELETE = -1;
      var DIFF_INSERT = 1;
      var DIFF_EQUAL = 0;
      diff_match_patch.Diff = function(op, text) {
        return [op, text];
      };
      diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
        if (typeof opt_deadline == "undefined") {
          if (this.Diff_Timeout <= 0) {
            opt_deadline = Number.MAX_VALUE;
          } else {
            opt_deadline = (/* @__PURE__ */ new Date()).getTime() + this.Diff_Timeout * 1e3;
          }
        }
        var deadline = opt_deadline;
        if (text1 == null || text2 == null) {
          throw new Error("Null input. (diff_main)");
        }
        if (text1 == text2) {
          if (text1) {
            return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
          }
          return [];
        }
        if (typeof opt_checklines == "undefined") {
          opt_checklines = true;
        }
        var checklines = opt_checklines;
        var commonlength = this.diff_commonPrefix(text1, text2);
        var commonprefix = text1.substring(0, commonlength);
        text1 = text1.substring(commonlength);
        text2 = text2.substring(commonlength);
        commonlength = this.diff_commonSuffix(text1, text2);
        var commonsuffix = text1.substring(text1.length - commonlength);
        text1 = text1.substring(0, text1.length - commonlength);
        text2 = text2.substring(0, text2.length - commonlength);
        var diffs = this.diff_compute_(text1, text2, checklines, deadline);
        if (commonprefix) {
          diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
        }
        if (commonsuffix) {
          diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
        }
        this.diff_cleanupMerge(diffs);
        return diffs;
      };
      diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
        var diffs;
        if (!text1) {
          return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
        }
        if (!text2) {
          return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
        }
        var longtext = text1.length > text2.length ? text1 : text2;
        var shorttext = text1.length > text2.length ? text2 : text1;
        var i3 = longtext.indexOf(shorttext);
        if (i3 != -1) {
          diffs = [
            new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i3)),
            new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
            new diff_match_patch.Diff(
              DIFF_INSERT,
              longtext.substring(i3 + shorttext.length)
            )
          ];
          if (text1.length > text2.length) {
            diffs[0][0] = diffs[2][0] = DIFF_DELETE;
          }
          return diffs;
        }
        if (shorttext.length == 1) {
          return [
            new diff_match_patch.Diff(DIFF_DELETE, text1),
            new diff_match_patch.Diff(DIFF_INSERT, text2)
          ];
        }
        var hm = this.diff_halfMatch_(text1, text2);
        if (hm) {
          var text1_a = hm[0];
          var text1_b = hm[1];
          var text2_a = hm[2];
          var text2_b = hm[3];
          var mid_common = hm[4];
          var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
          var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
          return diffs_a.concat(
            [new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
            diffs_b
          );
        }
        if (checklines && text1.length > 100 && text2.length > 100) {
          return this.diff_lineMode_(text1, text2, deadline);
        }
        return this.diff_bisect_(text1, text2, deadline);
      };
      diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
        var a3 = this.diff_linesToChars_(text1, text2);
        text1 = a3.chars1;
        text2 = a3.chars2;
        var linearray = a3.lineArray;
        var diffs = this.diff_main(text1, text2, false, deadline);
        this.diff_charsToLines_(diffs, linearray);
        this.diff_cleanupSemantic(diffs);
        diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
        var pointer = 0;
        var count_delete = 0;
        var count_insert = 0;
        var text_delete = "";
        var text_insert = "";
        while (pointer < diffs.length) {
          switch (diffs[pointer][0]) {
            case DIFF_INSERT:
              count_insert++;
              text_insert += diffs[pointer][1];
              break;
            case DIFF_DELETE:
              count_delete++;
              text_delete += diffs[pointer][1];
              break;
            case DIFF_EQUAL:
              if (count_delete >= 1 && count_insert >= 1) {
                diffs.splice(
                  pointer - count_delete - count_insert,
                  count_delete + count_insert
                );
                pointer = pointer - count_delete - count_insert;
                var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
                for (var j3 = subDiff.length - 1; j3 >= 0; j3--) {
                  diffs.splice(pointer, 0, subDiff[j3]);
                }
                pointer = pointer + subDiff.length;
              }
              count_insert = 0;
              count_delete = 0;
              text_delete = "";
              text_insert = "";
              break;
          }
          pointer++;
        }
        diffs.pop();
        return diffs;
      };
      diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
        var text1_length = text1.length;
        var text2_length = text2.length;
        var max_d = Math.ceil((text1_length + text2_length) / 2);
        var v_offset = max_d;
        var v_length = 2 * max_d;
        var v1 = new Array(v_length);
        var v22 = new Array(v_length);
        for (var x3 = 0; x3 < v_length; x3++) {
          v1[x3] = -1;
          v22[x3] = -1;
        }
        v1[v_offset + 1] = 0;
        v22[v_offset + 1] = 0;
        var delta = text1_length - text2_length;
        var front = delta % 2 != 0;
        var k1start = 0;
        var k1end = 0;
        var k2start = 0;
        var k2end = 0;
        for (var d3 = 0; d3 < max_d; d3++) {
          if ((/* @__PURE__ */ new Date()).getTime() > deadline) {
            break;
          }
          for (var k1 = -d3 + k1start; k1 <= d3 - k1end; k1 += 2) {
            var k1_offset = v_offset + k1;
            var x1;
            if (k1 == -d3 || k1 != d3 && v1[k1_offset - 1] < v1[k1_offset + 1]) {
              x1 = v1[k1_offset + 1];
            } else {
              x1 = v1[k1_offset - 1] + 1;
            }
            var y1 = x1 - k1;
            while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
              x1++;
              y1++;
            }
            v1[k1_offset] = x1;
            if (x1 > text1_length) {
              k1end += 2;
            } else if (y1 > text2_length) {
              k1start += 2;
            } else if (front) {
              var k2_offset = v_offset + delta - k1;
              if (k2_offset >= 0 && k2_offset < v_length && v22[k2_offset] != -1) {
                var x22 = text1_length - v22[k2_offset];
                if (x1 >= x22) {
                  return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
                }
              }
            }
          }
          for (var k22 = -d3 + k2start; k22 <= d3 - k2end; k22 += 2) {
            var k2_offset = v_offset + k22;
            var x22;
            if (k22 == -d3 || k22 != d3 && v22[k2_offset - 1] < v22[k2_offset + 1]) {
              x22 = v22[k2_offset + 1];
            } else {
              x22 = v22[k2_offset - 1] + 1;
            }
            var y22 = x22 - k22;
            while (x22 < text1_length && y22 < text2_length && text1.charAt(text1_length - x22 - 1) == text2.charAt(text2_length - y22 - 1)) {
              x22++;
              y22++;
            }
            v22[k2_offset] = x22;
            if (x22 > text1_length) {
              k2end += 2;
            } else if (y22 > text2_length) {
              k2start += 2;
            } else if (!front) {
              var k1_offset = v_offset + delta - k22;
              if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                var x1 = v1[k1_offset];
                var y1 = v_offset + x1 - k1_offset;
                x22 = text1_length - x22;
                if (x1 >= x22) {
                  return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
                }
              }
            }
          }
        }
        return [
          new diff_match_patch.Diff(DIFF_DELETE, text1),
          new diff_match_patch.Diff(DIFF_INSERT, text2)
        ];
      };
      diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x3, y3, deadline) {
        var text1a = text1.substring(0, x3);
        var text2a = text2.substring(0, y3);
        var text1b = text1.substring(x3);
        var text2b = text2.substring(y3);
        var diffs = this.diff_main(text1a, text2a, false, deadline);
        var diffsb = this.diff_main(text1b, text2b, false, deadline);
        return diffs.concat(diffsb);
      };
      diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
        var lineArray = [];
        var lineHash = {};
        lineArray[0] = "";
        function diff_linesToCharsMunge_(text) {
          var chars = "";
          var lineStart = 0;
          var lineEnd = -1;
          var lineArrayLength = lineArray.length;
          while (lineEnd < text.length - 1) {
            lineEnd = text.indexOf("\n", lineStart);
            if (lineEnd == -1) {
              lineEnd = text.length - 1;
            }
            var line = text.substring(lineStart, lineEnd + 1);
            if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
              chars += String.fromCharCode(lineHash[line]);
            } else {
              if (lineArrayLength == maxLines) {
                line = text.substring(lineStart);
                lineEnd = text.length;
              }
              chars += String.fromCharCode(lineArrayLength);
              lineHash[line] = lineArrayLength;
              lineArray[lineArrayLength++] = line;
            }
            lineStart = lineEnd + 1;
          }
          return chars;
        }
        var maxLines = 4e4;
        var chars1 = diff_linesToCharsMunge_(text1);
        maxLines = 65535;
        var chars2 = diff_linesToCharsMunge_(text2);
        return { chars1, chars2, lineArray };
      };
      diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
        for (var i3 = 0; i3 < diffs.length; i3++) {
          var chars = diffs[i3][1];
          var text = [];
          for (var j3 = 0; j3 < chars.length; j3++) {
            text[j3] = lineArray[chars.charCodeAt(j3)];
          }
          diffs[i3][1] = text.join("");
        }
      };
      diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
        if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
          return 0;
        }
        var pointermin = 0;
        var pointermax = Math.min(text1.length, text2.length);
        var pointermid = pointermax;
        var pointerstart = 0;
        while (pointermin < pointermid) {
          if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
            pointermin = pointermid;
            pointerstart = pointermin;
          } else {
            pointermax = pointermid;
          }
          pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
        }
        return pointermid;
      };
      diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
        if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
          return 0;
        }
        var pointermin = 0;
        var pointermax = Math.min(text1.length, text2.length);
        var pointermid = pointermax;
        var pointerend = 0;
        while (pointermin < pointermid) {
          if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
            pointermin = pointermid;
            pointerend = pointermin;
          } else {
            pointermax = pointermid;
          }
          pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
        }
        return pointermid;
      };
      diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
        var text1_length = text1.length;
        var text2_length = text2.length;
        if (text1_length == 0 || text2_length == 0) {
          return 0;
        }
        if (text1_length > text2_length) {
          text1 = text1.substring(text1_length - text2_length);
        } else if (text1_length < text2_length) {
          text2 = text2.substring(0, text1_length);
        }
        var text_length = Math.min(text1_length, text2_length);
        if (text1 == text2) {
          return text_length;
        }
        var best = 0;
        var length = 1;
        while (true) {
          var pattern = text1.substring(text_length - length);
          var found = text2.indexOf(pattern);
          if (found == -1) {
            return best;
          }
          length += found;
          if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
            best = length;
            length++;
          }
        }
      };
      diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
        if (this.Diff_Timeout <= 0) {
          return null;
        }
        var longtext = text1.length > text2.length ? text1 : text2;
        var shorttext = text1.length > text2.length ? text2 : text1;
        if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
          return null;
        }
        var dmp = this;
        function diff_halfMatchI_(longtext2, shorttext2, i3) {
          var seed = longtext2.substring(i3, i3 + Math.floor(longtext2.length / 4));
          var j3 = -1;
          var best_common = "";
          var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
          while ((j3 = shorttext2.indexOf(seed, j3 + 1)) != -1) {
            var prefixLength = dmp.diff_commonPrefix(
              longtext2.substring(i3),
              shorttext2.substring(j3)
            );
            var suffixLength = dmp.diff_commonSuffix(
              longtext2.substring(0, i3),
              shorttext2.substring(0, j3)
            );
            if (best_common.length < suffixLength + prefixLength) {
              best_common = shorttext2.substring(j3 - suffixLength, j3) + shorttext2.substring(j3, j3 + prefixLength);
              best_longtext_a = longtext2.substring(0, i3 - suffixLength);
              best_longtext_b = longtext2.substring(i3 + prefixLength);
              best_shorttext_a = shorttext2.substring(0, j3 - suffixLength);
              best_shorttext_b = shorttext2.substring(j3 + prefixLength);
            }
          }
          if (best_common.length * 2 >= longtext2.length) {
            return [
              best_longtext_a,
              best_longtext_b,
              best_shorttext_a,
              best_shorttext_b,
              best_common
            ];
          } else {
            return null;
          }
        }
        var hm1 = diff_halfMatchI_(
          longtext,
          shorttext,
          Math.ceil(longtext.length / 4)
        );
        var hm2 = diff_halfMatchI_(
          longtext,
          shorttext,
          Math.ceil(longtext.length / 2)
        );
        var hm;
        if (!hm1 && !hm2) {
          return null;
        } else if (!hm2) {
          hm = hm1;
        } else if (!hm1) {
          hm = hm2;
        } else {
          hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
        }
        var text1_a, text1_b, text2_a, text2_b;
        if (text1.length > text2.length) {
          text1_a = hm[0];
          text1_b = hm[1];
          text2_a = hm[2];
          text2_b = hm[3];
        } else {
          text2_a = hm[0];
          text2_b = hm[1];
          text1_a = hm[2];
          text1_b = hm[3];
        }
        var mid_common = hm[4];
        return [text1_a, text1_b, text2_a, text2_b, mid_common];
      };
      diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
        var changes = false;
        var equalities = [];
        var equalitiesLength = 0;
        var lastEquality = null;
        var pointer = 0;
        var length_insertions1 = 0;
        var length_deletions1 = 0;
        var length_insertions2 = 0;
        var length_deletions2 = 0;
        while (pointer < diffs.length) {
          if (diffs[pointer][0] == DIFF_EQUAL) {
            equalities[equalitiesLength++] = pointer;
            length_insertions1 = length_insertions2;
            length_deletions1 = length_deletions2;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastEquality = diffs[pointer][1];
          } else {
            if (diffs[pointer][0] == DIFF_INSERT) {
              length_insertions2 += diffs[pointer][1].length;
            } else {
              length_deletions2 += diffs[pointer][1].length;
            }
            if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(
              length_insertions2,
              length_deletions2
            )) {
              diffs.splice(
                equalities[equalitiesLength - 1],
                0,
                new diff_match_patch.Diff(DIFF_DELETE, lastEquality)
              );
              diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
              equalitiesLength--;
              equalitiesLength--;
              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
              length_insertions1 = 0;
              length_deletions1 = 0;
              length_insertions2 = 0;
              length_deletions2 = 0;
              lastEquality = null;
              changes = true;
            }
          }
          pointer++;
        }
        if (changes) {
          this.diff_cleanupMerge(diffs);
        }
        this.diff_cleanupSemanticLossless(diffs);
        pointer = 1;
        while (pointer < diffs.length) {
          if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
            var deletion = diffs[pointer - 1][1];
            var insertion = diffs[pointer][1];
            var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
            var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
            if (overlap_length1 >= overlap_length2) {
              if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
                diffs.splice(pointer, 0, new diff_match_patch.Diff(
                  DIFF_EQUAL,
                  insertion.substring(0, overlap_length1)
                ));
                diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
                diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                pointer++;
              }
            } else {
              if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
                diffs.splice(pointer, 0, new diff_match_patch.Diff(
                  DIFF_EQUAL,
                  deletion.substring(0, overlap_length2)
                ));
                diffs[pointer - 1][0] = DIFF_INSERT;
                diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
                diffs[pointer + 1][0] = DIFF_DELETE;
                diffs[pointer + 1][1] = deletion.substring(overlap_length2);
                pointer++;
              }
            }
            pointer++;
          }
          pointer++;
        }
      };
      diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
        function diff_cleanupSemanticScore_(one, two) {
          if (!one || !two) {
            return 6;
          }
          var char1 = one.charAt(one.length - 1);
          var char2 = two.charAt(0);
          var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
          var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
          var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);
          var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);
          var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);
          var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);
          var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);
          var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);
          if (blankLine1 || blankLine2) {
            return 5;
          } else if (lineBreak1 || lineBreak2) {
            return 4;
          } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
            return 3;
          } else if (whitespace1 || whitespace2) {
            return 2;
          } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
            return 1;
          }
          return 0;
        }
        var pointer = 1;
        while (pointer < diffs.length - 1) {
          if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
            var equality1 = diffs[pointer - 1][1];
            var edit = diffs[pointer][1];
            var equality2 = diffs[pointer + 1][1];
            var commonOffset = this.diff_commonSuffix(equality1, edit);
            if (commonOffset) {
              var commonString = edit.substring(edit.length - commonOffset);
              equality1 = equality1.substring(0, equality1.length - commonOffset);
              edit = commonString + edit.substring(0, edit.length - commonOffset);
              equality2 = commonString + equality2;
            }
            var bestEquality1 = equality1;
            var bestEdit = edit;
            var bestEquality2 = equality2;
            var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            while (edit.charAt(0) === equality2.charAt(0)) {
              equality1 += edit.charAt(0);
              edit = edit.substring(1) + equality2.charAt(0);
              equality2 = equality2.substring(1);
              var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
              if (score >= bestScore) {
                bestScore = score;
                bestEquality1 = equality1;
                bestEdit = edit;
                bestEquality2 = equality2;
              }
            }
            if (diffs[pointer - 1][1] != bestEquality1) {
              if (bestEquality1) {
                diffs[pointer - 1][1] = bestEquality1;
              } else {
                diffs.splice(pointer - 1, 1);
                pointer--;
              }
              diffs[pointer][1] = bestEdit;
              if (bestEquality2) {
                diffs[pointer + 1][1] = bestEquality2;
              } else {
                diffs.splice(pointer + 1, 1);
                pointer--;
              }
            }
          }
          pointer++;
        }
      };
      diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
      diff_match_patch.whitespaceRegex_ = /\s/;
      diff_match_patch.linebreakRegex_ = /[\r\n]/;
      diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
      diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
      diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
        var changes = false;
        var equalities = [];
        var equalitiesLength = 0;
        var lastEquality = null;
        var pointer = 0;
        var pre_ins = false;
        var pre_del = false;
        var post_ins = false;
        var post_del = false;
        while (pointer < diffs.length) {
          if (diffs[pointer][0] == DIFF_EQUAL) {
            if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
              equalities[equalitiesLength++] = pointer;
              pre_ins = post_ins;
              pre_del = post_del;
              lastEquality = diffs[pointer][1];
            } else {
              equalitiesLength = 0;
              lastEquality = null;
            }
            post_ins = post_del = false;
          } else {
            if (diffs[pointer][0] == DIFF_DELETE) {
              post_del = true;
            } else {
              post_ins = true;
            }
            if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
              diffs.splice(
                equalities[equalitiesLength - 1],
                0,
                new diff_match_patch.Diff(DIFF_DELETE, lastEquality)
              );
              diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
              equalitiesLength--;
              lastEquality = null;
              if (pre_ins && pre_del) {
                post_ins = post_del = true;
                equalitiesLength = 0;
              } else {
                equalitiesLength--;
                pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                post_ins = post_del = false;
              }
              changes = true;
            }
          }
          pointer++;
        }
        if (changes) {
          this.diff_cleanupMerge(diffs);
        }
      };
      diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
        diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
        var pointer = 0;
        var count_delete = 0;
        var count_insert = 0;
        var text_delete = "";
        var text_insert = "";
        var commonlength;
        while (pointer < diffs.length) {
          switch (diffs[pointer][0]) {
            case DIFF_INSERT:
              count_insert++;
              text_insert += diffs[pointer][1];
              pointer++;
              break;
            case DIFF_DELETE:
              count_delete++;
              text_delete += diffs[pointer][1];
              pointer++;
              break;
            case DIFF_EQUAL:
              if (count_delete + count_insert > 1) {
                if (count_delete !== 0 && count_insert !== 0) {
                  commonlength = this.diff_commonPrefix(text_insert, text_delete);
                  if (commonlength !== 0) {
                    if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                      diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                    } else {
                      diffs.splice(0, 0, new diff_match_patch.Diff(
                        DIFF_EQUAL,
                        text_insert.substring(0, commonlength)
                      ));
                      pointer++;
                    }
                    text_insert = text_insert.substring(commonlength);
                    text_delete = text_delete.substring(commonlength);
                  }
                  commonlength = this.diff_commonSuffix(text_insert, text_delete);
                  if (commonlength !== 0) {
                    diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                    text_insert = text_insert.substring(0, text_insert.length - commonlength);
                    text_delete = text_delete.substring(0, text_delete.length - commonlength);
                  }
                }
                pointer -= count_delete + count_insert;
                diffs.splice(pointer, count_delete + count_insert);
                if (text_delete.length) {
                  diffs.splice(
                    pointer,
                    0,
                    new diff_match_patch.Diff(DIFF_DELETE, text_delete)
                  );
                  pointer++;
                }
                if (text_insert.length) {
                  diffs.splice(
                    pointer,
                    0,
                    new diff_match_patch.Diff(DIFF_INSERT, text_insert)
                  );
                  pointer++;
                }
                pointer++;
              } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                diffs[pointer - 1][1] += diffs[pointer][1];
                diffs.splice(pointer, 1);
              } else {
                pointer++;
              }
              count_insert = 0;
              count_delete = 0;
              text_delete = "";
              text_insert = "";
              break;
          }
        }
        if (diffs[diffs.length - 1][1] === "") {
          diffs.pop();
        }
        var changes = false;
        pointer = 1;
        while (pointer < diffs.length - 1) {
          if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
            if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
              diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
              diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
              diffs.splice(pointer - 1, 1);
              changes = true;
            } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
              diffs[pointer - 1][1] += diffs[pointer + 1][1];
              diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
              diffs.splice(pointer + 1, 1);
              changes = true;
            }
          }
          pointer++;
        }
        if (changes) {
          this.diff_cleanupMerge(diffs);
        }
      };
      diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
        var chars1 = 0;
        var chars2 = 0;
        var last_chars1 = 0;
        var last_chars2 = 0;
        var x3;
        for (x3 = 0; x3 < diffs.length; x3++) {
          if (diffs[x3][0] !== DIFF_INSERT) {
            chars1 += diffs[x3][1].length;
          }
          if (diffs[x3][0] !== DIFF_DELETE) {
            chars2 += diffs[x3][1].length;
          }
          if (chars1 > loc) {
            break;
          }
          last_chars1 = chars1;
          last_chars2 = chars2;
        }
        if (diffs.length != x3 && diffs[x3][0] === DIFF_DELETE) {
          return last_chars2;
        }
        return last_chars2 + (loc - last_chars1);
      };
      diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
        var html = [];
        var pattern_amp = /&/g;
        var pattern_lt = /</g;
        var pattern_gt = />/g;
        var pattern_para = /\n/g;
        for (var x3 = 0; x3 < diffs.length; x3++) {
          var op = diffs[x3][0];
          var data = diffs[x3][1];
          var text = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
          switch (op) {
            case DIFF_INSERT:
              html[x3] = '<ins style="background:#e6ffe6;">' + text + "</ins>";
              break;
            case DIFF_DELETE:
              html[x3] = '<del style="background:#ffe6e6;">' + text + "</del>";
              break;
            case DIFF_EQUAL:
              html[x3] = "<span>" + text + "</span>";
              break;
          }
        }
        return html.join("");
      };
      diff_match_patch.prototype.diff_text1 = function(diffs) {
        var text = [];
        for (var x3 = 0; x3 < diffs.length; x3++) {
          if (diffs[x3][0] !== DIFF_INSERT) {
            text[x3] = diffs[x3][1];
          }
        }
        return text.join("");
      };
      diff_match_patch.prototype.diff_text2 = function(diffs) {
        var text = [];
        for (var x3 = 0; x3 < diffs.length; x3++) {
          if (diffs[x3][0] !== DIFF_DELETE) {
            text[x3] = diffs[x3][1];
          }
        }
        return text.join("");
      };
      diff_match_patch.prototype.diff_levenshtein = function(diffs) {
        var levenshtein = 0;
        var insertions = 0;
        var deletions = 0;
        for (var x3 = 0; x3 < diffs.length; x3++) {
          var op = diffs[x3][0];
          var data = diffs[x3][1];
          switch (op) {
            case DIFF_INSERT:
              insertions += data.length;
              break;
            case DIFF_DELETE:
              deletions += data.length;
              break;
            case DIFF_EQUAL:
              levenshtein += Math.max(insertions, deletions);
              insertions = 0;
              deletions = 0;
              break;
          }
        }
        levenshtein += Math.max(insertions, deletions);
        return levenshtein;
      };
      diff_match_patch.prototype.diff_toDelta = function(diffs) {
        var text = [];
        for (var x3 = 0; x3 < diffs.length; x3++) {
          switch (diffs[x3][0]) {
            case DIFF_INSERT:
              text[x3] = "+" + encodeURI(diffs[x3][1]);
              break;
            case DIFF_DELETE:
              text[x3] = "-" + diffs[x3][1].length;
              break;
            case DIFF_EQUAL:
              text[x3] = "=" + diffs[x3][1].length;
              break;
          }
        }
        return text.join("	").replace(/%20/g, " ");
      };
      diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
        var diffs = [];
        var diffsLength = 0;
        var pointer = 0;
        var tokens = delta.split(/\t/g);
        for (var x3 = 0; x3 < tokens.length; x3++) {
          var param = tokens[x3].substring(1);
          switch (tokens[x3].charAt(0)) {
            case "+":
              try {
                diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
              } catch (ex) {
                throw new Error("Illegal escape in diff_fromDelta: " + param);
              }
              break;
            case "-":
            case "=":
              var n3 = parseInt(param, 10);
              if (isNaN(n3) || n3 < 0) {
                throw new Error("Invalid number in diff_fromDelta: " + param);
              }
              var text = text1.substring(pointer, pointer += n3);
              if (tokens[x3].charAt(0) == "=") {
                diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
              } else {
                diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
              }
              break;
            default:
              if (tokens[x3]) {
                throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x3]);
              }
          }
        }
        if (pointer != text1.length) {
          throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
        }
        return diffs;
      };
      diff_match_patch.prototype.match_main = function(text, pattern, loc) {
        if (text == null || pattern == null || loc == null) {
          throw new Error("Null input. (match_main)");
        }
        loc = Math.max(0, Math.min(loc, text.length));
        if (text == pattern) {
          return 0;
        } else if (!text.length) {
          return -1;
        } else if (text.substring(loc, loc + pattern.length) == pattern) {
          return loc;
        } else {
          return this.match_bitap_(text, pattern, loc);
        }
      };
      diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
        if (pattern.length > this.Match_MaxBits) {
          throw new Error("Pattern too long for this browser.");
        }
        var s3 = this.match_alphabet_(pattern);
        var dmp = this;
        function match_bitapScore_(e2, x3) {
          var accuracy = e2 / pattern.length;
          var proximity = Math.abs(loc - x3);
          if (!dmp.Match_Distance) {
            return proximity ? 1 : accuracy;
          }
          return accuracy + proximity / dmp.Match_Distance;
        }
        var score_threshold = this.Match_Threshold;
        var best_loc = text.indexOf(pattern, loc);
        if (best_loc != -1) {
          score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
          best_loc = text.lastIndexOf(pattern, loc + pattern.length);
          if (best_loc != -1) {
            score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
          }
        }
        var matchmask = 1 << pattern.length - 1;
        best_loc = -1;
        var bin_min, bin_mid;
        var bin_max = pattern.length + text.length;
        var last_rd;
        for (var d3 = 0; d3 < pattern.length; d3++) {
          bin_min = 0;
          bin_mid = bin_max;
          while (bin_min < bin_mid) {
            if (match_bitapScore_(d3, loc + bin_mid) <= score_threshold) {
              bin_min = bin_mid;
            } else {
              bin_max = bin_mid;
            }
            bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
          }
          bin_max = bin_mid;
          var start = Math.max(1, loc - bin_mid + 1);
          var finish = Math.min(loc + bin_mid, text.length) + pattern.length;
          var rd = Array(finish + 2);
          rd[finish + 1] = (1 << d3) - 1;
          for (var j3 = finish; j3 >= start; j3--) {
            var charMatch = s3[text.charAt(j3 - 1)];
            if (d3 === 0) {
              rd[j3] = (rd[j3 + 1] << 1 | 1) & charMatch;
            } else {
              rd[j3] = (rd[j3 + 1] << 1 | 1) & charMatch | ((last_rd[j3 + 1] | last_rd[j3]) << 1 | 1) | last_rd[j3 + 1];
            }
            if (rd[j3] & matchmask) {
              var score = match_bitapScore_(d3, j3 - 1);
              if (score <= score_threshold) {
                score_threshold = score;
                best_loc = j3 - 1;
                if (best_loc > loc) {
                  start = Math.max(1, 2 * loc - best_loc);
                } else {
                  break;
                }
              }
            }
          }
          if (match_bitapScore_(d3 + 1, loc) > score_threshold) {
            break;
          }
          last_rd = rd;
        }
        return best_loc;
      };
      diff_match_patch.prototype.match_alphabet_ = function(pattern) {
        var s3 = {};
        for (var i3 = 0; i3 < pattern.length; i3++) {
          s3[pattern.charAt(i3)] = 0;
        }
        for (var i3 = 0; i3 < pattern.length; i3++) {
          s3[pattern.charAt(i3)] |= 1 << pattern.length - i3 - 1;
        }
        return s3;
      };
      diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
        if (text.length == 0) {
          return;
        }
        if (patch.start2 === null) {
          throw Error("patch not initialized");
        }
        var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
        var padding = 0;
        while (text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
          padding += this.Patch_Margin;
          pattern = text.substring(
            patch.start2 - padding,
            patch.start2 + patch.length1 + padding
          );
        }
        padding += this.Patch_Margin;
        var prefix = text.substring(patch.start2 - padding, patch.start2);
        if (prefix) {
          patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
        }
        var suffix = text.substring(
          patch.start2 + patch.length1,
          patch.start2 + patch.length1 + padding
        );
        if (suffix) {
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
        }
        patch.start1 -= prefix.length;
        patch.start2 -= prefix.length;
        patch.length1 += prefix.length + suffix.length;
        patch.length2 += prefix.length + suffix.length;
      };
      diff_match_patch.prototype.patch_make = function(a3, opt_b, opt_c) {
        var text1, diffs;
        if (typeof a3 == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
          text1 = /** @type {string} */
          a3;
          diffs = this.diff_main(
            text1,
            /** @type {string} */
            opt_b,
            true
          );
          if (diffs.length > 2) {
            this.diff_cleanupSemantic(diffs);
            this.diff_cleanupEfficiency(diffs);
          }
        } else if (a3 && typeof a3 == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
          diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
          a3;
          text1 = this.diff_text1(diffs);
        } else if (typeof a3 == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
          text1 = /** @type {string} */
          a3;
          diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
          opt_b;
        } else if (typeof a3 == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
          text1 = /** @type {string} */
          a3;
          diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
          opt_c;
        } else {
          throw new Error("Unknown call format to patch_make.");
        }
        if (diffs.length === 0) {
          return [];
        }
        var patches = [];
        var patch = new diff_match_patch.patch_obj();
        var patchDiffLength = 0;
        var char_count1 = 0;
        var char_count2 = 0;
        var prepatch_text = text1;
        var postpatch_text = text1;
        for (var x3 = 0; x3 < diffs.length; x3++) {
          var diff_type = diffs[x3][0];
          var diff_text = diffs[x3][1];
          if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
            patch.start1 = char_count1;
            patch.start2 = char_count2;
          }
          switch (diff_type) {
            case DIFF_INSERT:
              patch.diffs[patchDiffLength++] = diffs[x3];
              patch.length2 += diff_text.length;
              postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
              break;
            case DIFF_DELETE:
              patch.length1 += diff_text.length;
              patch.diffs[patchDiffLength++] = diffs[x3];
              postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
              break;
            case DIFF_EQUAL:
              if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x3 + 1) {
                patch.diffs[patchDiffLength++] = diffs[x3];
                patch.length1 += diff_text.length;
                patch.length2 += diff_text.length;
              } else if (diff_text.length >= 2 * this.Patch_Margin) {
                if (patchDiffLength) {
                  this.patch_addContext_(patch, prepatch_text);
                  patches.push(patch);
                  patch = new diff_match_patch.patch_obj();
                  patchDiffLength = 0;
                  prepatch_text = postpatch_text;
                  char_count1 = char_count2;
                }
              }
              break;
          }
          if (diff_type !== DIFF_INSERT) {
            char_count1 += diff_text.length;
          }
          if (diff_type !== DIFF_DELETE) {
            char_count2 += diff_text.length;
          }
        }
        if (patchDiffLength) {
          this.patch_addContext_(patch, prepatch_text);
          patches.push(patch);
        }
        return patches;
      };
      diff_match_patch.prototype.patch_deepCopy = function(patches) {
        var patchesCopy = [];
        for (var x3 = 0; x3 < patches.length; x3++) {
          var patch = patches[x3];
          var patchCopy = new diff_match_patch.patch_obj();
          patchCopy.diffs = [];
          for (var y3 = 0; y3 < patch.diffs.length; y3++) {
            patchCopy.diffs[y3] = new diff_match_patch.Diff(patch.diffs[y3][0], patch.diffs[y3][1]);
          }
          patchCopy.start1 = patch.start1;
          patchCopy.start2 = patch.start2;
          patchCopy.length1 = patch.length1;
          patchCopy.length2 = patch.length2;
          patchesCopy[x3] = patchCopy;
        }
        return patchesCopy;
      };
      diff_match_patch.prototype.patch_apply = function(patches, text) {
        if (patches.length == 0) {
          return [text, []];
        }
        patches = this.patch_deepCopy(patches);
        var nullPadding = this.patch_addPadding(patches);
        text = nullPadding + text + nullPadding;
        this.patch_splitMax(patches);
        var delta = 0;
        var results = [];
        for (var x3 = 0; x3 < patches.length; x3++) {
          var expected_loc = patches[x3].start2 + delta;
          var text1 = this.diff_text1(patches[x3].diffs);
          var start_loc;
          var end_loc = -1;
          if (text1.length > this.Match_MaxBits) {
            start_loc = this.match_main(
              text,
              text1.substring(0, this.Match_MaxBits),
              expected_loc
            );
            if (start_loc != -1) {
              end_loc = this.match_main(
                text,
                text1.substring(text1.length - this.Match_MaxBits),
                expected_loc + text1.length - this.Match_MaxBits
              );
              if (end_loc == -1 || start_loc >= end_loc) {
                start_loc = -1;
              }
            }
          } else {
            start_loc = this.match_main(text, text1, expected_loc);
          }
          if (start_loc == -1) {
            results[x3] = false;
            delta -= patches[x3].length2 - patches[x3].length1;
          } else {
            results[x3] = true;
            delta = start_loc - expected_loc;
            var text2;
            if (end_loc == -1) {
              text2 = text.substring(start_loc, start_loc + text1.length);
            } else {
              text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
            }
            if (text1 == text2) {
              text = text.substring(0, start_loc) + this.diff_text2(patches[x3].diffs) + text.substring(start_loc + text1.length);
            } else {
              var diffs = this.diff_main(text1, text2, false);
              if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
                results[x3] = false;
              } else {
                this.diff_cleanupSemanticLossless(diffs);
                var index1 = 0;
                var index2;
                for (var y3 = 0; y3 < patches[x3].diffs.length; y3++) {
                  var mod2 = patches[x3].diffs[y3];
                  if (mod2[0] !== DIFF_EQUAL) {
                    index2 = this.diff_xIndex(diffs, index1);
                  }
                  if (mod2[0] === DIFF_INSERT) {
                    text = text.substring(0, start_loc + index2) + mod2[1] + text.substring(start_loc + index2);
                  } else if (mod2[0] === DIFF_DELETE) {
                    text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(
                      diffs,
                      index1 + mod2[1].length
                    ));
                  }
                  if (mod2[0] !== DIFF_DELETE) {
                    index1 += mod2[1].length;
                  }
                }
              }
            }
          }
        }
        text = text.substring(nullPadding.length, text.length - nullPadding.length);
        return [text, results];
      };
      diff_match_patch.prototype.patch_addPadding = function(patches) {
        var paddingLength = this.Patch_Margin;
        var nullPadding = "";
        for (var x3 = 1; x3 <= paddingLength; x3++) {
          nullPadding += String.fromCharCode(x3);
        }
        for (var x3 = 0; x3 < patches.length; x3++) {
          patches[x3].start1 += paddingLength;
          patches[x3].start2 += paddingLength;
        }
        var patch = patches[0];
        var diffs = patch.diffs;
        if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
          diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
          patch.start1 -= paddingLength;
          patch.start2 -= paddingLength;
          patch.length1 += paddingLength;
          patch.length2 += paddingLength;
        } else if (paddingLength > diffs[0][1].length) {
          var extraLength = paddingLength - diffs[0][1].length;
          diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
          patch.start1 -= extraLength;
          patch.start2 -= extraLength;
          patch.length1 += extraLength;
          patch.length2 += extraLength;
        }
        patch = patches[patches.length - 1];
        diffs = patch.diffs;
        if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
          diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
          patch.length1 += paddingLength;
          patch.length2 += paddingLength;
        } else if (paddingLength > diffs[diffs.length - 1][1].length) {
          var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
          diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
          patch.length1 += extraLength;
          patch.length2 += extraLength;
        }
        return nullPadding;
      };
      diff_match_patch.prototype.patch_splitMax = function(patches) {
        var patch_size = this.Match_MaxBits;
        for (var x3 = 0; x3 < patches.length; x3++) {
          if (patches[x3].length1 <= patch_size) {
            continue;
          }
          var bigpatch = patches[x3];
          patches.splice(x3--, 1);
          var start1 = bigpatch.start1;
          var start2 = bigpatch.start2;
          var precontext = "";
          while (bigpatch.diffs.length !== 0) {
            var patch = new diff_match_patch.patch_obj();
            var empty = true;
            patch.start1 = start1 - precontext.length;
            patch.start2 = start2 - precontext.length;
            if (precontext !== "") {
              patch.length1 = patch.length2 = precontext.length;
              patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
            }
            while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
              var diff_type = bigpatch.diffs[0][0];
              var diff_text = bigpatch.diffs[0][1];
              if (diff_type === DIFF_INSERT) {
                patch.length2 += diff_text.length;
                start2 += diff_text.length;
                patch.diffs.push(bigpatch.diffs.shift());
                empty = false;
              } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
                patch.length1 += diff_text.length;
                start1 += diff_text.length;
                empty = false;
                patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
                bigpatch.diffs.shift();
              } else {
                diff_text = diff_text.substring(
                  0,
                  patch_size - patch.length1 - this.Patch_Margin
                );
                patch.length1 += diff_text.length;
                start1 += diff_text.length;
                if (diff_type === DIFF_EQUAL) {
                  patch.length2 += diff_text.length;
                  start2 += diff_text.length;
                } else {
                  empty = false;
                }
                patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
                if (diff_text == bigpatch.diffs[0][1]) {
                  bigpatch.diffs.shift();
                } else {
                  bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
                }
              }
            }
            precontext = this.diff_text2(patch.diffs);
            precontext = precontext.substring(precontext.length - this.Patch_Margin);
            var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
            if (postcontext !== "") {
              patch.length1 += postcontext.length;
              patch.length2 += postcontext.length;
              if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
                patch.diffs[patch.diffs.length - 1][1] += postcontext;
              } else {
                patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
              }
            }
            if (!empty) {
              patches.splice(++x3, 0, patch);
            }
          }
        }
      };
      diff_match_patch.prototype.patch_toText = function(patches) {
        var text = [];
        for (var x3 = 0; x3 < patches.length; x3++) {
          text[x3] = patches[x3];
        }
        return text.join("");
      };
      diff_match_patch.prototype.patch_fromText = function(textline) {
        var patches = [];
        if (!textline) {
          return patches;
        }
        var text = textline.split("\n");
        var textPointer = 0;
        var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
        while (textPointer < text.length) {
          var m3 = text[textPointer].match(patchHeader);
          if (!m3) {
            throw new Error("Invalid patch string: " + text[textPointer]);
          }
          var patch = new diff_match_patch.patch_obj();
          patches.push(patch);
          patch.start1 = parseInt(m3[1], 10);
          if (m3[2] === "") {
            patch.start1--;
            patch.length1 = 1;
          } else if (m3[2] == "0") {
            patch.length1 = 0;
          } else {
            patch.start1--;
            patch.length1 = parseInt(m3[2], 10);
          }
          patch.start2 = parseInt(m3[3], 10);
          if (m3[4] === "") {
            patch.start2--;
            patch.length2 = 1;
          } else if (m3[4] == "0") {
            patch.length2 = 0;
          } else {
            patch.start2--;
            patch.length2 = parseInt(m3[4], 10);
          }
          textPointer++;
          while (textPointer < text.length) {
            var sign = text[textPointer].charAt(0);
            try {
              var line = decodeURI(text[textPointer].substring(1));
            } catch (ex) {
              throw new Error("Illegal escape in patch_fromText: " + line);
            }
            if (sign == "-") {
              patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
            } else if (sign == "+") {
              patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
            } else if (sign == " ") {
              patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
            } else if (sign == "@") {
              break;
            } else if (sign === "") {
            } else {
              throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
            }
            textPointer++;
          }
        }
        return patches;
      };
      diff_match_patch.patch_obj = function() {
        this.diffs = [];
        this.start1 = null;
        this.start2 = null;
        this.length1 = 0;
        this.length2 = 0;
      };
      diff_match_patch.patch_obj.prototype.toString = function() {
        var coords1, coords2;
        if (this.length1 === 0) {
          coords1 = this.start1 + ",0";
        } else if (this.length1 == 1) {
          coords1 = this.start1 + 1;
        } else {
          coords1 = this.start1 + 1 + "," + this.length1;
        }
        if (this.length2 === 0) {
          coords2 = this.start2 + ",0";
        } else if (this.length2 == 1) {
          coords2 = this.start2 + 1;
        } else {
          coords2 = this.start2 + 1 + "," + this.length2;
        }
        var text = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
        var op;
        for (var x3 = 0; x3 < this.diffs.length; x3++) {
          switch (this.diffs[x3][0]) {
            case DIFF_INSERT:
              op = "+";
              break;
            case DIFF_DELETE:
              op = "-";
              break;
            case DIFF_EQUAL:
              op = " ";
              break;
          }
          text[x3 + 1] = op + encodeURI(this.diffs[x3][1]) + "\n";
        }
        return text.join("").replace(/%20/g, " ");
      };
      module.exports = diff_match_patch;
      module.exports["diff_match_patch"] = diff_match_patch;
      module.exports["DIFF_DELETE"] = DIFF_DELETE;
      module.exports["DIFF_INSERT"] = DIFF_INSERT;
      module.exports["DIFF_EQUAL"] = DIFF_EQUAL;
    }
  });

  // ../node_modules/dom-node-iterator/lib/adapter.js
  var require_adapter = __commonJS({
    "../node_modules/dom-node-iterator/lib/adapter.js"(exports) {
      "use strict";
      exports.__esModule = true;
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      exports["default"] = createNodeIterator;
      function createNodeIterator(root) {
        var whatToShow = arguments.length <= 1 || arguments[1] === void 0 ? 4294967295 : arguments[1];
        var filter3 = arguments.length <= 2 || arguments[2] === void 0 ? null : arguments[2];
        var doc = root.nodeType == 9 || root.ownerDocument;
        var iter = doc.createNodeIterator(root, whatToShow, filter3, false);
        return new NodeIterator(iter, root, whatToShow, filter3);
      }
      var NodeIterator = function() {
        function NodeIterator2(iter, root, whatToShow, filter3) {
          _classCallCheck(this, NodeIterator2);
          this.root = root;
          this.whatToShow = whatToShow;
          this.filter = filter3;
          this.referenceNode = root;
          this.pointerBeforeReferenceNode = true;
          this._iter = iter;
        }
        NodeIterator2.prototype.nextNode = function nextNode() {
          var result = this._iter.nextNode();
          this.pointerBeforeReferenceNode = false;
          if (result === null)
            return null;
          this.referenceNode = result;
          return this.referenceNode;
        };
        NodeIterator2.prototype.previousNode = function previousNode() {
          var result = this._iter.previousNode();
          this.pointerBeforeReferenceNode = true;
          if (result === null)
            return null;
          this.referenceNode = result;
          return this.referenceNode;
        };
        NodeIterator2.prototype.toString = function toString3() {
          return "[object NodeIterator]";
        };
        return NodeIterator2;
      }();
    }
  });

  // ../node_modules/dom-node-iterator/lib/builtin.js
  var require_builtin = __commonJS({
    "../node_modules/dom-node-iterator/lib/builtin.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = createNodeIterator;
      function createNodeIterator(root) {
        var whatToShow = arguments.length <= 1 || arguments[1] === void 0 ? 4294967295 : arguments[1];
        var filter3 = arguments.length <= 2 || arguments[2] === void 0 ? null : arguments[2];
        var doc = root.ownerDocument;
        return doc.createNodeIterator.call(doc, root, whatToShow, filter3);
      }
    }
  });

  // ../node_modules/dom-node-iterator/lib/implementation.js
  var require_implementation = __commonJS({
    "../node_modules/dom-node-iterator/lib/implementation.js"(exports) {
      "use strict";
      exports.__esModule = true;
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      exports["default"] = createNodeIterator;
      function createNodeIterator(root) {
        var whatToShow = arguments.length <= 1 || arguments[1] === void 0 ? 4294967295 : arguments[1];
        var filter3 = arguments.length <= 2 || arguments[2] === void 0 ? null : arguments[2];
        return new NodeIterator(root, whatToShow, filter3);
      }
      var NodeIterator = function() {
        function NodeIterator2(root, whatToShow, filter3) {
          _classCallCheck(this, NodeIterator2);
          this.root = root;
          this.whatToShow = whatToShow;
          this.filter = filter3;
          this.referenceNode = root;
          this.pointerBeforeReferenceNode = true;
          this._filter = function(node) {
            return filter3 ? filter3(node) === 1 : true;
          };
          this._show = function(node) {
            return whatToShow >> node.nodeType - 1 & true;
          };
        }
        NodeIterator2.prototype.nextNode = function nextNode() {
          var before = this.pointerBeforeReferenceNode;
          this.pointerBeforeReferenceNode = false;
          var node = this.referenceNode;
          if (before && this._show(node) && this._filter(node))
            return node;
          do {
            if (node.firstChild) {
              node = node.firstChild;
              continue;
            }
            do {
              if (node === this.root)
                return null;
              if (node.nextSibling)
                break;
              node = node.parentNode;
            } while (node);
            node = node.nextSibling;
          } while (!this._show(node) || !this._filter(node));
          this.referenceNode = node;
          this.pointerBeforeReferenceNode = false;
          return node;
        };
        NodeIterator2.prototype.previousNode = function previousNode() {
          var before = this.pointerBeforeReferenceNode;
          this.pointerBeforeReferenceNode = true;
          var node = this.referenceNode;
          if (!before && this._show(node) && this._filter(node))
            return node;
          do {
            if (node === this.root)
              return null;
            if (node.previousSibling) {
              node = node.previousSibling;
              while (node.lastChild) {
                node = node.lastChild;
              }
              continue;
            }
            node = node.parentNode;
          } while (!this._show(node) || !this._filter(node));
          this.referenceNode = node;
          this.pointerBeforeReferenceNode = true;
          return node;
        };
        NodeIterator2.prototype.toString = function toString3() {
          return "[object NodeIterator]";
        };
        return NodeIterator2;
      }();
    }
  });

  // ../node_modules/dom-node-iterator/lib/polyfill.js
  var require_polyfill = __commonJS({
    "../node_modules/dom-node-iterator/lib/polyfill.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = getPolyfill;
      var _adapter = require_adapter();
      var _adapter2 = _interopRequireDefault(_adapter);
      var _builtin = require_builtin();
      var _builtin2 = _interopRequireDefault(_builtin);
      var _implementation = require_implementation();
      var _implementation2 = _interopRequireDefault(_implementation);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function getPolyfill() {
        try {
          var doc = typeof document === "undefined" ? {} : document;
          var iter = (0, _builtin2["default"])(doc, 4294967295, null, false);
          if (iter.referenceNode === doc)
            return _builtin2["default"];
          return _adapter2["default"];
        } catch (_3) {
          return _implementation2["default"];
        }
      }
    }
  });

  // ../node_modules/dom-node-iterator/lib/shim.js
  var require_shim = __commonJS({
    "../node_modules/dom-node-iterator/lib/shim.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = shim;
      var _builtin = require_builtin();
      var _builtin2 = _interopRequireDefault(_builtin);
      var _polyfill = require_polyfill();
      var _polyfill2 = _interopRequireDefault(_polyfill);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function shim() {
        var doc = typeof document === "undefined" ? {} : document;
        var polyfill = (0, _polyfill2["default"])();
        if (polyfill !== _builtin2["default"])
          doc.createNodeIterator = polyfill;
        return polyfill;
      }
    }
  });

  // ../node_modules/dom-node-iterator/lib/index.js
  var require_lib = __commonJS({
    "../node_modules/dom-node-iterator/lib/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      var _polyfill = require_polyfill();
      var _polyfill2 = _interopRequireDefault(_polyfill);
      var _implementation = require_implementation();
      var _implementation2 = _interopRequireDefault(_implementation);
      var _shim = require_shim();
      var _shim2 = _interopRequireDefault(_shim);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var polyfill = (0, _polyfill2["default"])();
      polyfill.implementation = _implementation2["default"];
      polyfill.shim = _shim2["default"];
      exports["default"] = polyfill;
    }
  });

  // ../node_modules/dom-node-iterator/polyfill.js
  var require_polyfill2 = __commonJS({
    "../node_modules/dom-node-iterator/polyfill.js"(exports, module) {
      module.exports = require_polyfill()["default"];
    }
  });

  // ../node_modules/dom-node-iterator/implementation.js
  var require_implementation2 = __commonJS({
    "../node_modules/dom-node-iterator/implementation.js"(exports, module) {
      module.exports = require_implementation()["default"];
    }
  });

  // ../node_modules/dom-node-iterator/shim.js
  var require_shim2 = __commonJS({
    "../node_modules/dom-node-iterator/shim.js"(exports, module) {
      module.exports = require_shim()["default"];
    }
  });

  // ../node_modules/dom-node-iterator/index.js
  var require_dom_node_iterator = __commonJS({
    "../node_modules/dom-node-iterator/index.js"(exports, module) {
      module.exports = require_lib()["default"];
      module.exports.getPolyfill = require_polyfill2();
      module.exports.implementation = require_implementation2();
      module.exports.shim = require_shim2();
    }
  });

  // ../node_modules/ancestors/index.js
  var require_ancestors = __commonJS({
    "../node_modules/ancestors/index.js"(exports, module) {
      module.exports = parents;
      function parents(node, filter3) {
        var out = [];
        filter3 = filter3 || noop;
        do {
          out.push(node);
          node = node.parentNode;
        } while (node && node.tagName && filter3(node));
        return out.slice(1);
      }
      function noop(n3) {
        return true;
      }
    }
  });

  // ../node_modules/index-of/index.js
  var require_index_of = __commonJS({
    "../node_modules/index-of/index.js"(exports, module) {
      "use strict";
      module.exports = function indexOf2(arr, ele, start) {
        start = start || 0;
        var idx = -1;
        if (arr == null)
          return idx;
        var len = arr.length;
        var i3 = start < 0 ? len + start : start;
        if (i3 >= arr.length) {
          return -1;
        }
        while (i3 < len) {
          if (arr[i3] === ele) {
            return i3;
          }
          i3++;
        }
        return -1;
      };
    }
  });

  // ../node_modules/dom-anchor-text-quote/node_modules/dom-seek/lib/index.js
  var require_lib2 = __commonJS({
    "../node_modules/dom-anchor-text-quote/node_modules/dom-seek/lib/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = seek;
      var _ancestors = require_ancestors();
      var _ancestors2 = _interopRequireDefault(_ancestors);
      var _indexOf = require_index_of();
      var _indexOf2 = _interopRequireDefault(_indexOf);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var E_SHOW = "Argument 1 of seek must use filter NodeFilter.SHOW_TEXT.";
      var E_WHERE = "Argument 2 of seek must be a number or a Text Node.";
      var SHOW_TEXT = 4;
      var TEXT_NODE = 3;
      function seek(iter, where) {
        if (iter.whatToShow !== SHOW_TEXT) {
          throw new Error(E_SHOW);
        }
        var count = 0;
        var node = iter.referenceNode;
        var predicates = null;
        if (isNumber2(where)) {
          predicates = {
            forward: function forward2() {
              return count < where;
            },
            backward: function backward2() {
              return count > where;
            }
          };
        } else if (isText(where)) {
          var forward = before(node, where) ? function() {
            return false;
          } : function() {
            return node !== where;
          };
          var backward = function backward2() {
            return node != where || !iter.pointerBeforeReferenceNode;
          };
          predicates = { forward, backward };
        } else {
          throw new Error(E_WHERE);
        }
        while (predicates.forward() && (node = iter.nextNode()) !== null) {
          count += node.nodeValue.length;
        }
        while (predicates.backward() && (node = iter.previousNode()) !== null) {
          count -= node.nodeValue.length;
        }
        return count;
      }
      function isNumber2(n3) {
        return !isNaN(parseInt(n3)) && isFinite(n3);
      }
      function isText(node) {
        return node.nodeType === TEXT_NODE;
      }
      function before(ref, node) {
        if (ref === node)
          return false;
        var common = null;
        var left = [ref].concat((0, _ancestors2["default"])(ref)).reverse();
        var right = [node].concat((0, _ancestors2["default"])(node)).reverse();
        while (left[0] === right[0]) {
          common = left.shift();
          right.shift();
        }
        left = left[0];
        right = right[0];
        var l3 = (0, _indexOf2["default"])(common.childNodes, left);
        var r3 = (0, _indexOf2["default"])(common.childNodes, right);
        return l3 > r3;
      }
    }
  });

  // ../node_modules/dom-anchor-text-quote/node_modules/dom-seek/index.js
  var require_dom_seek = __commonJS({
    "../node_modules/dom-anchor-text-quote/node_modules/dom-seek/index.js"(exports, module) {
      module.exports = require_lib2()["default"];
    }
  });

  // ../node_modules/dom-anchor-text-quote/node_modules/dom-anchor-text-position/lib/range-to-string.js
  var require_range_to_string = __commonJS({
    "../node_modules/dom-anchor-text-quote/node_modules/dom-anchor-text-position/lib/range-to-string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = rangeToString;
      function nextNode(node, skipChildren) {
        if (!skipChildren && node.firstChild) {
          return node.firstChild;
        }
        do {
          if (node.nextSibling) {
            return node.nextSibling;
          }
          node = node.parentNode;
        } while (node);
        return node;
      }
      function firstNode(range) {
        if (range.startContainer.nodeType === Node.ELEMENT_NODE) {
          var node = range.startContainer.childNodes[range.startOffset];
          return node || nextNode(
            range.startContainer,
            true
            /* skip children */
          );
        }
        return range.startContainer;
      }
      function firstNodeAfter(range) {
        if (range.endContainer.nodeType === Node.ELEMENT_NODE) {
          var node = range.endContainer.childNodes[range.endOffset];
          return node || nextNode(
            range.endContainer,
            true
            /* skip children */
          );
        }
        return nextNode(range.endContainer);
      }
      function forEachNodeInRange(range, cb) {
        var node = firstNode(range);
        var pastEnd = firstNodeAfter(range);
        while (node !== pastEnd) {
          cb(node);
          node = nextNode(node);
        }
      }
      function rangeToString(range) {
        var text = "";
        forEachNodeInRange(range, function(node) {
          if (node.nodeType !== Node.TEXT_NODE) {
            return;
          }
          var start = node === range.startContainer ? range.startOffset : 0;
          var end = node === range.endContainer ? range.endOffset : node.textContent.length;
          text += node.textContent.slice(start, end);
        });
        return text;
      }
    }
  });

  // ../node_modules/dom-anchor-text-quote/node_modules/dom-anchor-text-position/lib/index.js
  var require_lib3 = __commonJS({
    "../node_modules/dom-anchor-text-quote/node_modules/dom-anchor-text-position/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fromRange = fromRange2;
      exports.toRange = toRange3;
      var _domNodeIterator = require_dom_node_iterator();
      var _domNodeIterator2 = _interopRequireDefault(_domNodeIterator);
      var _domSeek = require_dom_seek();
      var _domSeek2 = _interopRequireDefault(_domSeek);
      var _rangeToString = require_range_to_string();
      var _rangeToString2 = _interopRequireDefault(_rangeToString);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var SHOW_TEXT = 4;
      function fromRange2(root, range) {
        if (root === void 0) {
          throw new Error('missing required parameter "root"');
        }
        if (range === void 0) {
          throw new Error('missing required parameter "range"');
        }
        var document2 = root.ownerDocument;
        var prefix = document2.createRange();
        var startNode = range.startContainer;
        var startOffset = range.startOffset;
        prefix.setStart(root, 0);
        prefix.setEnd(startNode, startOffset);
        var start = (0, _rangeToString2.default)(prefix).length;
        var end = start + (0, _rangeToString2.default)(range).length;
        return {
          start,
          end
        };
      }
      function toRange3(root) {
        var selector = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        if (root === void 0) {
          throw new Error('missing required parameter "root"');
        }
        var document2 = root.ownerDocument;
        var range = document2.createRange();
        var iter = (0, _domNodeIterator2.default)(root, SHOW_TEXT);
        var start = selector.start || 0;
        var end = selector.end || start;
        var count = (0, _domSeek2.default)(iter, start);
        var remainder = start - count;
        if (iter.pointerBeforeReferenceNode) {
          range.setStart(iter.referenceNode, remainder);
        } else {
          range.setStart(iter.nextNode(), remainder);
          iter.previousNode();
        }
        var length = end - start + remainder;
        count = (0, _domSeek2.default)(iter, length);
        remainder = length - count;
        if (iter.pointerBeforeReferenceNode) {
          range.setEnd(iter.referenceNode, remainder);
        } else {
          range.setEnd(iter.nextNode(), remainder);
        }
        return range;
      }
    }
  });

  // ../node_modules/dom-anchor-text-quote/node_modules/dom-anchor-text-position/index.js
  var require_dom_anchor_text_position = __commonJS({
    "../node_modules/dom-anchor-text-quote/node_modules/dom-anchor-text-position/index.js"(exports, module) {
      module.exports = require_lib3();
    }
  });

  // ../node_modules/dom-anchor-text-quote/lib/index.js
  var require_lib4 = __commonJS({
    "../node_modules/dom-anchor-text-quote/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fromRange = fromRange2;
      exports.fromTextPosition = fromTextPosition3;
      exports.toRange = toRange3;
      exports.toTextPosition = toTextPosition3;
      var _diffMatchPatch = require_diff_match_patch();
      var _diffMatchPatch2 = _interopRequireDefault(_diffMatchPatch);
      var _domAnchorTextPosition = require_dom_anchor_text_position();
      var textPosition3 = _interopRequireWildcard(_domAnchorTextPosition);
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var SLICE_LENGTH = 32;
      var SLICE_RE = new RegExp("(.|[\r\n]){1," + String(SLICE_LENGTH) + "}", "g");
      var CONTEXT_LENGTH = SLICE_LENGTH;
      function fromRange2(root, range) {
        if (root === void 0) {
          throw new Error('missing required parameter "root"');
        }
        if (range === void 0) {
          throw new Error('missing required parameter "range"');
        }
        var position = textPosition3.fromRange(root, range);
        return fromTextPosition3(root, position);
      }
      function fromTextPosition3(root, selector) {
        if (root === void 0) {
          throw new Error('missing required parameter "root"');
        }
        if (selector === void 0) {
          throw new Error('missing required parameter "selector"');
        }
        var start = selector.start;
        if (start === void 0) {
          throw new Error('selector missing required property "start"');
        }
        if (start < 0) {
          throw new Error('property "start" must be a non-negative integer');
        }
        var end = selector.end;
        if (end === void 0) {
          throw new Error('selector missing required property "end"');
        }
        if (end < 0) {
          throw new Error('property "end" must be a non-negative integer');
        }
        var exact = root.textContent.substr(start, end - start);
        var prefixStart = Math.max(0, start - CONTEXT_LENGTH);
        var prefix = root.textContent.substr(prefixStart, start - prefixStart);
        var suffixEnd = Math.min(root.textContent.length, end + CONTEXT_LENGTH);
        var suffix = root.textContent.substr(end, suffixEnd - end);
        return { exact, prefix, suffix };
      }
      function toRange3(root, selector) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var position = toTextPosition3(root, selector, options);
        if (position === null) {
          return null;
        } else {
          return textPosition3.toRange(root, position);
        }
      }
      function toTextPosition3(root, selector) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (root === void 0) {
          throw new Error('missing required parameter "root"');
        }
        if (selector === void 0) {
          throw new Error('missing required parameter "selector"');
        }
        var exact = selector.exact;
        if (exact === void 0) {
          throw new Error('selector missing required property "exact"');
        }
        var prefix = selector.prefix, suffix = selector.suffix;
        var hint = options.hint;
        var dmp = new _diffMatchPatch2.default();
        dmp.Match_Distance = root.textContent.length * 2;
        var slices = exact.match(SLICE_RE);
        var loc = hint === void 0 ? root.textContent.length / 2 | 0 : hint;
        var start = Number.POSITIVE_INFINITY;
        var end = Number.NEGATIVE_INFINITY;
        var result = -1;
        var havePrefix = prefix !== void 0;
        var haveSuffix = suffix !== void 0;
        var foundPrefix = false;
        if (havePrefix) {
          result = dmp.match_main(root.textContent, prefix, loc);
          if (result > -1) {
            loc = result + prefix.length;
            foundPrefix = true;
          }
        }
        if (haveSuffix && !foundPrefix) {
          result = dmp.match_main(root.textContent, suffix, loc + exact.length);
          if (result > -1) {
            loc = result - exact.length;
          }
        }
        var firstSlice = slices.shift();
        result = dmp.match_main(root.textContent, firstSlice, loc);
        if (result > -1) {
          start = result;
          loc = end = start + firstSlice.length;
        } else {
          return null;
        }
        var foldSlices = function foldSlices2(acc2, slice) {
          if (!acc2) {
            return null;
          }
          var result2 = dmp.match_main(root.textContent, slice, acc2.loc);
          if (result2 === -1) {
            return null;
          }
          acc2.loc = result2 + slice.length;
          acc2.start = Math.min(acc2.start, result2);
          acc2.end = Math.max(acc2.end, result2 + slice.length);
          return acc2;
        };
        dmp.Match_Distance = 64;
        var acc = slices.reduce(foldSlices, { start, end, loc });
        if (!acc) {
          return null;
        }
        return { start: acc.start, end: acc.end };
      }
    }
  });

  // ../node_modules/dom-anchor-text-quote/index.js
  var require_dom_anchor_text_quote = __commonJS({
    "../node_modules/dom-anchor-text-quote/index.js"(exports, module) {
      module.exports = require_lib4();
    }
  });

  // ../howdju-common/lib/logger.ts
  var logger;
  var init_logger = __esm({
    "../howdju-common/lib/logger.ts"() {
      "use strict";
      logger = console;
    }
  });

  // ../node_modules/dom-seek/lib/index.js
  var require_lib5 = __commonJS({
    "../node_modules/dom-seek/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = seek;
      var E_END = "Iterator exhausted before seek ended.";
      var E_SHOW = "Argument 1 of seek must use filter NodeFilter.SHOW_TEXT.";
      var E_WHERE = "Argument 2 of seek must be an integer or a Text Node.";
      var DOCUMENT_POSITION_PRECEDING = 2;
      var SHOW_TEXT = 4;
      var TEXT_NODE = 3;
      function seek(iter, where) {
        if (iter.whatToShow !== SHOW_TEXT) {
          var error;
          try {
            error = new DOMException(E_SHOW, "InvalidStateError");
          } catch (_unused) {
            error = new Error(E_SHOW);
            error.code = 11;
            error.name = "InvalidStateError";
            error.toString = function() {
              return "InvalidStateError: ".concat(E_SHOW);
            };
          }
          throw error;
        }
        var count = 0;
        var node = iter.referenceNode;
        var predicates = null;
        if (isInteger(where)) {
          predicates = {
            forward: function forward2() {
              return count < where;
            },
            backward: function backward2() {
              return count > where || !iter.pointerBeforeReferenceNode;
            }
          };
        } else if (isText(where)) {
          var forward = before(node, where) ? function() {
            return false;
          } : function() {
            return node !== where;
          };
          var backward = function backward2() {
            return node !== where || !iter.pointerBeforeReferenceNode;
          };
          predicates = {
            forward,
            backward
          };
        } else {
          throw new TypeError(E_WHERE);
        }
        while (predicates.forward()) {
          node = iter.nextNode();
          if (node === null) {
            throw new RangeError(E_END);
          }
          count += node.nodeValue.length;
        }
        if (iter.nextNode()) {
          node = iter.previousNode();
        }
        while (predicates.backward()) {
          node = iter.previousNode();
          if (node === null) {
            throw new RangeError(E_END);
          }
          count -= node.nodeValue.length;
        }
        if (!isText(iter.referenceNode)) {
          throw new RangeError(E_END);
        }
        return count;
      }
      function isInteger(n3) {
        if (typeof n3 !== "number")
          return false;
        return isFinite(n3) && Math.floor(n3) === n3;
      }
      function isText(node) {
        return node.nodeType === TEXT_NODE;
      }
      function before(ref, node) {
        return ref.compareDocumentPosition(node) & DOCUMENT_POSITION_PRECEDING;
      }
    }
  });

  // ../node_modules/dom-seek/index.js
  var require_dom_seek2 = __commonJS({
    "../node_modules/dom-seek/index.js"(exports, module) {
      module.exports = require_lib5()["default"];
    }
  });

  // ../node_modules/dom-anchor-text-position/lib/range-to-string.js
  var require_range_to_string2 = __commonJS({
    "../node_modules/dom-anchor-text-position/lib/range-to-string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = rangeToString;
      function nextNode(node, skipChildren) {
        if (!skipChildren && node.firstChild) {
          return node.firstChild;
        }
        do {
          if (node.nextSibling) {
            return node.nextSibling;
          }
          node = node.parentNode;
        } while (node);
        return node;
      }
      function firstNode(range) {
        if (range.startContainer.nodeType === Node.ELEMENT_NODE) {
          var node = range.startContainer.childNodes[range.startOffset];
          return node || nextNode(
            range.startContainer,
            true
            /* skip children */
          );
        }
        return range.startContainer;
      }
      function firstNodeAfter(range) {
        if (range.endContainer.nodeType === Node.ELEMENT_NODE) {
          var node = range.endContainer.childNodes[range.endOffset];
          return node || nextNode(
            range.endContainer,
            true
            /* skip children */
          );
        }
        return nextNode(range.endContainer);
      }
      function forEachNodeInRange(range, cb) {
        var node = firstNode(range);
        var pastEnd = firstNodeAfter(range);
        while (node !== pastEnd) {
          cb(node);
          node = nextNode(node);
        }
      }
      function rangeToString(range) {
        var text = "";
        forEachNodeInRange(range, function(node) {
          if (node.nodeType !== Node.TEXT_NODE) {
            return;
          }
          var start = node === range.startContainer ? range.startOffset : 0;
          var end = node === range.endContainer ? range.endOffset : node.textContent.length;
          text += node.textContent.slice(start, end);
        });
        return text;
      }
    }
  });

  // ../node_modules/dom-anchor-text-position/lib/index.js
  var require_lib6 = __commonJS({
    "../node_modules/dom-anchor-text-position/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fromRange = fromRange2;
      exports.toRange = toRange3;
      var _domSeek = _interopRequireDefault(require_dom_seek2());
      var _rangeToString = _interopRequireDefault(require_range_to_string2());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var SHOW_TEXT = 4;
      function fromRange2(root, range) {
        if (root === void 0) {
          throw new Error('missing required parameter "root"');
        }
        if (range === void 0) {
          throw new Error('missing required parameter "range"');
        }
        var document2 = root.ownerDocument;
        var prefix = document2.createRange();
        var startNode = range.startContainer;
        var startOffset = range.startOffset;
        prefix.setStart(root, 0);
        prefix.setEnd(startNode, startOffset);
        var start = (0, _rangeToString["default"])(prefix).length;
        var end = start + (0, _rangeToString["default"])(range).length;
        return {
          start,
          end
        };
      }
      function toRange3(root) {
        var selector = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (root === void 0) {
          throw new Error('missing required parameter "root"');
        }
        var document2 = root.ownerDocument;
        var range = document2.createRange();
        var iter = document2.createNodeIterator(root, SHOW_TEXT);
        var start = selector.start || 0;
        var end = selector.end || start;
        var startOffset = start - (0, _domSeek["default"])(iter, start);
        var startNode = iter.referenceNode;
        var remainder = end - start + startOffset;
        var endOffset = remainder - (0, _domSeek["default"])(iter, remainder);
        var endNode = iter.referenceNode;
        range.setStart(startNode, startOffset);
        range.setEnd(endNode, endOffset);
        return range;
      }
    }
  });

  // ../node_modules/dom-anchor-text-position/index.js
  var require_dom_anchor_text_position2 = __commonJS({
    "../node_modules/dom-anchor-text-position/index.js"(exports, module) {
      module.exports = require_lib6();
    }
  });

  // ../node_modules/lodash/_apply.js
  var require_apply = __commonJS({
    "../node_modules/lodash/_apply.js"(exports, module) {
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      module.exports = apply;
    }
  });

  // ../node_modules/lodash/_overRest.js
  var require_overRest = __commonJS({
    "../node_modules/lodash/_overRest.js"(exports, module) {
      var apply = require_apply();
      var nativeMax = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      module.exports = overRest;
    }
  });

  // ../node_modules/lodash/constant.js
  var require_constant = __commonJS({
    "../node_modules/lodash/constant.js"(exports, module) {
      function constant(value) {
        return function() {
          return value;
        };
      }
      module.exports = constant;
    }
  });

  // ../node_modules/lodash/_baseSetToString.js
  var require_baseSetToString = __commonJS({
    "../node_modules/lodash/_baseSetToString.js"(exports, module) {
      var constant = require_constant();
      var defineProperty = require_defineProperty();
      var identity = require_identity();
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      module.exports = baseSetToString;
    }
  });

  // ../node_modules/lodash/_shortOut.js
  var require_shortOut = __commonJS({
    "../node_modules/lodash/_shortOut.js"(exports, module) {
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      module.exports = shortOut;
    }
  });

  // ../node_modules/lodash/_setToString.js
  var require_setToString = __commonJS({
    "../node_modules/lodash/_setToString.js"(exports, module) {
      var baseSetToString = require_baseSetToString();
      var shortOut = require_shortOut();
      var setToString = shortOut(baseSetToString);
      module.exports = setToString;
    }
  });

  // ../node_modules/lodash/_baseRest.js
  var require_baseRest = __commonJS({
    "../node_modules/lodash/_baseRest.js"(exports, module) {
      var identity = require_identity();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      module.exports = baseRest;
    }
  });

  // ../node_modules/lodash/_isIterateeCall.js
  var require_isIterateeCall = __commonJS({
    "../node_modules/lodash/_isIterateeCall.js"(exports, module) {
      var eq = require_eq();
      var isArrayLike = require_isArrayLike();
      var isIndex = require_isIndex();
      var isObject3 = require_isObject();
      function isIterateeCall(value, index, object) {
        if (!isObject3(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      module.exports = isIterateeCall;
    }
  });

  // ../node_modules/lodash/_createAssigner.js
  var require_createAssigner = __commonJS({
    "../node_modules/lodash/_createAssigner.js"(exports, module) {
      var baseRest = require_baseRest();
      var isIterateeCall = require_isIterateeCall();
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      module.exports = createAssigner;
    }
  });

  // ../node_modules/lodash/assign.js
  var require_assign = __commonJS({
    "../node_modules/lodash/assign.js"(exports, module) {
      var assignValue = require_assignValue();
      var copyObject = require_copyObject();
      var createAssigner = require_createAssigner();
      var isArrayLike = require_isArrayLike();
      var isPrototype = require_isPrototype();
      var keys4 = require_keys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var assign4 = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys4(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      module.exports = assign4;
    }
  });

  // ../node_modules/lodash/_assignMergeValue.js
  var require_assignMergeValue = __commonJS({
    "../node_modules/lodash/_assignMergeValue.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module.exports = assignMergeValue;
    }
  });

  // ../node_modules/lodash/isArrayLikeObject.js
  var require_isArrayLikeObject = __commonJS({
    "../node_modules/lodash/isArrayLikeObject.js"(exports, module) {
      var isArrayLike = require_isArrayLike();
      var isObjectLike = require_isObjectLike();
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      module.exports = isArrayLikeObject;
    }
  });

  // ../node_modules/lodash/isPlainObject.js
  var require_isPlainObject = __commonJS({
    "../node_modules/lodash/isPlainObject.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var getPrototype = require_getPrototype();
      var isObjectLike = require_isObjectLike();
      var objectTag = "[object Object]";
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      module.exports = isPlainObject2;
    }
  });

  // ../node_modules/lodash/_safeGet.js
  var require_safeGet = __commonJS({
    "../node_modules/lodash/_safeGet.js"(exports, module) {
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      module.exports = safeGet;
    }
  });

  // ../node_modules/lodash/toPlainObject.js
  var require_toPlainObject = __commonJS({
    "../node_modules/lodash/toPlainObject.js"(exports, module) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      module.exports = toPlainObject;
    }
  });

  // ../node_modules/lodash/_baseMergeDeep.js
  var require_baseMergeDeep = __commonJS({
    "../node_modules/lodash/_baseMergeDeep.js"(exports, module) {
      var assignMergeValue = require_assignMergeValue();
      var cloneBuffer = require_cloneBuffer();
      var cloneTypedArray = require_cloneTypedArray();
      var copyArray = require_copyArray();
      var initCloneObject = require_initCloneObject();
      var isArguments = require_isArguments();
      var isArray3 = require_isArray();
      var isArrayLikeObject = require_isArrayLikeObject();
      var isBuffer = require_isBuffer();
      var isFunction2 = require_isFunction();
      var isObject3 = require_isObject();
      var isPlainObject2 = require_isPlainObject();
      var isTypedArray = require_isTypedArray();
      var safeGet = require_safeGet();
      var toPlainObject = require_toPlainObject();
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray3(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray3(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject3(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      module.exports = baseMergeDeep;
    }
  });

  // ../node_modules/lodash/_baseMerge.js
  var require_baseMerge = __commonJS({
    "../node_modules/lodash/_baseMerge.js"(exports, module) {
      var Stack = require_Stack();
      var assignMergeValue = require_assignMergeValue();
      var baseFor = require_baseFor();
      var baseMergeDeep = require_baseMergeDeep();
      var isObject3 = require_isObject();
      var keysIn = require_keysIn();
      var safeGet = require_safeGet();
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject3(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      module.exports = baseMerge;
    }
  });

  // ../node_modules/lodash/merge.js
  var require_merge = __commonJS({
    "../node_modules/lodash/merge.js"(exports, module) {
      var baseMerge = require_baseMerge();
      var createAssigner = require_createAssigner();
      var merge4 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      module.exports = merge4;
    }
  });

  // ../node_modules/zod/lib/index.mjs
  function setErrorMap(map4) {
    overrideErrorMap = map4;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap
      ].filter((x3) => !!x3)
    });
    ctx.common.issues.push(issue);
  }
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject(__spreadProps(__spreadValues({}, schema._def), {
        shape: () => newShape
      }));
    } else if (schema instanceof ZodArray) {
      return ZodArray.create(deepPartialify(schema.element));
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  function mergeValues(a3, b3) {
    const aType = getParsedType(a3);
    const bType = getParsedType(b3);
    if (a3 === b3) {
      return { valid: true, data: a3 };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b3);
      const sharedKeys = util.objectKeys(a3).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = __spreadValues(__spreadValues({}, a3), b3);
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a3[key], b3[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a3.length !== b3.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a3.length; index++) {
        const itemA = a3[index];
        const itemB = b3[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a3 === +b3) {
      return { valid: true, data: a3 };
    } else {
      return { valid: false };
    }
  }
  function createZodEnum(values2, params) {
    return new ZodEnum(__spreadValues({
      values: values2,
      typeName: ZodFirstPartyTypeKind.ZodEnum
    }, processCreateParams(params)));
  }
  var util, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, ZodError, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, ParseInputLazyPath, handleResult, ZodType, cuidRegex, uuidRegex, emailRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, objectUtil, AugmentFactory, ZodObject, ZodUnion, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodNaN, BRAND, ZodBranded, custom, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, ostring, onumber, oboolean, NEVER, mod;
  var init_lib = __esm({
    "../node_modules/zod/lib/index.mjs"() {
      (function(util2) {
        util2.assertEqual = (val) => val;
        function assertIs(_arg) {
        }
        util2.assertIs = assertIs;
        function assertNever(_x) {
          throw new Error();
        }
        util2.assertNever = assertNever;
        util2.arrayToEnum = (items) => {
          const obj = {};
          for (const item of items) {
            obj[item] = item;
          }
          return obj;
        };
        util2.getValidEnumValues = (obj) => {
          const validKeys = util2.objectKeys(obj).filter((k3) => typeof obj[obj[k3]] !== "number");
          const filtered = {};
          for (const k3 of validKeys) {
            filtered[k3] = obj[k3];
          }
          return util2.objectValues(filtered);
        };
        util2.objectValues = (obj) => {
          return util2.objectKeys(obj).map(function(e2) {
            return obj[e2];
          });
        };
        util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
          const keys4 = [];
          for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              keys4.push(key);
            }
          }
          return keys4;
        };
        util2.find = (arr, checker) => {
          for (const item of arr) {
            if (checker(item))
              return item;
          }
          return void 0;
        };
        util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array, separator = " | ") {
          return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util2.joinValues = joinValues;
        util2.jsonStringifyReplacer = (_3, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          return value;
        };
      })(util || (util = {}));
      ZodParsedType = util.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
      ]);
      getParsedType = (data) => {
        const t3 = typeof data;
        switch (t3) {
          case "undefined":
            return ZodParsedType.undefined;
          case "string":
            return ZodParsedType.string;
          case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
          case "boolean":
            return ZodParsedType.boolean;
          case "function":
            return ZodParsedType.function;
          case "bigint":
            return ZodParsedType.bigint;
          case "object":
            if (Array.isArray(data)) {
              return ZodParsedType.array;
            }
            if (data === null) {
              return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return ZodParsedType.date;
            }
            return ZodParsedType.object;
          default:
            return ZodParsedType.unknown;
        }
      };
      ZodIssueCode = util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of"
      ]);
      quotelessJson = (obj) => {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
      };
      ZodError = class extends Error {
        constructor(issues) {
          super();
          this.issues = [];
          this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
          };
          this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
          };
          const actualProto = new.target.prototype;
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
          } else {
            this.__proto__ = actualProto;
          }
          this.name = "ZodError";
          this.issues = issues;
        }
        get errors() {
          return this.issues;
        }
        format(_mapper) {
          const mapper = _mapper || function(issue) {
            return issue.message;
          };
          const fieldErrors = { _errors: [] };
          const processError = (error) => {
            for (const issue of error.issues) {
              if (issue.code === "invalid_union") {
                issue.unionErrors.map(processError);
              } else if (issue.code === "invalid_return_type") {
                processError(issue.returnTypeError);
              } else if (issue.code === "invalid_arguments") {
                processError(issue.argumentsError);
              } else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
              } else {
                let curr = fieldErrors;
                let i3 = 0;
                while (i3 < issue.path.length) {
                  const el = issue.path[i3];
                  const terminal = i3 === issue.path.length - 1;
                  if (!terminal) {
                    curr[el] = curr[el] || { _errors: [] };
                  } else {
                    curr[el] = curr[el] || { _errors: [] };
                    curr[el]._errors.push(mapper(issue));
                  }
                  curr = curr[el];
                  i3++;
                }
              }
            }
          };
          processError(this);
          return fieldErrors;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return this.issues.length === 0;
        }
        flatten(mapper = (issue) => issue.message) {
          const fieldErrors = {};
          const formErrors = [];
          for (const sub of this.issues) {
            if (sub.path.length > 0) {
              fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
              fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
              formErrors.push(mapper(sub));
            }
          }
          return { formErrors, fieldErrors };
        }
        get formErrors() {
          return this.flatten();
        }
      };
      ZodError.create = (issues) => {
        const error = new ZodError(issues);
        return error;
      };
      errorMap = (issue, _ctx) => {
        let message;
        switch (issue.code) {
          case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
              message = "Required";
            } else {
              message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
          case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
          case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
          case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
          case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
          case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
          case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
          case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
          case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
              if ("startsWith" in issue.validation) {
                message = `Invalid input: must start with "${issue.validation.startsWith}"`;
              } else if ("endsWith" in issue.validation) {
                message = `Invalid input: must end with "${issue.validation.endsWith}"`;
              } else {
                util.assertNever(issue.validation);
              }
            } else if (issue.validation !== "regex") {
              message = `Invalid ${issue.validation}`;
            } else {
              message = "Invalid";
            }
            break;
          case ZodIssueCode.too_small:
            if (issue.type === "array")
              message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;
            else if (issue.type === "date")
              message = `Date must be greater than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.minimum)}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.too_big:
            if (issue.type === "array")
              message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;
            else if (issue.type === "date")
              message = `Date must be smaller than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.maximum)}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
          case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
          default:
            message = _ctx.defaultError;
            util.assertNever(issue);
        }
        return { message };
      };
      overrideErrorMap = errorMap;
      makeIssue = (params) => {
        const { data, path, errorMaps, issueData } = params;
        const fullPath = [...path, ...issueData.path || []];
        const fullIssue = __spreadProps(__spreadValues({}, issueData), {
          path: fullPath
        });
        let errorMessage = "";
        const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
        for (const map4 of maps) {
          errorMessage = map4(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return __spreadProps(__spreadValues({}, issueData), {
          path: fullPath,
          message: issueData.message || errorMessage
        });
      };
      EMPTY_PATH = [];
      ParseStatus = class _ParseStatus {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          if (this.value === "valid")
            this.value = "dirty";
        }
        abort() {
          if (this.value !== "aborted")
            this.value = "aborted";
        }
        static mergeArray(status, results) {
          const arrayValue = [];
          for (const s3 of results) {
            if (s3.status === "aborted")
              return INVALID;
            if (s3.status === "dirty")
              status.dirty();
            arrayValue.push(s3.value);
          }
          return { status: status.value, value: arrayValue };
        }
        static mergeObjectAsync(status, pairs) {
          return __async(this, null, function* () {
            const syncPairs = [];
            for (const pair of pairs) {
              syncPairs.push({
                key: yield pair.key,
                value: yield pair.value
              });
            }
            return _ParseStatus.mergeObjectSync(status, syncPairs);
          });
        }
        static mergeObjectSync(status, pairs) {
          const finalObject = {};
          for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
              return INVALID;
            if (value.status === "aborted")
              return INVALID;
            if (key.status === "dirty")
              status.dirty();
            if (value.status === "dirty")
              status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
              finalObject[key.value] = value.value;
            }
          }
          return { status: status.value, value: finalObject };
        }
      };
      INVALID = Object.freeze({
        status: "aborted"
      });
      DIRTY = (value) => ({ status: "dirty", value });
      OK = (value) => ({ status: "valid", value });
      isAborted = (x3) => x3.status === "aborted";
      isDirty = (x3) => x3.status === "dirty";
      isValid = (x3) => x3.status === "valid";
      isAsync = (x3) => typeof Promise !== void 0 && x3 instanceof Promise;
      (function(errorUtil2) {
        errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
        errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
      })(errorUtil || (errorUtil = {}));
      ParseInputLazyPath = class {
        constructor(parent, value, path, key) {
          this.parent = parent;
          this.data = value;
          this._path = path;
          this._key = key;
        }
        get path() {
          return this._path.concat(this._key);
        }
      };
      handleResult = (ctx, result) => {
        if (isValid(result)) {
          return { success: true, data: result.value };
        } else {
          if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
          }
          const error = new ZodError(ctx.common.issues);
          return { success: false, error };
        }
      };
      ZodType = class {
        constructor(def) {
          this.spa = this.safeParseAsync;
          this.superRefine = this._refinement;
          this._def = def;
          this.parse = this.parse.bind(this);
          this.safeParse = this.safeParse.bind(this);
          this.parseAsync = this.parseAsync.bind(this);
          this.safeParseAsync = this.safeParseAsync.bind(this);
          this.spa = this.spa.bind(this);
          this.refine = this.refine.bind(this);
          this.refinement = this.refinement.bind(this);
          this.superRefine = this.superRefine.bind(this);
          this.optional = this.optional.bind(this);
          this.nullable = this.nullable.bind(this);
          this.nullish = this.nullish.bind(this);
          this.array = this.array.bind(this);
          this.promise = this.promise.bind(this);
          this.or = this.or.bind(this);
          this.and = this.and.bind(this);
          this.transform = this.transform.bind(this);
          this.default = this.default.bind(this);
          this.describe = this.describe.bind(this);
          this.isNullable = this.isNullable.bind(this);
          this.isOptional = this.isOptional.bind(this);
        }
        get description() {
          return this._def.description;
        }
        _getType(input) {
          return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
          return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          };
        }
        _processInputParams(input) {
          return {
            status: new ParseStatus(),
            ctx: {
              common: input.parent.common,
              data: input.data,
              parsedType: getParsedType(input.data),
              schemaErrorMap: this._def.errorMap,
              path: input.path,
              parent: input.parent
            }
          };
        }
        _parseSync(input) {
          const result = this._parse(input);
          if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
          }
          return result;
        }
        _parseAsync(input) {
          const result = this._parse(input);
          return Promise.resolve(result);
        }
        parse(data, params) {
          const result = this.safeParse(data, params);
          if (result.success)
            return result.data;
          throw result.error;
        }
        safeParse(data, params) {
          var _a;
          const ctx = {
            common: {
              issues: [],
              async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
              contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
          };
          const result = this._parseSync({ data, path: ctx.path, parent: ctx });
          return handleResult(ctx, result);
        }
        parseAsync(data, params) {
          return __async(this, null, function* () {
            const result = yield this.safeParseAsync(data, params);
            if (result.success)
              return result.data;
            throw result.error;
          });
        }
        safeParseAsync(data, params) {
          return __async(this, null, function* () {
            const ctx = {
              common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true
              },
              path: (params === null || params === void 0 ? void 0 : params.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data,
              parsedType: getParsedType(data)
            };
            const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
            const result = yield isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult);
            return handleResult(ctx, result);
          });
        }
        refine(check, message) {
          const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
              return { message };
            } else if (typeof message === "function") {
              return message(val);
            } else {
              return message;
            }
          };
          return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue(__spreadValues({
              code: ZodIssueCode.custom
            }, getIssueProperties(val)));
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then((data) => {
                if (!data) {
                  setError();
                  return false;
                } else {
                  return true;
                }
              });
            }
            if (!result) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        refinement(check, refinementData) {
          return this._refinement((val, ctx) => {
            if (!check(val)) {
              ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
              return false;
            } else {
              return true;
            }
          });
        }
        _refinement(refinement) {
          return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement }
          });
        }
        optional() {
          return ZodOptional.create(this);
        }
        nullable() {
          return ZodNullable.create(this);
        }
        nullish() {
          return this.optional().nullable();
        }
        array() {
          return ZodArray.create(this);
        }
        promise() {
          return ZodPromise.create(this);
        }
        or(option) {
          return ZodUnion.create([this, option]);
        }
        and(incoming) {
          return ZodIntersection.create(this, incoming);
        }
        transform(transform) {
          return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform }
          });
        }
        default(def) {
          const defaultValueFunc = typeof def === "function" ? def : () => def;
          return new ZodDefault({
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
          });
        }
        brand() {
          return new ZodBranded(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this
          }, processCreateParams(void 0)));
        }
        describe(description) {
          const This = this.constructor;
          return new This(__spreadProps(__spreadValues({}, this._def), {
            description
          }));
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      };
      cuidRegex = /^c[^\s-]{8,}$/i;
      uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
      emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
      ZodString = class _ZodString extends ZodType {
        constructor() {
          super(...arguments);
          this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), __spreadValues({
            validation,
            code: ZodIssueCode.invalid_string
          }, errorUtil.errToObj(message)));
          this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
          this.trim = () => new _ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "trim" }]
          }));
        }
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.string) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(
              ctx2,
              {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx2.parsedType
              }
              //
            );
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.length < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.length > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "email") {
              if (!emailRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "email",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "uuid") {
              if (!uuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "uuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid") {
              if (!cuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "url") {
              try {
                new URL(input.data);
              } catch (_a) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "url",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "regex") {
              check.regex.lastIndex = 0;
              const testResult = check.regex.test(input.data);
              if (!testResult) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "regex",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "trim") {
              input.data = input.data.trim();
            } else if (check.kind === "startsWith") {
              if (!input.data.startsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { startsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "endsWith") {
              if (!input.data.endsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { endsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        _addCheck(check) {
          return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        email(message) {
          return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
        }
        url(message) {
          return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
        }
        uuid(message) {
          return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
        }
        cuid(message) {
          return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
        }
        regex(regex, message) {
          return this._addCheck(__spreadValues({
            kind: "regex",
            regex
          }, errorUtil.errToObj(message)));
        }
        startsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "startsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        endsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "endsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        min(minLength, message) {
          return this._addCheck(__spreadValues({
            kind: "min",
            value: minLength
          }, errorUtil.errToObj(message)));
        }
        max(maxLength, message) {
          return this._addCheck(__spreadValues({
            kind: "max",
            value: maxLength
          }, errorUtil.errToObj(message)));
        }
        length(len, message) {
          return this.min(len, message).max(len, message);
        }
        get isEmail() {
          return !!this._def.checks.find((ch) => ch.kind === "email");
        }
        get isURL() {
          return !!this._def.checks.find((ch) => ch.kind === "url");
        }
        get isUUID() {
          return !!this._def.checks.find((ch) => ch.kind === "uuid");
        }
        get isCUID() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid");
        }
        get minLength() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxLength() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodString.create = (params) => {
        return new ZodString(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodString
        }, processCreateParams(params)));
      };
      ZodNumber = class _ZodNumber extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
          this.step = this.multipleOf;
        }
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.number) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.number,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "int") {
              if (!util.isInteger(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (floatSafeRemainder(input.data, check.value) !== 0) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check) {
          return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        int(message) {
          return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message)
          });
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
        get isInt() {
          return !!this._def.checks.find((ch) => ch.kind === "int");
        }
      };
      ZodNumber.create = (params) => {
        return new ZodNumber(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodNumber
        }, processCreateParams(params)));
      };
      ZodBigInt = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.bigint,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodBigInt.create = (params) => {
        return new ZodBigInt(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodBigInt
        }, processCreateParams(params)));
      };
      ZodBoolean = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.boolean,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodBoolean.create = (params) => {
        return new ZodBoolean(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodBoolean
        }, processCreateParams(params)));
      };
      ZodDate = class _ZodDate extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.date) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.date,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          if (isNaN(input.data.getTime())) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_date
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.getTime() < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  message: check.message,
                  inclusive: true,
                  minimum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.getTime() > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  message: check.message,
                  inclusive: true,
                  maximum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return {
            status: status.value,
            value: new Date(input.data.getTime())
          };
        }
        _addCheck(check) {
          return new _ZodDate(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        min(minDate2, message) {
          return this._addCheck({
            kind: "min",
            value: minDate2.getTime(),
            message: errorUtil.toString(message)
          });
        }
        max(maxDate, message) {
          return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        get minDate() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min != null ? new Date(min) : null;
        }
        get maxDate() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max != null ? new Date(max) : null;
        }
      };
      ZodDate.create = (params) => {
        return new ZodDate(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodDate
        }, processCreateParams(params)));
      };
      ZodUndefined = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.undefined,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodUndefined.create = (params) => {
        return new ZodUndefined(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUndefined
        }, processCreateParams(params)));
      };
      ZodNull = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.null,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodNull.create = (params) => {
        return new ZodNull(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNull
        }, processCreateParams(params)));
      };
      ZodAny = class extends ZodType {
        constructor() {
          super(...arguments);
          this._any = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodAny.create = (params) => {
        return new ZodAny(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodAny
        }, processCreateParams(params)));
      };
      ZodUnknown = class extends ZodType {
        constructor() {
          super(...arguments);
          this._unknown = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodUnknown.create = (params) => {
        return new ZodUnknown(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUnknown
        }, processCreateParams(params)));
      };
      ZodNever = class extends ZodType {
        _parse(input) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType
          });
          return INVALID;
        }
      };
      ZodNever.create = (params) => {
        return new ZodNever(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNever
        }, processCreateParams(params)));
      };
      ZodVoid = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.void,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodVoid.create = (params) => {
        return new ZodVoid(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodVoid
        }, processCreateParams(params)));
      };
      ZodArray = class _ZodArray extends ZodType {
        _parse(input) {
          const { ctx, status } = this._processInputParams(input);
          const def = this._def;
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def.minLength.value,
                type: "array",
                inclusive: true,
                message: def.minLength.message
              });
              status.dirty();
            }
          }
          if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def.maxLength.value,
                type: "array",
                inclusive: true,
                message: def.maxLength.message
              });
              status.dirty();
            }
          }
          if (ctx.common.async) {
            return Promise.all(ctx.data.map((item, i3) => {
              return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
            })).then((result2) => {
              return ParseStatus.mergeArray(status, result2);
            });
          }
          const result = ctx.data.map((item, i3) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
          });
          return ParseStatus.mergeArray(status, result);
        }
        get element() {
          return this._def.type;
        }
        min(minLength, message) {
          return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
            minLength: { value: minLength, message: errorUtil.toString(message) }
          }));
        }
        max(maxLength, message) {
          return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
            maxLength: { value: maxLength, message: errorUtil.toString(message) }
          }));
        }
        length(len, message) {
          return this.min(len, message).max(len, message);
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodArray.create = (schema, params) => {
        return new ZodArray(__spreadValues({
          type: schema,
          minLength: null,
          maxLength: null,
          typeName: ZodFirstPartyTypeKind.ZodArray
        }, processCreateParams(params)));
      };
      (function(objectUtil2) {
        objectUtil2.mergeShapes = (first, second) => {
          return __spreadValues(__spreadValues({}, first), second);
        };
      })(objectUtil || (objectUtil = {}));
      AugmentFactory = (def) => (augmentation) => {
        return new ZodObject(__spreadProps(__spreadValues({}, def), {
          shape: () => __spreadValues(__spreadValues({}, def.shape()), augmentation)
        }));
      };
      ZodObject = class _ZodObject extends ZodType {
        constructor() {
          super(...arguments);
          this._cached = null;
          this.nonstrict = this.passthrough;
          this.augment = AugmentFactory(this._def);
          this.extend = AugmentFactory(this._def);
        }
        _getCached() {
          if (this._cached !== null)
            return this._cached;
          const shape = this._def.shape();
          const keys4 = util.objectKeys(shape);
          return this._cached = { shape, keys: keys4 };
        }
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.object) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const { status, ctx } = this._processInputParams(input);
          const { shape, keys: shapeKeys } = this._getCached();
          const extraKeys = [];
          if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
              if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
              }
            }
          }
          const pairs = [];
          for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
          if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
              for (const key of extraKeys) {
                pairs.push({
                  key: { status: "valid", value: key },
                  value: { status: "valid", value: ctx.data[key] }
                });
              }
            } else if (unknownKeys === "strict") {
              if (extraKeys.length > 0) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.unrecognized_keys,
                  keys: extraKeys
                });
                status.dirty();
              }
            } else if (unknownKeys === "strip")
              ;
            else {
              throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
          } else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
              const value = ctx.data[key];
              pairs.push({
                key: { status: "valid", value: key },
                value: catchall._parse(
                  new ParseInputLazyPath(ctx, value, ctx.path, key)
                  //, ctx.child(key), value, getParsedType(value)
                ),
                alwaysSet: key in ctx.data
              });
            }
          }
          if (ctx.common.async) {
            return Promise.resolve().then(() => __async(this, null, function* () {
              const syncPairs = [];
              for (const pair of pairs) {
                const key = yield pair.key;
                syncPairs.push({
                  key,
                  value: yield pair.value,
                  alwaysSet: pair.alwaysSet
                });
              }
              return syncPairs;
            })).then((syncPairs) => {
              return ParseStatus.mergeObjectSync(status, syncPairs);
            });
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get shape() {
          return this._def.shape();
        }
        strict(message) {
          errorUtil.errToObj;
          return new _ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strict"
          }), message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}));
        }
        strip() {
          return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strip"
          }));
        }
        passthrough() {
          return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "passthrough"
          }));
        }
        setKey(key, schema) {
          return this.augment({ [key]: schema });
        }
        /**
         * Prior to zod@1.0.12 there was a bug in the
         * inferred type of merged objects. Please
         * upgrade if you are experiencing issues.
         */
        merge(merging) {
          const merged = new _ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject
          });
          return merged;
        }
        catchall(index) {
          return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
            catchall: index
          }));
        }
        pick(mask) {
          const shape = {};
          util.objectKeys(mask).map((key) => {
            if (this.shape[key])
              shape[key] = this.shape[key];
          });
          return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        omit(mask) {
          const shape = {};
          util.objectKeys(this.shape).map((key) => {
            if (util.objectKeys(mask).indexOf(key) === -1) {
              shape[key] = this.shape[key];
            }
          });
          return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        deepPartial() {
          return deepPartialify(this);
        }
        partial(mask) {
          const newShape = {};
          if (mask) {
            util.objectKeys(this.shape).map((key) => {
              if (util.objectKeys(mask).indexOf(key) === -1) {
                newShape[key] = this.shape[key];
              } else {
                newShape[key] = this.shape[key].optional();
              }
            });
            return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
              shape: () => newShape
            }));
          } else {
            for (const key in this.shape) {
              const fieldSchema = this.shape[key];
              newShape[key] = fieldSchema.optional();
            }
          }
          return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        required() {
          const newShape = {};
          for (const key in this.shape) {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
          return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        keyof() {
          return createZodEnum(util.objectKeys(this.shape));
        }
      };
      ZodObject.create = (shape, params) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params)));
      };
      ZodObject.strictCreate = (shape, params) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strict",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params)));
      };
      ZodObject.lazycreate = (shape, params) => {
        return new ZodObject(__spreadValues({
          shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params)));
      };
      ZodUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const options = this._def.options;
          function handleResults(results) {
            for (const result of results) {
              if (result.result.status === "valid") {
                return result.result;
              }
            }
            for (const result of results) {
              if (result.result.status === "dirty") {
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
              }
            }
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return Promise.all(options.map((option) => __async(this, null, function* () {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              return {
                result: yield option._parseAsync({
                  data: ctx.data,
                  path: ctx.path,
                  parent: childCtx
                }),
                ctx: childCtx
              };
            }))).then(handleResults);
          } else {
            let dirty = void 0;
            const issues = [];
            for (const option of options) {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              const result = option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              });
              if (result.status === "valid") {
                return result;
              } else if (result.status === "dirty" && !dirty) {
                dirty = { result, ctx: childCtx };
              }
              if (childCtx.common.issues.length) {
                issues.push(childCtx.common.issues);
              }
            }
            if (dirty) {
              ctx.common.issues.push(...dirty.ctx.common.issues);
              return dirty.result;
            }
            const unionErrors = issues.map((issues2) => new ZodError(issues2));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
        }
        get options() {
          return this._def.options;
        }
      };
      ZodUnion.create = (types, params) => {
        return new ZodUnion(__spreadValues({
          options: types,
          typeName: ZodFirstPartyTypeKind.ZodUnion
        }, processCreateParams(params)));
      };
      ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const discriminator = this.discriminator;
          const discriminatorValue = ctx.data[discriminator];
          const option = this.options.get(discriminatorValue);
          if (!option) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union_discriminator,
              options: this.validDiscriminatorValues,
              path: [discriminator]
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          } else {
            return option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get validDiscriminatorValues() {
          return Array.from(this.options.keys());
        }
        get options() {
          return this._def.options;
        }
        /**
         * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
         * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
         * have a different value for each object in the union.
         * @param discriminator the name of the discriminator property
         * @param types an array of object schemas
         * @param params
         */
        static create(discriminator, types, params) {
          const options = /* @__PURE__ */ new Map();
          try {
            types.forEach((type) => {
              const discriminatorValue = type.shape[discriminator].value;
              options.set(discriminatorValue, type);
            });
          } catch (e2) {
            throw new Error("The discriminator value could not be extracted from all the provided schemas");
          }
          if (options.size !== types.length) {
            throw new Error("Some of the discriminator values are not unique");
          }
          return new _ZodDiscriminatedUnion(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options
          }, processCreateParams(params)));
        }
      };
      ZodIntersection = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
              return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_intersection_types
              });
              return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
              status.dirty();
            }
            return { status: status.value, value: merged.data };
          };
          if (ctx.common.async) {
            return Promise.all([
              this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              }),
              this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              })
            ]).then(([left, right]) => handleParsed(left, right));
          } else {
            return handleParsed(this._def.left._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }), this._def.right._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }));
          }
        }
      };
      ZodIntersection.create = (left, right, params) => {
        return new ZodIntersection(__spreadValues({
          left,
          right,
          typeName: ZodFirstPartyTypeKind.ZodIntersection
        }, processCreateParams(params)));
      };
      ZodTuple = class _ZodTuple extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: this._def.items.length,
              inclusive: true,
              type: "array"
            });
            return INVALID;
          }
          const rest = this._def.rest;
          if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: this._def.items.length,
              inclusive: true,
              type: "array"
            });
            status.dirty();
          }
          const items = ctx.data.map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
              return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
          }).filter((x3) => !!x3);
          if (ctx.common.async) {
            return Promise.all(items).then((results) => {
              return ParseStatus.mergeArray(status, results);
            });
          } else {
            return ParseStatus.mergeArray(status, items);
          }
        }
        get items() {
          return this._def.items;
        }
        rest(rest) {
          return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
            rest
          }));
        }
      };
      ZodTuple.create = (schemas2, params) => {
        if (!Array.isArray(schemas2)) {
          throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple(__spreadValues({
          items: schemas2,
          typeName: ZodFirstPartyTypeKind.ZodTuple,
          rest: null
        }, processCreateParams(params)));
      };
      ZodRecord = class _ZodRecord extends ZodType {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const pairs = [];
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          for (const key in ctx.data) {
            pairs.push({
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
              value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
            });
          }
          if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get element() {
          return this._def.valueType;
        }
        static create(first, second, third) {
          if (second instanceof ZodType) {
            return new _ZodRecord(__spreadValues({
              keyType: first,
              valueType: second,
              typeName: ZodFirstPartyTypeKind.ZodRecord
            }, processCreateParams(third)));
          }
          return new _ZodRecord(__spreadValues({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord
          }, processCreateParams(second)));
        }
      };
      ZodMap = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.map,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
              value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
            };
          });
          if (ctx.common.async) {
            const finalMap = /* @__PURE__ */ new Map();
            return Promise.resolve().then(() => __async(this, null, function* () {
              for (const pair of pairs) {
                const key = yield pair.key;
                const value = yield pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                  return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                  status.dirty();
                }
                finalMap.set(key.value, value.value);
              }
              return { status: status.value, value: finalMap };
            }));
          } else {
            const finalMap = /* @__PURE__ */ new Map();
            for (const pair of pairs) {
              const key = pair.key;
              const value = pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          }
        }
      };
      ZodMap.create = (keyType, valueType, params) => {
        return new ZodMap(__spreadValues({
          valueType,
          keyType,
          typeName: ZodFirstPartyTypeKind.ZodMap
        }, processCreateParams(params)));
      };
      ZodSet = class _ZodSet extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.set,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const def = this._def;
          if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def.minSize.value,
                type: "set",
                inclusive: true,
                message: def.minSize.message
              });
              status.dirty();
            }
          }
          if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def.maxSize.value,
                type: "set",
                inclusive: true,
                message: def.maxSize.message
              });
              status.dirty();
            }
          }
          const valueType = this._def.valueType;
          function finalizeSet(elements2) {
            const parsedSet = /* @__PURE__ */ new Set();
            for (const element of elements2) {
              if (element.status === "aborted")
                return INVALID;
              if (element.status === "dirty")
                status.dirty();
              parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
          }
          const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
          if (ctx.common.async) {
            return Promise.all(elements).then((elements2) => finalizeSet(elements2));
          } else {
            return finalizeSet(elements);
          }
        }
        min(minSize, message) {
          return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
            minSize: { value: minSize, message: errorUtil.toString(message) }
          }));
        }
        max(maxSize, message) {
          return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
            maxSize: { value: maxSize, message: errorUtil.toString(message) }
          }));
        }
        size(size, message) {
          return this.min(size, message).max(size, message);
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodSet.create = (valueType, params) => {
        return new ZodSet(__spreadValues({
          valueType,
          minSize: null,
          maxSize: null,
          typeName: ZodFirstPartyTypeKind.ZodSet
        }, processCreateParams(params)));
      };
      ZodFunction = class _ZodFunction extends ZodType {
        constructor() {
          super(...arguments);
          this.validate = this.implement;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.function,
              received: ctx.parsedType
            });
            return INVALID;
          }
          function makeArgsIssue(args, error) {
            return makeIssue({
              data: args,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x3) => !!x3),
              issueData: {
                code: ZodIssueCode.invalid_arguments,
                argumentsError: error
              }
            });
          }
          function makeReturnsIssue(returns, error) {
            return makeIssue({
              data: returns,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x3) => !!x3),
              issueData: {
                code: ZodIssueCode.invalid_return_type,
                returnTypeError: error
              }
            });
          }
          const params = { errorMap: ctx.common.contextualErrorMap };
          const fn2 = ctx.data;
          if (this._def.returns instanceof ZodPromise) {
            return OK((...args) => __async(this, null, function* () {
              const error = new ZodError([]);
              const parsedArgs = yield this._def.args.parseAsync(args, params).catch((e2) => {
                error.addIssue(makeArgsIssue(args, e2));
                throw error;
              });
              const result = yield fn2(...parsedArgs);
              const parsedReturns = yield this._def.returns._def.type.parseAsync(result, params).catch((e2) => {
                error.addIssue(makeReturnsIssue(result, e2));
                throw error;
              });
              return parsedReturns;
            }));
          } else {
            return OK((...args) => {
              const parsedArgs = this._def.args.safeParse(args, params);
              if (!parsedArgs.success) {
                throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
              }
              const result = fn2(...parsedArgs.data);
              const parsedReturns = this._def.returns.safeParse(result, params);
              if (!parsedReturns.success) {
                throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
              }
              return parsedReturns.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...items) {
          return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            args: ZodTuple.create(items).rest(ZodUnknown.create())
          }));
        }
        returns(returnType) {
          return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            returns: returnType
          }));
        }
        implement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        strictImplement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        static create(args, returns, params) {
          return new _ZodFunction(__spreadValues({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction
          }, processCreateParams(params)));
        }
      };
      ZodLazy = class extends ZodType {
        get schema() {
          return this._def.getter();
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const lazySchema = this._def.getter();
          return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
        }
      };
      ZodLazy.create = (getter, params) => {
        return new ZodLazy(__spreadValues({
          getter,
          typeName: ZodFirstPartyTypeKind.ZodLazy
        }, processCreateParams(params)));
      };
      ZodLiteral = class extends ZodType {
        _parse(input) {
          if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_literal,
              expected: this._def.value
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
        get value() {
          return this._def.value;
        }
      };
      ZodLiteral.create = (value, params) => {
        return new ZodLiteral(__spreadValues({
          value,
          typeName: ZodFirstPartyTypeKind.ZodLiteral
        }, processCreateParams(params)));
      };
      ZodEnum = class extends ZodType {
        _parse(input) {
          if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Values() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
      };
      ZodEnum.create = createZodEnum;
      ZodNativeEnum = class extends ZodType {
        _parse(input) {
          const nativeEnumValues = util.getValidEnumValues(this._def.values);
          const ctx = this._getOrReturnCtx(input);
          if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get enum() {
          return this._def.values;
        }
      };
      ZodNativeEnum.create = (values2, params) => {
        return new ZodNativeEnum(__spreadValues({
          values: values2,
          typeName: ZodFirstPartyTypeKind.ZodNativeEnum
        }, processCreateParams(params)));
      };
      ZodPromise = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.promise,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
          return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
              path: ctx.path,
              errorMap: ctx.common.contextualErrorMap
            });
          }));
        }
      };
      ZodPromise.create = (schema, params) => {
        return new ZodPromise(__spreadValues({
          type: schema,
          typeName: ZodFirstPartyTypeKind.ZodPromise
        }, processCreateParams(params)));
      };
      ZodEffects = class extends ZodType {
        innerType() {
          return this._def.schema;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const effect = this._def.effect || null;
          if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
              return Promise.resolve(processed).then((processed2) => {
                return this._def.schema._parseAsync({
                  data: processed2,
                  path: ctx.path,
                  parent: ctx
                });
              });
            } else {
              return this._def.schema._parseSync({
                data: processed,
                path: ctx.path,
                parent: ctx
              });
            }
          }
          const checkCtx = {
            addIssue: (arg) => {
              addIssueToContext(ctx, arg);
              if (arg.fatal) {
                status.abort();
              } else {
                status.dirty();
              }
            },
            get path() {
              return ctx.path;
            }
          };
          checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
          if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
              const result = effect.refinement(acc, checkCtx);
              if (ctx.common.async) {
                return Promise.resolve(result);
              }
              if (result instanceof Promise) {
                throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
              }
              return acc;
            };
            if (ctx.common.async === false) {
              const inner = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              executeRefinement(inner.value);
              return { status: status.value, value: inner.value };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                if (inner.status === "aborted")
                  return INVALID;
                if (inner.status === "dirty")
                  status.dirty();
                return executeRefinement(inner.value).then(() => {
                  return { status: status.value, value: inner.value };
                });
              });
            }
          }
          if (effect.type === "transform") {
            if (ctx.common.async === false) {
              const base = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (!isValid(base))
                return base;
              const result = effect.transform(base.value, checkCtx);
              if (result instanceof Promise) {
                throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
              }
              return { status: status.value, value: result };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
                if (!isValid(base))
                  return base;
                return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
              });
            }
          }
          util.assertNever(effect);
        }
      };
      ZodEffects.create = (schema, effect, params) => {
        return new ZodEffects(__spreadValues({
          schema,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect
        }, processCreateParams(params)));
      };
      ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
        return new ZodEffects(__spreadValues({
          schema,
          effect: { type: "preprocess", transform: preprocess },
          typeName: ZodFirstPartyTypeKind.ZodEffects
        }, processCreateParams(params)));
      };
      ZodOptional = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.undefined) {
            return OK(void 0);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodOptional.create = (type, params) => {
        return new ZodOptional(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodOptional
        }, processCreateParams(params)));
      };
      ZodNullable = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.null) {
            return OK(null);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodNullable.create = (type, params) => {
        return new ZodNullable(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodNullable
        }, processCreateParams(params)));
      };
      ZodDefault = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          let data = ctx.data;
          if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
          }
          return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        removeDefault() {
          return this._def.innerType;
        }
      };
      ZodDefault.create = (type, params) => {
        return new ZodOptional(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodOptional
        }, processCreateParams(params)));
      };
      ZodNaN = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.nan,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
      };
      ZodNaN.create = (params) => {
        return new ZodNaN(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNaN
        }, processCreateParams(params)));
      };
      BRAND = Symbol("zod_brand");
      ZodBranded = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const data = ctx.data;
          return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        unwrap() {
          return this._def.type;
        }
      };
      custom = (check, params = {}, fatal) => {
        if (check)
          return ZodAny.create().superRefine((data, ctx) => {
            if (!check(data)) {
              const p3 = typeof params === "function" ? params(data) : params;
              const p22 = typeof p3 === "string" ? { message: p3 } : p3;
              ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p22), { fatal }));
            }
          });
        return ZodAny.create();
      };
      late = {
        object: ZodObject.lazycreate
      };
      (function(ZodFirstPartyTypeKind2) {
        ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
      instanceOfType = (cls, params = {
        message: `Input not instance of ${cls.name}`
      }) => custom((data) => data instanceof cls, params, true);
      stringType = ZodString.create;
      numberType = ZodNumber.create;
      nanType = ZodNaN.create;
      bigIntType = ZodBigInt.create;
      booleanType = ZodBoolean.create;
      dateType = ZodDate.create;
      undefinedType = ZodUndefined.create;
      nullType = ZodNull.create;
      anyType = ZodAny.create;
      unknownType = ZodUnknown.create;
      neverType = ZodNever.create;
      voidType = ZodVoid.create;
      arrayType = ZodArray.create;
      objectType = ZodObject.create;
      strictObjectType = ZodObject.strictCreate;
      unionType = ZodUnion.create;
      discriminatedUnionType = ZodDiscriminatedUnion.create;
      intersectionType = ZodIntersection.create;
      tupleType = ZodTuple.create;
      recordType = ZodRecord.create;
      mapType = ZodMap.create;
      setType = ZodSet.create;
      functionType = ZodFunction.create;
      lazyType = ZodLazy.create;
      literalType = ZodLiteral.create;
      enumType = ZodEnum.create;
      nativeEnumType = ZodNativeEnum.create;
      promiseType = ZodPromise.create;
      effectsType = ZodEffects.create;
      optionalType = ZodOptional.create;
      nullableType = ZodNullable.create;
      preprocessType = ZodEffects.createWithPreprocess;
      ostring = () => stringType().optional();
      onumber = () => numberType().optional();
      oboolean = () => booleanType().optional();
      NEVER = INVALID;
      mod = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        getParsedType,
        ZodParsedType,
        defaultErrorMap: errorMap,
        setErrorMap,
        getErrorMap,
        makeIssue,
        EMPTY_PATH,
        addIssueToContext,
        ParseStatus,
        INVALID,
        DIRTY,
        OK,
        isAborted,
        isDirty,
        isValid,
        isAsync,
        ZodType,
        ZodString,
        ZodNumber,
        ZodBigInt,
        ZodBoolean,
        ZodDate,
        ZodUndefined,
        ZodNull,
        ZodAny,
        ZodUnknown,
        ZodNever,
        ZodVoid,
        ZodArray,
        get objectUtil() {
          return objectUtil;
        },
        ZodObject,
        ZodUnion,
        ZodDiscriminatedUnion,
        ZodIntersection,
        ZodTuple,
        ZodRecord,
        ZodMap,
        ZodSet,
        ZodFunction,
        ZodLazy,
        ZodLiteral,
        ZodEnum,
        ZodNativeEnum,
        ZodPromise,
        ZodEffects,
        ZodTransformer: ZodEffects,
        ZodOptional,
        ZodNullable,
        ZodDefault,
        ZodNaN,
        BRAND,
        ZodBranded,
        custom,
        Schema: ZodType,
        ZodSchema: ZodType,
        late,
        get ZodFirstPartyTypeKind() {
          return ZodFirstPartyTypeKind;
        },
        any: anyType,
        array: arrayType,
        bigint: bigIntType,
        boolean: booleanType,
        date: dateType,
        discriminatedUnion: discriminatedUnionType,
        effect: effectsType,
        "enum": enumType,
        "function": functionType,
        "instanceof": instanceOfType,
        intersection: intersectionType,
        lazy: lazyType,
        literal: literalType,
        map: mapType,
        nan: nanType,
        nativeEnum: nativeEnumType,
        never: neverType,
        "null": nullType,
        nullable: nullableType,
        number: numberType,
        object: objectType,
        oboolean,
        onumber,
        optional: optionalType,
        ostring,
        preprocess: preprocessType,
        promise: promiseType,
        record: recordType,
        set: setType,
        strictObject: strictObjectType,
        string: stringType,
        transformer: effectsType,
        tuple: tupleType,
        "undefined": undefinedType,
        union: unionType,
        unknown: unknownType,
        "void": voidType,
        NEVER,
        ZodIssueCode,
        quotelessJson,
        ZodError
      });
    }
  });

  // ../node_modules/validator/lib/util/assertString.js
  var require_assertString = __commonJS({
    "../node_modules/validator/lib/util/assertString.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = assertString;
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function assertString(input) {
        var isString3 = typeof input === "string" || input instanceof String;
        if (!isString3) {
          var invalidType = _typeof(input);
          if (input === null)
            invalidType = "null";
          else if (invalidType === "object")
            invalidType = input.constructor.name;
          throw new TypeError("Expected a string but received a ".concat(invalidType));
        }
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // ../node_modules/validator/lib/util/merge.js
  var require_merge2 = __commonJS({
    "../node_modules/validator/lib/util/merge.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = merge4;
      function merge4() {
        var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var defaults = arguments.length > 1 ? arguments[1] : void 0;
        for (var key in defaults) {
          if (typeof obj[key] === "undefined") {
            obj[key] = defaults[key];
          }
        }
        return obj;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // ../node_modules/validator/lib/isFQDN.js
  var require_isFQDN = __commonJS({
    "../node_modules/validator/lib/isFQDN.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isFQDN;
      var _assertString = _interopRequireDefault(require_assertString());
      var _merge = _interopRequireDefault(require_merge2());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var default_fqdn_options = {
        require_tld: true,
        allow_underscores: false,
        allow_trailing_dot: false,
        allow_numeric_tld: false,
        allow_wildcard: false
      };
      function isFQDN(str2, options) {
        (0, _assertString.default)(str2);
        options = (0, _merge.default)(options, default_fqdn_options);
        if (options.allow_trailing_dot && str2[str2.length - 1] === ".") {
          str2 = str2.substring(0, str2.length - 1);
        }
        if (options.allow_wildcard === true && str2.indexOf("*.") === 0) {
          str2 = str2.substring(2);
        }
        var parts = str2.split(".");
        var tld = parts[parts.length - 1];
        if (options.require_tld) {
          if (parts.length < 2) {
            return false;
          }
          if (!/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
            return false;
          }
          if (/\s/.test(tld)) {
            return false;
          }
        }
        if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
          return false;
        }
        return parts.every(function(part) {
          if (part.length > 63) {
            return false;
          }
          if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
            return false;
          }
          if (/[\uff01-\uff5e]/.test(part)) {
            return false;
          }
          if (/^-|-$/.test(part)) {
            return false;
          }
          if (!options.allow_underscores && /_/.test(part)) {
            return false;
          }
          return true;
        });
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // ../node_modules/validator/lib/isIP.js
  var require_isIP = __commonJS({
    "../node_modules/validator/lib/isIP.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isIP;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
      var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
      var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
      var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
      var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
      function isIP(str2) {
        var version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        (0, _assertString.default)(str2);
        version = String(version);
        if (!version) {
          return isIP(str2, 4) || isIP(str2, 6);
        }
        if (version === "4") {
          if (!IPv4AddressRegExp.test(str2)) {
            return false;
          }
          var parts = str2.split(".").sort(function(a3, b3) {
            return a3 - b3;
          });
          return parts[3] <= 255;
        }
        if (version === "6") {
          return !!IPv6AddressRegExp.test(str2);
        }
        return false;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // ../node_modules/validator/lib/isURL.js
  var require_isURL = __commonJS({
    "../node_modules/validator/lib/isURL.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isURL;
      var _assertString = _interopRequireDefault(require_assertString());
      var _isFQDN = _interopRequireDefault(require_isFQDN());
      var _isIP = _interopRequireDefault(require_isIP());
      var _merge = _interopRequireDefault(require_merge2());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray(arr, i3) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i3) || _unsupportedIterableToArray(arr, i3) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o3, minLen) {
        if (!o3)
          return;
        if (typeof o3 === "string")
          return _arrayLikeToArray(o3, minLen);
        var n3 = Object.prototype.toString.call(o3).slice(8, -1);
        if (n3 === "Object" && o3.constructor)
          n3 = o3.constructor.name;
        if (n3 === "Map" || n3 === "Set")
          return Array.from(o3);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return _arrayLikeToArray(o3, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
          arr2[i3] = arr[i3];
        }
        return arr2;
      }
      function _iterableToArrayLimit(arr, i3) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i3 && _arr.length === i3)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      var default_url_options = {
        protocols: ["http", "https", "ftp"],
        require_tld: true,
        require_protocol: false,
        require_host: true,
        require_port: false,
        require_valid_protocol: true,
        allow_underscores: false,
        allow_trailing_dot: false,
        allow_protocol_relative_urls: false,
        allow_fragments: true,
        allow_query_components: true,
        validate_length: true
      };
      var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
      function isRegExp(obj) {
        return Object.prototype.toString.call(obj) === "[object RegExp]";
      }
      function checkHost(host, matches) {
        for (var i3 = 0; i3 < matches.length; i3++) {
          var match = matches[i3];
          if (host === match || isRegExp(match) && match.test(host)) {
            return true;
          }
        }
        return false;
      }
      function isURL(url, options) {
        (0, _assertString.default)(url);
        if (!url || /[\s<>]/.test(url)) {
          return false;
        }
        if (url.indexOf("mailto:") === 0) {
          return false;
        }
        options = (0, _merge.default)(options, default_url_options);
        if (options.validate_length && url.length >= 2083) {
          return false;
        }
        if (!options.allow_fragments && url.includes("#")) {
          return false;
        }
        if (!options.allow_query_components && (url.includes("?") || url.includes("&"))) {
          return false;
        }
        var protocol, auth, host, hostname, port, port_str, split2, ipv6;
        split2 = url.split("#");
        url = split2.shift();
        split2 = url.split("?");
        url = split2.shift();
        split2 = url.split("://");
        if (split2.length > 1) {
          protocol = split2.shift().toLowerCase();
          if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
            return false;
          }
        } else if (options.require_protocol) {
          return false;
        } else if (url.substr(0, 2) === "//") {
          if (!options.allow_protocol_relative_urls) {
            return false;
          }
          split2[0] = url.substr(2);
        }
        url = split2.join("://");
        if (url === "") {
          return false;
        }
        split2 = url.split("/");
        url = split2.shift();
        if (url === "" && !options.require_host) {
          return true;
        }
        split2 = url.split("@");
        if (split2.length > 1) {
          if (options.disallow_auth) {
            return false;
          }
          if (split2[0] === "") {
            return false;
          }
          auth = split2.shift();
          if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
            return false;
          }
          var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray(_auth$split, 2), user2 = _auth$split2[0], password = _auth$split2[1];
          if (user2 === "" && password === "") {
            return false;
          }
        }
        hostname = split2.join("@");
        port_str = null;
        ipv6 = null;
        var ipv6_match = hostname.match(wrapped_ipv6);
        if (ipv6_match) {
          host = "";
          ipv6 = ipv6_match[1];
          port_str = ipv6_match[2] || null;
        } else {
          split2 = hostname.split(":");
          host = split2.shift();
          if (split2.length) {
            port_str = split2.join(":");
          }
        }
        if (port_str !== null && port_str.length > 0) {
          port = parseInt(port_str, 10);
          if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
            return false;
          }
        } else if (options.require_port) {
          return false;
        }
        if (options.host_whitelist) {
          return checkHost(host, options.host_whitelist);
        }
        if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
          return false;
        }
        host = host || ipv6;
        if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
          return false;
        }
        return true;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // ../node_modules/punycode/punycode.js
  var require_punycode = __commonJS({
    "../node_modules/punycode/punycode.js"(exports, module) {
      "use strict";
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map4(array, fn2) {
        const result = [];
        let length = array.length;
        while (length--) {
          result[length] = fn2(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn2) {
        const parts = string.split("@");
        let result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        const labels = string.split(".");
        const encoded = map4(labels, fn2).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        const output = [];
        let counter = 0;
        const length = string.length;
        while (counter < length) {
          const value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            const extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = (array) => String.fromCodePoint(...array);
      var basicToDigit = function(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function(delta, numPoints, firstTime) {
        let k3 = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k3 += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k3 + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function(input) {
        const output = [];
        const inputLength = input.length;
        let i3 = 0;
        let n3 = initialN;
        let bias = initialBias;
        let basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (let j3 = 0; j3 < basic; ++j3) {
          if (input.charCodeAt(j3) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j3));
        }
        for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          let oldi = i3;
          for (let w3 = 1, k3 = base; ; k3 += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            const digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i3) / w3)) {
              error("overflow");
            }
            i3 += digit * w3;
            const t3 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
            if (digit < t3) {
              break;
            }
            const baseMinusT = base - t3;
            if (w3 > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w3 *= baseMinusT;
          }
          const out = output.length + 1;
          bias = adapt(i3 - oldi, out, oldi == 0);
          if (floor(i3 / out) > maxInt - n3) {
            error("overflow");
          }
          n3 += floor(i3 / out);
          i3 %= out;
          output.splice(i3++, 0, n3);
        }
        return String.fromCodePoint(...output);
      };
      var encode = function(input) {
        const output = [];
        input = ucs2decode(input);
        let inputLength = input.length;
        let n3 = initialN;
        let delta = 0;
        let bias = initialBias;
        for (const currentValue of input) {
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        let basicLength = output.length;
        let handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          let m3 = maxInt;
          for (const currentValue of input) {
            if (currentValue >= n3 && currentValue < m3) {
              m3 = currentValue;
            }
          }
          const handledCPCountPlusOne = handledCPCount + 1;
          if (m3 - n3 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m3 - n3) * handledCPCountPlusOne;
          n3 = m3;
          for (const currentValue of input) {
            if (currentValue < n3 && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n3) {
              let q3 = delta;
              for (let k3 = base; ; k3 += base) {
                const t3 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
                if (q3 < t3) {
                  break;
                }
                const qMinusT = q3 - t3;
                const baseMinusT = base - t3;
                output.push(
                  stringFromCharCode(digitToBasic(t3 + qMinusT % baseMinusT, 0))
                );
                q3 = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q3, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n3;
        }
        return output.join("");
      };
      var toUnicode = function(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      module.exports = punycode;
    }
  });

  // ../node_modules/is-valid-domain/data/sldMap.json
  var require_sldMap = __commonJS({
    "../node_modules/is-valid-domain/data/sldMap.json"(exports, module) {
      module.exports = {
        "com.ac": true,
        "net.ac": true,
        "gov.ac": true,
        "org.ac": true,
        "mil.ac": true,
        "co.ae": true,
        "net.ae": true,
        "gov.ae": true,
        "ac.ae": true,
        "sch.ae": true,
        "org.ae": true,
        "mil.ae": true,
        "pro.ae": true,
        "name.ae": true,
        "com.af": true,
        "edu.af": true,
        "gov.af": true,
        "net.af": true,
        "org.af": true,
        "com.al": true,
        "edu.al": true,
        "gov.al": true,
        "mil.al": true,
        "net.al": true,
        "org.al": true,
        "ed.ao": true,
        "gv.ao": true,
        "og.ao": true,
        "co.ao": true,
        "pb.ao": true,
        "it.ao": true,
        "com.ar": true,
        "edu.ar": true,
        "gob.ar": true,
        "gov.ar": true,
        "int.ar": true,
        "mil.ar": true,
        "net.ar": true,
        "org.ar": true,
        "tur.ar": true,
        "gv.at": true,
        "ac.at": true,
        "co.at": true,
        "or.at": true,
        "com.au": true,
        "net.au": true,
        "org.au": true,
        "edu.au": true,
        "gov.au": true,
        "csiro.au": true,
        "asn.au": true,
        "id.au": true,
        "vic.au": true,
        "sa.au": true,
        "wa.au": true,
        "nt.au": true,
        "tas.au": true,
        "qld.au": true,
        "act.au": true,
        "conf.au": true,
        "oz.au": true,
        "org.ba": true,
        "net.ba": true,
        "edu.ba": true,
        "gov.ba": true,
        "mil.ba": true,
        "unsa.ba": true,
        "untz.ba": true,
        "unmo.ba": true,
        "unbi.ba": true,
        "unze.ba": true,
        "co.ba": true,
        "com.ba": true,
        "rs.ba": true,
        "co.bb": true,
        "com.bb": true,
        "net.bb": true,
        "org.bb": true,
        "gov.bb": true,
        "edu.bb": true,
        "info.bb": true,
        "store.bb": true,
        "tv.bb": true,
        "biz.bb": true,
        "com.bh": true,
        "info.bh": true,
        "cc.bh": true,
        "edu.bh": true,
        "biz.bh": true,
        "net.bh": true,
        "org.bh": true,
        "gov.bh": true,
        "com.bn": true,
        "edu.bn": true,
        "gov.bn": true,
        "net.bn": true,
        "org.bn": true,
        "com.bo": true,
        "net.bo": true,
        "org.bo": true,
        "tv.bo": true,
        "mil.bo": true,
        "int.bo": true,
        "gob.bo": true,
        "gov.bo": true,
        "edu.bo": true,
        "adm.br": true,
        "adv.br": true,
        "agr.br": true,
        "am.br": true,
        "arq.br": true,
        "art.br": true,
        "ato.br": true,
        "b.br": true,
        "bio.br": true,
        "blog.br": true,
        "bmd.br": true,
        "cim.br": true,
        "cng.br": true,
        "cnt.br": true,
        "com.br": true,
        "coop.br": true,
        "ecn.br": true,
        "edu.br": true,
        "eng.br": true,
        "esp.br": true,
        "etc.br": true,
        "eti.br": true,
        "far.br": true,
        "flog.br": true,
        "fm.br": true,
        "fnd.br": true,
        "fot.br": true,
        "fst.br": true,
        "g12.br": true,
        "ggf.br": true,
        "gov.br": true,
        "imb.br": true,
        "ind.br": true,
        "inf.br": true,
        "jor.br": true,
        "jus.br": true,
        "lel.br": true,
        "mat.br": true,
        "med.br": true,
        "mil.br": true,
        "mus.br": true,
        "net.br": true,
        "nom.br": true,
        "not.br": true,
        "ntr.br": true,
        "odo.br": true,
        "org.br": true,
        "ppg.br": true,
        "pro.br": true,
        "psc.br": true,
        "psi.br": true,
        "qsl.br": true,
        "rec.br": true,
        "slg.br": true,
        "srv.br": true,
        "tmp.br": true,
        "trd.br": true,
        "tur.br": true,
        "tv.br": true,
        "vet.br": true,
        "vlog.br": true,
        "wiki.br": true,
        "zlg.br": true,
        "com.bs": true,
        "net.bs": true,
        "org.bs": true,
        "edu.bs": true,
        "gov.bs": true,
        "om.bz": true,
        "du.bz": true,
        "ov.bz": true,
        "et.bz": true,
        "rg.bz": true,
        "ab.ca": true,
        "bc.ca": true,
        "mb.ca": true,
        "nb.ca": true,
        "nf.ca": true,
        "nl.ca": true,
        "ns.ca": true,
        "nt.ca": true,
        "nu.ca": true,
        "on.ca": true,
        "pe.ca": true,
        "qc.ca": true,
        "sk.ca": true,
        "yk.ca": true,
        "co.ck": true,
        "org.ck": true,
        "edu.ck": true,
        "gov.ck": true,
        "net.ck": true,
        "gen.ck": true,
        "biz.ck": true,
        "info.ck": true,
        "ac.cn": true,
        "com.cn": true,
        "edu.cn": true,
        "gov.cn": true,
        "mil.cn": true,
        "net.cn": true,
        "org.cn": true,
        "ah.cn": true,
        "bj.cn": true,
        "cq.cn": true,
        "fj.cn": true,
        "gd.cn": true,
        "gs.cn": true,
        "gz.cn": true,
        "gx.cn": true,
        "ha.cn": true,
        "hb.cn": true,
        "he.cn": true,
        "hi.cn": true,
        "hl.cn": true,
        "hn.cn": true,
        "jl.cn": true,
        "js.cn": true,
        "jx.cn": true,
        "ln.cn": true,
        "nm.cn": true,
        "nx.cn": true,
        "qh.cn": true,
        "sc.cn": true,
        "sd.cn": true,
        "sh.cn": true,
        "sn.cn": true,
        "sx.cn": true,
        "tj.cn": true,
        "tw.cn": true,
        "xj.cn": true,
        "xz.cn": true,
        "yn.cn": true,
        "zj.cn": true,
        "com.co": true,
        "org.co": true,
        "edu.co": true,
        "gov.co": true,
        "net.co": true,
        "mil.co": true,
        "nom.co": true,
        "ac.cr": true,
        "co.cr": true,
        "ed.cr": true,
        "fi.cr": true,
        "go.cr": true,
        "or.cr": true,
        "sa.cr": true,
        cr: true,
        "ac.cy": true,
        "net.cy": true,
        "gov.cy": true,
        "org.cy": true,
        "pro.cy": true,
        "name.cy": true,
        "ekloges.cy": true,
        "tm.cy": true,
        "ltd.cy": true,
        "biz.cy": true,
        "press.cy": true,
        "parliament.cy": true,
        "com.cy": true,
        "edu.do": true,
        "gob.do": true,
        "gov.do": true,
        "com.do": true,
        "sld.do": true,
        "org.do": true,
        "net.do": true,
        "web.do": true,
        "mil.do": true,
        "art.do": true,
        "com.dz": true,
        "org.dz": true,
        "net.dz": true,
        "gov.dz": true,
        "edu.dz": true,
        "asso.dz": true,
        "pol.dz": true,
        "art.dz": true,
        "com.ec": true,
        "info.ec": true,
        "net.ec": true,
        "fin.ec": true,
        "med.ec": true,
        "pro.ec": true,
        "org.ec": true,
        "edu.ec": true,
        "gov.ec": true,
        "mil.ec": true,
        "com.eg": true,
        "edu.eg": true,
        "eun.eg": true,
        "gov.eg": true,
        "mil.eg": true,
        "name.eg": true,
        "net.eg": true,
        "org.eg": true,
        "sci.eg": true,
        "com.er": true,
        "edu.er": true,
        "gov.er": true,
        "mil.er": true,
        "net.er": true,
        "org.er": true,
        "ind.er": true,
        "rochest.er": true,
        "w.er": true,
        "com.es": true,
        "nom.es": true,
        "org.es": true,
        "gob.es": true,
        "edu.es": true,
        "com.et": true,
        "gov.et": true,
        "org.et": true,
        "edu.et": true,
        "net.et": true,
        "biz.et": true,
        "name.et": true,
        "info.et": true,
        "ac.fj": true,
        "biz.fj": true,
        "com.fj": true,
        "info.fj": true,
        "mil.fj": true,
        "name.fj": true,
        "net.fj": true,
        "org.fj": true,
        "pro.fj": true,
        "co.fk": true,
        "org.fk": true,
        "gov.fk": true,
        "ac.fk": true,
        "nom.fk": true,
        "net.fk": true,
        fr: true,
        "tm.fr": true,
        "asso.fr": true,
        "nom.fr": true,
        "prd.fr": true,
        "presse.fr": true,
        "com.fr": true,
        "gouv.fr": true,
        "co.gg": true,
        "net.gg": true,
        "org.gg": true,
        "com.gh": true,
        "edu.gh": true,
        "gov.gh": true,
        "org.gh": true,
        "mil.gh": true,
        "co.gl": true,
        "com.gl": true,
        "edu.gl": true,
        "net.gl": true,
        "org.gl": true,
        "com.gn": true,
        "ac.gn": true,
        "gov.gn": true,
        "org.gn": true,
        "net.gn": true,
        "com.gr": true,
        "edu.gr": true,
        "net.gr": true,
        "org.gr": true,
        "gov.gr": true,
        "mil.gr": true,
        "com.gt": true,
        "edu.gt": true,
        "net.gt": true,
        "gob.gt": true,
        "org.gt": true,
        "mil.gt": true,
        "ind.gt": true,
        "com.gu": true,
        "net.gu": true,
        "gov.gu": true,
        "org.gu": true,
        "edu.gu": true,
        "com.hk": true,
        "edu.hk": true,
        "gov.hk": true,
        "idv.hk": true,
        "net.hk": true,
        "org.hk": true,
        "2000.hu": true,
        "agrar.hu": true,
        "bolt.hu": true,
        "casino.hu": true,
        "city.hu": true,
        "co.hu": true,
        "erotica.hu": true,
        "erotika.hu": true,
        "film.hu": true,
        "forum.hu": true,
        "games.hu": true,
        "hotel.hu": true,
        "info.hu": true,
        "ingatlan.hu": true,
        "jogasz.hu": true,
        "konyvelo.hu": true,
        "lakas.hu": true,
        "media.hu": true,
        "news.hu": true,
        "org.hu": true,
        "priv.hu": true,
        "reklam.hu": true,
        "sex.hu": true,
        "shop.hu": true,
        "sport.hu": true,
        "suli.huv": true,
        "szex.hu": true,
        "tm.hu": true,
        "tozsde.hu": true,
        "utazas.hu": true,
        "video.hu": true,
        "ac.id": true,
        "co.id": true,
        "net.id": true,
        "or.id": true,
        "web.id": true,
        "sch.id": true,
        "mil.id": true,
        "go.id": true,
        "war.net.id": true,
        "my.id": true,
        "biz.id": true,
        "ac.il": true,
        "co.il": true,
        "org.il": true,
        "net.il": true,
        "k12.il": true,
        "gov.il": true,
        "muni.il": true,
        "idf.il": true,
        in: true,
        "4fd.in": true,
        "co.in": true,
        "firm.in": true,
        "net.in": true,
        "org.in": true,
        "gen.in": true,
        "ind.in": true,
        "ac.in": true,
        "edu.in": true,
        "res.in": true,
        "ernet.in": true,
        "gov.in": true,
        "mil.in": true,
        "nic.in": true,
        iq: true,
        "gov.iq": true,
        "edu.iq": true,
        "com.iq": true,
        "mil.iq": true,
        "org.iq": true,
        "net.iq": true,
        ir: true,
        "ac.ir": true,
        "co.ir": true,
        "gov.ir": true,
        "id.ir": true,
        "net.ir": true,
        "org.ir": true,
        "sch.ir": true,
        "dnssec.ir": true,
        "gov.it": true,
        "edu.it": true,
        "co.je": true,
        "net.je": true,
        "org.je": true,
        "com.jo": true,
        "net.jo": true,
        "gov.jo": true,
        "edu.jo": true,
        "org.jo": true,
        "mil.jo": true,
        "name.jo": true,
        "sch.jo": true,
        "ac.jp": true,
        "ad.jp": true,
        "co.jp": true,
        "ed.jp": true,
        "go.jp": true,
        "gr.jp": true,
        "lg.jp": true,
        "ne.jp": true,
        "or.jp": true,
        "co.ke": true,
        "or.ke": true,
        "ne.ke": true,
        "go.ke": true,
        "ac.ke": true,
        "sc.ke": true,
        "me.ke": true,
        "mobi.ke": true,
        "info.ke": true,
        "per.kh": true,
        "com.kh": true,
        "edu.kh": true,
        "gov.kh": true,
        "mil.kh": true,
        "net.kh": true,
        "org.kh": true,
        "com.ki": true,
        "biz.ki": true,
        "de.ki": true,
        "net.ki": true,
        "info.ki": true,
        "org.ki": true,
        "gov.ki": true,
        "edu.ki": true,
        "mob.ki": true,
        "tel.ki": true,
        km: true,
        "com.km": true,
        "coop.km": true,
        "asso.km": true,
        "nom.km": true,
        "presse.km": true,
        "tm.km": true,
        "medecin.km": true,
        "notaires.km": true,
        "pharmaciens.km": true,
        "veterinaire.km": true,
        "edu.km": true,
        "gouv.km": true,
        "mil.km": true,
        "net.kn": true,
        "org.kn": true,
        "edu.kn": true,
        "gov.kn": true,
        kr: true,
        "co.kr": true,
        "ne.kr": true,
        "or.kr": true,
        "re.kr": true,
        "pe.kr": true,
        "go.kr": true,
        "mil.kr": true,
        "ac.kr": true,
        "hs.kr": true,
        "ms.kr": true,
        "es.kr": true,
        "sc.kr": true,
        "kg.kr": true,
        "seoul.kr": true,
        "busan.kr": true,
        "daegu.kr": true,
        "incheon.kr": true,
        "gwangju.kr": true,
        "daejeon.kr": true,
        "ulsan.kr": true,
        "gyeonggi.kr": true,
        "gangwon.kr": true,
        "chungbuk.kr": true,
        "chungnam.kr": true,
        "jeonbuk.kr": true,
        "jeonnam.kr": true,
        "gyeongbuk.kr": true,
        "gyeongnam.kr": true,
        "jeju.kr": true,
        "edu.kw": true,
        "com.kw": true,
        "net.kw": true,
        "org.kw": true,
        "gov.kw": true,
        "com.ky": true,
        "org.ky": true,
        "net.ky": true,
        "edu.ky": true,
        "gov.ky": true,
        "com.kz": true,
        "edu.kz": true,
        "gov.kz": true,
        "mil.kz": true,
        "net.kz": true,
        "org.kz": true,
        "com.lb": true,
        "edu.lb": true,
        "gov.lb": true,
        "net.lb": true,
        "org.lb": true,
        "gov.lk": true,
        "sch.lk": true,
        "net.lk": true,
        "int.lk": true,
        "com.lk": true,
        "org.lk": true,
        "edu.lk": true,
        "ngo.lk": true,
        "soc.lk": true,
        "web.lk": true,
        "ltd.lk": true,
        "assn.lk": true,
        "grp.lk": true,
        "hotel.lk": true,
        "com.lr": true,
        "edu.lr": true,
        "gov.lr": true,
        "org.lr": true,
        "net.lr": true,
        "com.lv": true,
        "edu.lv": true,
        "gov.lv": true,
        "org.lv": true,
        "mil.lv": true,
        "id.lv": true,
        "net.lv": true,
        "asn.lv": true,
        "conf.lv": true,
        "com.ly": true,
        "net.ly": true,
        "gov.ly": true,
        "plc.ly": true,
        "edu.ly": true,
        "sch.ly": true,
        "med.ly": true,
        "org.ly": true,
        "id.ly": true,
        ma: true,
        "net.ma": true,
        "ac.ma": true,
        "org.ma": true,
        "gov.ma": true,
        "press.ma": true,
        "co.ma": true,
        "tm.mc": true,
        "asso.mc": true,
        "co.me": true,
        "net.me": true,
        "org.me": true,
        "edu.me": true,
        "ac.me": true,
        "gov.me": true,
        "its.me": true,
        "priv.me": true,
        "org.mg": true,
        "nom.mg": true,
        "gov.mg": true,
        "prd.mg": true,
        "tm.mg": true,
        "edu.mg": true,
        "mil.mg": true,
        "com.mg": true,
        "com.mk": true,
        "org.mk": true,
        "net.mk": true,
        "edu.mk": true,
        "gov.mk": true,
        "inf.mk": true,
        "name.mk": true,
        "pro.mk": true,
        "com.ml": true,
        "net.ml": true,
        "org.ml": true,
        "edu.ml": true,
        "gov.ml": true,
        "presse.ml": true,
        "gov.mn": true,
        "edu.mn": true,
        "org.mn": true,
        "com.mo": true,
        "edu.mo": true,
        "gov.mo": true,
        "net.mo": true,
        "org.mo": true,
        "com.mt": true,
        "org.mt": true,
        "net.mt": true,
        "edu.mt": true,
        "gov.mt": true,
        "aero.mv": true,
        "biz.mv": true,
        "com.mv": true,
        "coop.mv": true,
        "edu.mv": true,
        "gov.mv": true,
        "info.mv": true,
        "int.mv": true,
        "mil.mv": true,
        "museum.mv": true,
        "name.mv": true,
        "net.mv": true,
        "org.mv": true,
        "pro.mv": true,
        "ac.mw": true,
        "co.mw": true,
        "com.mw": true,
        "coop.mw": true,
        "edu.mw": true,
        "gov.mw": true,
        "int.mw": true,
        "museum.mw": true,
        "net.mw": true,
        "org.mw": true,
        "com.mx": true,
        "net.mx": true,
        "org.mx": true,
        "edu.mx": true,
        "gob.mx": true,
        "com.my": true,
        "net.my": true,
        "org.my": true,
        "gov.my": true,
        "edu.my": true,
        "sch.my": true,
        "mil.my": true,
        "name.my": true,
        "com.nf": true,
        "net.nf": true,
        "arts.nf": true,
        "store.nf": true,
        "web.nf": true,
        "firm.nf": true,
        "info.nf": true,
        "other.nf": true,
        "per.nf": true,
        "rec.nf": true,
        "com.ng": true,
        "org.ng": true,
        "gov.ng": true,
        "edu.ng": true,
        "net.ng": true,
        "sch.ng": true,
        "name.ng": true,
        "mobi.ng": true,
        "biz.ng": true,
        "mil.ng": true,
        "gob.ni": true,
        "co.ni": true,
        "com.ni": true,
        "ac.ni": true,
        "edu.ni": true,
        "org.ni": true,
        "nom.ni": true,
        "net.ni": true,
        "mil.ni": true,
        "com.np": true,
        "edu.np": true,
        "gov.np": true,
        "org.np": true,
        "mil.np": true,
        "net.np": true,
        "edu.nr": true,
        "gov.nr": true,
        "biz.nr": true,
        "info.nr": true,
        "net.nr": true,
        "org.nr": true,
        "com.nr": true,
        "com.om": true,
        "co.om": true,
        "edu.om": true,
        "ac.om": true,
        "sch.om": true,
        "gov.om": true,
        "net.om": true,
        "org.om": true,
        "mil.om": true,
        "museum.om": true,
        "biz.om": true,
        "pro.om": true,
        "med.om": true,
        "edu.pe": true,
        "gob.pe": true,
        "nom.pe": true,
        "mil.pe": true,
        "sld.pe": true,
        "org.pe": true,
        "com.pe": true,
        "net.pe": true,
        "com.ph": true,
        "net.ph": true,
        "org.ph": true,
        "mil.ph": true,
        "ngo.ph": true,
        "i.ph": true,
        "gov.ph": true,
        "edu.ph": true,
        "com.pk": true,
        "net.pk": true,
        "edu.pk": true,
        "org.pk": true,
        "fam.pk": true,
        "biz.pk": true,
        "web.pk": true,
        "gov.pk": true,
        "gob.pk": true,
        "gok.pk": true,
        "gon.pk": true,
        "gop.pk": true,
        "gos.pk": true,
        "pwr.pl": true,
        "com.pl": true,
        "biz.pl": true,
        "net.pl": true,
        "art.pl": true,
        "edu.pl": true,
        "org.pl": true,
        "ngo.pl": true,
        "gov.pl": true,
        "info.pl": true,
        "mil.pl": true,
        "waw.pl": true,
        "warszawa.pl": true,
        "wroc.pl": true,
        "wroclaw.pl": true,
        "krakow.pl": true,
        "katowice.pl": true,
        "poznan.pl": true,
        "lodz.pl": true,
        "gda.pl": true,
        "gdansk.pl": true,
        "slupsk.pl": true,
        "radom.pl": true,
        "szczecin.pl": true,
        "lublin.pl": true,
        "bialystok.pl": true,
        "olsztyn.pl": true,
        "torun.pl": true,
        "gorzow.pl": true,
        "zgora.pl": true,
        "biz.pr": true,
        "com.pr": true,
        "edu.pr": true,
        "gov.pr": true,
        "info.pr": true,
        "isla.pr": true,
        "name.pr": true,
        "net.pr": true,
        "org.pr": true,
        "pro.pr": true,
        "est.pr": true,
        "prof.pr": true,
        "ac.pr": true,
        "com.ps": true,
        "net.ps": true,
        "org.ps": true,
        "edu.ps": true,
        "gov.ps": true,
        "plo.ps": true,
        "sec.ps": true,
        "co.pw": true,
        "ne.pw": true,
        "or.pw": true,
        "ed.pw": true,
        "go.pw": true,
        "belau.pw": true,
        "arts.ro": true,
        "com.ro": true,
        "firm.ro": true,
        "info.ro": true,
        "nom.ro": true,
        "nt.ro": true,
        "org.ro": true,
        "rec.ro": true,
        "store.ro": true,
        "tm.ro": true,
        "www.ro": true,
        "co.rs": true,
        "org.rs": true,
        "edu.rs": true,
        "ac.rs": true,
        "gov.rs": true,
        "in.rs": true,
        "com.sb": true,
        "net.sb": true,
        "edu.sb": true,
        "org.sb": true,
        "gov.sb": true,
        "com.sc": true,
        "net.sc": true,
        "edu.sc": true,
        "gov.sc": true,
        "org.sc": true,
        "co.sh": true,
        "com.sh": true,
        "org.sh": true,
        "gov.sh": true,
        "edu.sh": true,
        "net.sh": true,
        "nom.sh": true,
        "com.sl": true,
        "net.sl": true,
        "org.sl": true,
        "edu.sl": true,
        "gov.sl": true,
        "gov.st": true,
        "saotome.st": true,
        "principe.st": true,
        "consulado.st": true,
        "embaixada.st": true,
        "org.st": true,
        "edu.st": true,
        "net.st": true,
        "com.st": true,
        "store.st": true,
        "mil.st": true,
        "co.st": true,
        "edu.sv": true,
        "gob.sv": true,
        "com.sv": true,
        "org.sv": true,
        "red.sv": true,
        "co.sz": true,
        "ac.sz": true,
        "org.sz": true,
        "com.tr": true,
        "gen.tr": true,
        "org.tr": true,
        "biz.tr": true,
        "info.tr": true,
        "av.tr": true,
        "dr.tr": true,
        "pol.tr": true,
        "bel.tr": true,
        "tsk.tr": true,
        "bbs.tr": true,
        "k12.tr": true,
        "edu.tr": true,
        "name.tr": true,
        "net.tr": true,
        "gov.tr": true,
        "web.tr": true,
        "tel.tr": true,
        "tv.tr": true,
        "co.tt": true,
        "com.tt": true,
        "org.tt": true,
        "net.tt": true,
        "biz.tt": true,
        "info.tt": true,
        "pro.tt": true,
        "int.tt": true,
        "coop.tt": true,
        "jobs.tt": true,
        "mobi.tt": true,
        "travel.tt": true,
        "museum.tt": true,
        "aero.tt": true,
        "cat.tt": true,
        "tel.tt": true,
        "name.tt": true,
        "mil.tt": true,
        "edu.tt": true,
        "gov.tt": true,
        "edu.tw": true,
        "gov.tw": true,
        "mil.tw": true,
        "com.tw": true,
        "net.tw": true,
        "org.tw": true,
        "idv.tw": true,
        "game.tw": true,
        "ebiz.tw": true,
        "club.tw": true,
        "com.mu": true,
        "gov.mu": true,
        "net.mu": true,
        "org.mu": true,
        "ac.mu": true,
        "co.mu": true,
        "or.mu": true,
        "ac.mz": true,
        "co.mz": true,
        "edu.mz": true,
        "org.mz": true,
        "gov.mz": true,
        "com.na": true,
        "co.na": true,
        "ac.nz": true,
        "co.nz": true,
        "cri.nz": true,
        "geek.nz": true,
        "gen.nz": true,
        "govt.nz": true,
        "health.nz": true,
        "iwi.nz": true,
        "maori.nz": true,
        "mil.nz": true,
        "net.nz": true,
        "org.nz": true,
        "parliament.nz": true,
        "school.nz": true,
        "abo.pa": true,
        "ac.pa": true,
        "com.pa": true,
        "edu.pa": true,
        "gob.pa": true,
        "ing.pa": true,
        "med.pa": true,
        "net.pa": true,
        "nom.pa": true,
        "org.pa": true,
        "sld.pa": true,
        "com.pt": true,
        "edu.pt": true,
        "gov.pt": true,
        "int.pt": true,
        "net.pt": true,
        "nome.pt": true,
        "org.pt": true,
        "publ.pt": true,
        "com.py": true,
        "edu.py": true,
        "gov.py": true,
        "mil.py": true,
        "net.py": true,
        "org.py": true,
        "com.qa": true,
        "edu.qa": true,
        "gov.qa": true,
        "mil.qa": true,
        "net.qa": true,
        "org.qa": true,
        "asso.re": true,
        "com.re": true,
        "nom.re": true,
        "ac.ru": true,
        "adygeya.ru": true,
        "altai.ru": true,
        "amur.ru": true,
        "arkhangelsk.ru": true,
        "astrakhan.ru": true,
        "bashkiria.ru": true,
        "belgorod.ru": true,
        "bir.ru": true,
        "bryansk.ru": true,
        "buryatia.ru": true,
        "cbg.ru": true,
        "chel.ru": true,
        "chelyabinsk.ru": true,
        "chita.ru": true,
        "chukotka.ru": true,
        "chuvashia.ru": true,
        "com.ru": true,
        "dagestan.ru": true,
        "e-burg.ru": true,
        "edu.ru": true,
        "gov.ru": true,
        "grozny.ru": true,
        "int.ru": true,
        "irkutsk.ru": true,
        "ivanovo.ru": true,
        "izhevsk.ru": true,
        "jar.ru": true,
        "joshkar-ola.ru": true,
        "kalmykia.ru": true,
        "kaluga.ru": true,
        "kamchatka.ru": true,
        "karelia.ru": true,
        "kazan.ru": true,
        "kchr.ru": true,
        "kemerovo.ru": true,
        "khabarovsk.ru": true,
        "khakassia.ru": true,
        "khv.ru": true,
        "kirov.ru": true,
        "koenig.ru": true,
        "komi.ru": true,
        "kostroma.ru": true,
        "kranoyarsk.ru": true,
        "kuban.ru": true,
        "kurgan.ru": true,
        "kursk.ru": true,
        "lipetsk.ru": true,
        "magadan.ru": true,
        "mari.ru": true,
        "mari-el.ru": true,
        "marine.ru": true,
        "mil.ru": true,
        "mordovia.ru": true,
        "mosreg.ru": true,
        "msk.ru": true,
        "murmansk.ru": true,
        "nalchik.ru": true,
        "net.ru": true,
        "nnov.ru": true,
        "nov.ru": true,
        "novosibirsk.ru": true,
        "nsk.ru": true,
        "omsk.ru": true,
        "orenburg.ru": true,
        "org.ru": true,
        "oryol.ru": true,
        "penza.ru": true,
        "perm.ru": true,
        "pp.ru": true,
        "pskov.ru": true,
        "ptz.ru": true,
        "rnd.ru": true,
        "ryazan.ru": true,
        "sakhalin.ru": true,
        "samara.ru": true,
        "saratov.ru": true,
        "simbirsk.ru": true,
        "smolensk.ru": true,
        "spb.ru": true,
        "stavropol.ru": true,
        "stv.ru": true,
        "surgut.ru": true,
        "tambov.ru": true,
        "tatarstan.ru": true,
        "tom.ru": true,
        "tomsk.ru": true,
        "tsaritsyn.ru": true,
        "tsk.ru": true,
        "tula.ru": true,
        "tuva.ru": true,
        "tver.ru": true,
        "tyumen.ru": true,
        "udm.ru": true,
        "udmurtia.ru": true,
        "ulan-ude.ru": true,
        "vladikavkaz.ru": true,
        "vladimir.ru": true,
        "vladivostok.ru": true,
        "volgograd.ru": true,
        "vologda.ru": true,
        "voronezh.ru": true,
        "vrn.ru": true,
        "vyatka.ru": true,
        "yakutia.ru": true,
        "yamal.ru": true,
        "yekaterinburg.ru": true,
        "yuzhno-sakhalinsk.ru": true,
        "ac.rw": true,
        "co.rw": true,
        "com.rw": true,
        "edu.rw": true,
        "gouv.rw": true,
        "gov.rw": true,
        "int.rw": true,
        "mil.rw": true,
        "net.rw": true,
        "com.sa": true,
        "edu.sa": true,
        "gov.sa": true,
        "med.sa": true,
        "net.sa": true,
        "org.sa": true,
        "pub.sa": true,
        "sch.sa": true,
        "com.sd": true,
        "edu.sd": true,
        "gov.sd": true,
        "info.sd": true,
        "med.sd": true,
        "net.sd": true,
        "org.sd": true,
        "tv.sd": true,
        "a.se": true,
        "ac.se": true,
        "b.se": true,
        "bd.se": true,
        "c.se": true,
        "d.se": true,
        "e.se": true,
        "f.se": true,
        "g.se": true,
        "h.se": true,
        "i.se": true,
        "k.se": true,
        "l.se": true,
        "m.se": true,
        "n.se": true,
        "o.se": true,
        "org.se": true,
        "p.se": true,
        "parti.se": true,
        "pp.se": true,
        "press.se": true,
        "r.se": true,
        "s.se": true,
        "t.se": true,
        "tm.se": true,
        "u.se": true,
        "w.se": true,
        "x.se": true,
        "y.se": true,
        "z.se": true,
        "com.sg": true,
        "edu.sg": true,
        "gov.sg": true,
        "idn.sg": true,
        "net.sg": true,
        "org.sg": true,
        "per.sg": true,
        "art.sn": true,
        "com.sn": true,
        "edu.sn": true,
        "gouv.sn": true,
        "org.sn": true,
        "perso.sn": true,
        "univ.sn": true,
        "com.sy": true,
        "edu.sy": true,
        "gov.sy": true,
        "mil.sy": true,
        "net.sy": true,
        "news.sy": true,
        "org.sy": true,
        "ac.th": true,
        "co.th": true,
        "go.th": true,
        "in.th": true,
        "mi.th": true,
        "net.th": true,
        "or.th": true,
        "ac.tj": true,
        "biz.tj": true,
        "co.tj": true,
        "com.tj": true,
        "edu.tj": true,
        "go.tj": true,
        "gov.tj": true,
        "info.tj": true,
        "int.tj": true,
        "mil.tj": true,
        "name.tj": true,
        "net.tj": true,
        "nic.tj": true,
        "org.tj": true,
        "test.tj": true,
        "web.tj": true,
        "agrinet.tn": true,
        "com.tn": true,
        "defense.tn": true,
        "edunet.tn": true,
        "ens.tn": true,
        "fin.tn": true,
        "gov.tn": true,
        "ind.tn": true,
        "info.tn": true,
        "intl.tn": true,
        "mincom.tn": true,
        "nat.tn": true,
        "net.tn": true,
        "org.tn": true,
        "perso.tn": true,
        "rnrt.tn": true,
        "rns.tn": true,
        "rnu.tn": true,
        "tourism.tn": true,
        "ac.tz": true,
        "co.tz": true,
        "go.tz": true,
        "ne.tz": true,
        "or.tz": true,
        "biz.ua": true,
        "cherkassy.ua": true,
        "chernigov.ua": true,
        "chernovtsy.ua": true,
        "ck.ua": true,
        "cn.ua": true,
        "co.ua": true,
        "com.ua": true,
        "crimea.ua": true,
        "cv.ua": true,
        "dn.ua": true,
        "dnepropetrovsk.ua": true,
        "donetsk.ua": true,
        "dp.ua": true,
        "edu.ua": true,
        "gov.ua": true,
        "if.ua": true,
        "in.ua": true,
        "ivano-frankivsk.ua": true,
        "kh.ua": true,
        "kharkov.ua": true,
        "kherson.ua": true,
        "khmelnitskiy.ua": true,
        "kiev.ua": true,
        "kirovograd.ua": true,
        "km.ua": true,
        "kr.ua": true,
        "ks.ua": true,
        "kv.ua": true,
        "lg.ua": true,
        "lugansk.ua": true,
        "lutsk.ua": true,
        "lviv.ua": true,
        "me.ua": true,
        "mk.ua": true,
        "net.ua": true,
        "nikolaev.ua": true,
        "od.ua": true,
        "odessa.ua": true,
        "org.ua": true,
        "pl.ua": true,
        "poltava.ua": true,
        "pp.ua": true,
        "rovno.ua": true,
        "rv.ua": true,
        "sebastopol.ua": true,
        "sumy.ua": true,
        "te.ua": true,
        "ternopil.ua": true,
        "uzhgorod.ua": true,
        "vinnica.ua": true,
        "vn.ua": true,
        "zaporizhzhe.ua": true,
        "zhitomir.ua": true,
        "zp.ua": true,
        "zt.ua": true,
        "ac.ug": true,
        "co.ug": true,
        "go.ug": true,
        "ne.ug": true,
        "or.ug": true,
        "org.ug": true,
        "sc.ug": true,
        "ac.uk": true,
        "bl.uk": true,
        "british-library.uk": true,
        "co.uk": true,
        "cym.uk": true,
        "gov.uk": true,
        "govt.uk": true,
        "icnet.uk": true,
        "jet.uk": true,
        "lea.uk": true,
        "ltd.uk": true,
        "me.uk": true,
        "mil.uk": true,
        "mod.uk": true,
        "national-library-scotland.uk": true,
        "nel.uk": true,
        "net.uk": true,
        "nhs.uk": true,
        "nic.uk": true,
        "nls.uk": true,
        "org.uk": true,
        "orgn.uk": true,
        "parliament.uk": true,
        "plc.uk": true,
        "police.uk": true,
        "sch.uk": true,
        "scot.uk": true,
        "soc.uk": true,
        "4fd.us": true,
        "dni.us": true,
        "fed.us": true,
        "isa.us": true,
        "kids.us": true,
        "nsn.us": true,
        "com.uy": true,
        "edu.uy": true,
        "gub.uy": true,
        "mil.uy": true,
        "net.uy": true,
        "org.uy": true,
        "co.ve": true,
        "com.ve": true,
        "edu.ve": true,
        "gob.ve": true,
        "info.ve": true,
        "mil.ve": true,
        "net.ve": true,
        "org.ve": true,
        "web.ve": true,
        "co.vi": true,
        "com.vi": true,
        "k12.vi": true,
        "net.vi": true,
        "org.vi": true,
        "ac.vn": true,
        "biz.vn": true,
        "com.vn": true,
        "edu.vn": true,
        "gov.vn": true,
        "health.vn": true,
        "info.vn": true,
        "int.vn": true,
        "name.vn": true,
        "net.vn": true,
        "org.vn": true,
        "pro.vn": true,
        "co.ye": true,
        "com.ye": true,
        "gov.ye": true,
        "ltd.ye": true,
        "me.ye": true,
        "net.ye": true,
        "org.ye": true,
        "plc.ye": true,
        "ac.yu": true,
        "co.yu": true,
        "edu.yu": true,
        "gov.yu": true,
        "org.yu": true,
        "ac.za": true,
        "agric.za": true,
        "alt.za": true,
        "bourse.za": true,
        "city.za": true,
        "co.za": true,
        "cybernet.za": true,
        "db.za": true,
        "ecape.school.za": true,
        "edu.za": true,
        "fs.school.za": true,
        "gov.za": true,
        "gp.school.za": true,
        "grondar.za": true,
        "iaccess.za": true,
        "imt.za": true,
        "inca.za": true,
        "kzn.school.za": true,
        "landesign.za": true,
        "law.za": true,
        "lp.school.za": true,
        "mil.za": true,
        "mpm.school.za": true,
        "ncape.school.za": true,
        "net.za": true,
        "ngo.za": true,
        "nis.za": true,
        "nom.za": true,
        "nw.school.za": true,
        "olivetti.za": true,
        "org.za": true,
        "pix.za": true,
        "school.za": true,
        "tm.za": true,
        "wcape.school.za": true,
        "web.za": true,
        "ac.zm": true,
        "co.zm": true,
        "com.zm": true,
        "edu.zm": true,
        "gov.zm": true,
        "net.zm": true,
        "org.zm": true,
        "sch.zm": true
      };
    }
  });

  // ../node_modules/is-valid-domain/data/ccTldMap.json
  var require_ccTldMap = __commonJS({
    "../node_modules/is-valid-domain/data/ccTldMap.json"(exports, module) {
      module.exports = {
        ad: true,
        ae: true,
        af: true,
        ag: true,
        ai: true,
        al: true,
        am: true,
        ao: true,
        aq: true,
        ar: true,
        as: true,
        at: true,
        au: true,
        aw: true,
        ax: true,
        az: true,
        ba: true,
        bb: true,
        bd: true,
        be: true,
        bf: true,
        bg: true,
        bh: true,
        bi: true,
        bj: true,
        bl: true,
        bm: true,
        bn: true,
        bo: true,
        bq: true,
        br: true,
        bs: true,
        bt: true,
        bv: true,
        bw: true,
        by: true,
        bz: true,
        ca: true,
        cc: true,
        cd: true,
        cf: true,
        cg: true,
        ch: true,
        ci: true,
        ck: true,
        cl: true,
        cm: true,
        cn: true,
        co: true,
        cr: true,
        cu: true,
        cv: true,
        cw: true,
        cx: true,
        cy: true,
        cz: true,
        de: true,
        dj: true,
        dk: true,
        dm: true,
        do: true,
        dz: true,
        ec: true,
        ee: true,
        eg: true,
        er: true,
        es: true,
        et: true,
        fi: true,
        fj: true,
        fk: true,
        fm: true,
        fo: true,
        fr: true,
        ga: true,
        "gb (.uk)": true,
        gd: true,
        ge: true,
        gf: true,
        gg: true,
        gh: true,
        gi: true,
        gl: true,
        gm: true,
        gn: true,
        gp: true,
        gq: true,
        gr: true,
        gs: true,
        gt: true,
        gu: true,
        gw: true,
        gy: true,
        hk: true,
        hm: true,
        hn: true,
        hr: true,
        ht: true,
        hu: true,
        id: true,
        ie: true,
        il: true,
        im: true,
        in: true,
        io: true,
        iq: true,
        ir: true,
        is: true,
        it: true,
        je: true,
        jm: true,
        jo: true,
        jp: true,
        ke: true,
        kg: true,
        kh: true,
        ki: true,
        km: true,
        kn: true,
        kp: true,
        kr: true,
        kw: true,
        ky: true,
        kz: true,
        la: true,
        lb: true,
        lc: true,
        li: true,
        lk: true,
        lr: true,
        ls: true,
        lt: true,
        lu: true,
        lv: true,
        ly: true,
        ma: true,
        mc: true,
        md: true,
        me: true,
        mf: true,
        mg: true,
        mh: true,
        mk: true,
        ml: true,
        mm: true,
        mn: true,
        mo: true,
        mp: true,
        mq: true,
        mr: true,
        ms: true,
        mt: true,
        mu: true,
        mv: true,
        mw: true,
        mx: true,
        my: true,
        mz: true,
        na: true,
        nc: true,
        ne: true,
        nf: true,
        ng: true,
        ni: true,
        nl: true,
        no: true,
        np: true,
        nr: true,
        nu: true,
        nz: true,
        om: true,
        pa: true,
        pe: true,
        pf: true,
        pg: true,
        ph: true,
        pk: true,
        pl: true,
        pm: true,
        pn: true,
        pr: true,
        ps: true,
        pt: true,
        pw: true,
        py: true,
        qa: true,
        re: true,
        ro: true,
        rs: true,
        ru: true,
        rw: true,
        sa: true,
        sb: true,
        sc: true,
        sd: true,
        se: true,
        sg: true,
        sh: true,
        si: true,
        sj: true,
        sk: true,
        sl: true,
        sm: true,
        sn: true,
        so: true,
        sr: true,
        ss: true,
        st: true,
        sv: true,
        sx: true,
        sy: true,
        sz: true,
        tc: true,
        td: true,
        tf: true,
        tg: true,
        th: true,
        tj: true,
        tk: true,
        tl: true,
        tm: true,
        tn: true,
        to: true,
        tr: true,
        tt: true,
        tv: true,
        tw: true,
        tz: true,
        ua: true,
        ug: true,
        us: true,
        uy: true,
        uz: true,
        va: true,
        vc: true,
        ve: true,
        vg: true,
        vi: true,
        vn: true,
        vu: true,
        wf: true,
        ws: true,
        ye: true,
        yt: true,
        za: true,
        zm: true,
        zw: true
      };
    }
  });

  // ../node_modules/is-valid-domain/index.js
  var require_is_valid_domain = __commonJS({
    "../node_modules/is-valid-domain/index.js"(exports, module) {
      var punycode = require_punycode();
      var sldMap = require_sldMap();
      var ccTldMap = require_ccTldMap();
      module.exports = function isValidDomain2(value, opts) {
        if (typeof value !== "string")
          return false;
        if (!(opts instanceof Object))
          opts = {};
        value = value.toLowerCase();
        if (value.endsWith(".")) {
          value = value.slice(0, value.length - 1);
        }
        if (opts.allowUnicode) {
          value = punycode.toASCII(value);
        }
        if (value.length > 253) {
          return false;
        }
        const validChars = /^([\u0E00-\u0E7Fa-z0-9-._*]+)$/g;
        if (!validChars.test(value)) {
          return false;
        }
        if (opts.topLevel) {
          if (ccTldMap[value.replace(/\.$/, "")]) {
            return true;
          }
        }
        const sldRegex = /(.*)\.(([\u0E00-\u0E7Fa-z0-9]+)(\.[a-z0-9]+))/;
        const matches = value.match(sldRegex);
        let tld = null;
        let labels = null;
        if (matches && matches.length > 2) {
          if (sldMap[matches[2]]) {
            tld = matches[2];
            labels = matches[1].split(".");
          }
        }
        if (!labels) {
          labels = value.split(".");
          if (labels.length <= 1)
            return false;
          tld = labels.pop();
          const tldRegex = /^(?:xn--)?(?!^\d+$)[\u0E00-\u0E7Fa-z0-9]+$/gi;
          if (!tldRegex.test(tld))
            return false;
        }
        if (opts.subdomain === false && labels.length > 1)
          return false;
        const isValid2 = labels.every(function(label, index) {
          if (opts.wildcard && index === 0 && label === "*" && labels.length > 1) {
            return true;
          }
          let validLabelChars = /^([\u0E00-\u0E7Fa-zA-Z0-9-_]+)$/g;
          if (index === labels.length - 1) {
            validLabelChars = /^([\u0E00-\u0E7Fa-zA-Z0-9-]+)$/g;
          }
          const doubleDashCount = (label.match(/--(--)?/g) || []).length;
          const xnDashCount = (label.match(/xn--/g) || []).length;
          if (index === labels.length - 1 && doubleDashCount !== xnDashCount) {
            return false;
          }
          const isValid3 = validLabelChars.test(label) && label.length < 64 && !label.startsWith("-") && !label.endsWith("-");
          return isValid3;
        });
        return isValid2;
      };
    }
  });

  // ../node_modules/normalize-url/index.js
  function normalizeUrl(urlString2, options) {
    options = __spreadValues({
      defaultProtocol: "http",
      normalizeProtocol: true,
      forceHttp: false,
      forceHttps: false,
      stripAuthentication: true,
      stripHash: false,
      stripTextFragment: true,
      stripWWW: true,
      removeQueryParameters: [/^utm_\w+/i],
      removeTrailingSlash: true,
      removeSingleSlash: true,
      removeDirectoryIndex: false,
      removeExplicitPort: false,
      sortQueryParameters: true
    }, options);
    if (typeof options.defaultProtocol === "string" && !options.defaultProtocol.endsWith(":")) {
      options.defaultProtocol = `${options.defaultProtocol}:`;
    }
    urlString2 = urlString2.trim();
    if (/^data:/i.test(urlString2)) {
      return normalizeDataURL(urlString2, options);
    }
    if (hasCustomProtocol(urlString2)) {
      return urlString2;
    }
    const hasRelativeProtocol = urlString2.startsWith("//");
    const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString2);
    if (!isRelativeUrl) {
      urlString2 = urlString2.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
    }
    const urlObject = new URL(urlString2);
    if (options.forceHttp && options.forceHttps) {
      throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
    }
    if (options.forceHttp && urlObject.protocol === "https:") {
      urlObject.protocol = "http:";
    }
    if (options.forceHttps && urlObject.protocol === "http:") {
      urlObject.protocol = "https:";
    }
    if (options.stripAuthentication) {
      urlObject.username = "";
      urlObject.password = "";
    }
    if (options.stripHash) {
      urlObject.hash = "";
    } else if (options.stripTextFragment) {
      urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "");
    }
    if (urlObject.pathname) {
      const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;
      let lastIndex = 0;
      let result = "";
      for (; ; ) {
        const match = protocolRegex.exec(urlObject.pathname);
        if (!match) {
          break;
        }
        const protocol = match[0];
        const protocolAtIndex = match.index;
        const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
        result += intermediate.replace(/\/{2,}/g, "/");
        result += protocol;
        lastIndex = protocolAtIndex + protocol.length;
      }
      const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
      result += remnant.replace(/\/{2,}/g, "/");
      urlObject.pathname = result;
    }
    if (urlObject.pathname) {
      try {
        urlObject.pathname = decodeURI(urlObject.pathname);
      } catch (e2) {
      }
    }
    if (options.removeDirectoryIndex === true) {
      options.removeDirectoryIndex = [/^index\.[a-z]+$/];
    }
    if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
      let pathComponents = urlObject.pathname.split("/");
      const lastComponent = pathComponents[pathComponents.length - 1];
      if (testParameter(lastComponent, options.removeDirectoryIndex)) {
        pathComponents = pathComponents.slice(0, -1);
        urlObject.pathname = pathComponents.slice(1).join("/") + "/";
      }
    }
    if (urlObject.hostname) {
      urlObject.hostname = urlObject.hostname.replace(/\.$/, "");
      if (options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)) {
        urlObject.hostname = urlObject.hostname.replace(/^www\./, "");
      }
    }
    if (Array.isArray(options.removeQueryParameters)) {
      for (const key of [...urlObject.searchParams.keys()]) {
        if (testParameter(key, options.removeQueryParameters)) {
          urlObject.searchParams.delete(key);
        }
      }
    }
    if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {
      urlObject.search = "";
    }
    if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
      for (const key of [...urlObject.searchParams.keys()]) {
        if (!testParameter(key, options.keepQueryParameters)) {
          urlObject.searchParams.delete(key);
        }
      }
    }
    if (options.sortQueryParameters) {
      urlObject.searchParams.sort();
      try {
        urlObject.search = decodeURIComponent(urlObject.search);
      } catch (e2) {
      }
    }
    if (options.removeTrailingSlash) {
      urlObject.pathname = urlObject.pathname.replace(/\/$/, "");
    }
    if (options.removeExplicitPort && urlObject.port) {
      urlObject.port = "";
    }
    const oldUrlString = urlString2;
    urlString2 = urlObject.toString();
    if (!options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "") {
      urlString2 = urlString2.replace(/\/$/, "");
    }
    if ((options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash) {
      urlString2 = urlString2.replace(/\/$/, "");
    }
    if (hasRelativeProtocol && !options.normalizeProtocol) {
      urlString2 = urlString2.replace(/^http:\/\//, "//");
    }
    if (options.stripProtocol) {
      urlString2 = urlString2.replace(/^(?:https?:)?\/\//, "");
    }
    return urlString2;
  }
  var DATA_URL_DEFAULT_MIME_TYPE, DATA_URL_DEFAULT_CHARSET, testParameter, supportedProtocols, hasCustomProtocol, normalizeDataURL;
  var init_normalize_url = __esm({
    "../node_modules/normalize-url/index.js"() {
      DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
      DATA_URL_DEFAULT_CHARSET = "us-ascii";
      testParameter = (name, filters) => filters.some((filter3) => filter3 instanceof RegExp ? filter3.test(name) : filter3 === name);
      supportedProtocols = /* @__PURE__ */ new Set([
        "https:",
        "http:",
        "file:"
      ]);
      hasCustomProtocol = (urlString2) => {
        try {
          const { protocol } = new URL(urlString2);
          return protocol.endsWith(":") && !supportedProtocols.has(protocol);
        } catch (e2) {
          return false;
        }
      };
      normalizeDataURL = (urlString2, { stripHash }) => {
        var _a, _b;
        const match = new RegExp("^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$").exec(urlString2);
        if (!match) {
          throw new Error(`Invalid URL: ${urlString2}`);
        }
        let { type, data, hash } = match.groups;
        const mediaType = type.split(";");
        hash = stripHash ? "" : hash;
        let isBase64 = false;
        if (mediaType[mediaType.length - 1] === "base64") {
          mediaType.pop();
          isBase64 = true;
        }
        const mimeType = (_b = (_a = mediaType.shift()) == null ? void 0 : _a.toLowerCase()) != null ? _b : "";
        const attributes = mediaType.map((attribute) => {
          let [key, value = ""] = attribute.split("=").map((string) => string.trim());
          if (key === "charset") {
            value = value.toLowerCase();
            if (value === DATA_URL_DEFAULT_CHARSET) {
              return "";
            }
          }
          return `${key}${value ? `=${value}` : ""}`;
        }).filter(Boolean);
        const normalizedMediaType = [
          ...attributes
        ];
        if (isBase64) {
          normalizedMediaType.push("base64");
        }
        if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
          normalizedMediaType.unshift(mimeType);
        }
        return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
      };
    }
  });

  // ../howdju-common/lib/urls.ts
  function extractDomain(url) {
    url = url == null ? void 0 : url.trim();
    if (!url) {
      return void 0;
    }
    try {
      const urlObj = new URL(url);
      return urlObj.hostname;
    } catch (e2) {
      return void 0;
    }
  }
  function isUrl(text) {
    text = text == null ? void 0 : text.trim();
    if (!text) {
      return false;
    }
    try {
      new URL(text);
      return true;
    } catch (e2) {
      return false;
    }
  }
  function isDomain(text) {
    if (!text) {
      return false;
    }
    return (0, import_is_valid_domain.default)(text);
  }
  function removeQueryParamsAndFragment(url) {
    const i3 = url.indexOf("?");
    if (i3 > -1) {
      return url.substring(0, i3);
    }
    const j3 = url.indexOf("#");
    if (j3 > -1) {
      return url.substring(0, j3);
    }
    return url;
  }
  function normalizeUrl2(url, options) {
    const urlObj = new URL(url);
    if (!urlObj.pathname.endsWith("/")) {
      urlObj.pathname = urlObj.pathname + "/";
    }
    return normalizeUrl(
      urlObj.toString(),
      mergeCopy(
        {
          defaultProtocol: "https",
          stripWWW: false,
          removeTrailingSlash: false,
          removeSingleSlash: false
        },
        options
      )
    );
  }
  var import_is_valid_domain;
  var init_urls = __esm({
    "../howdju-common/lib/urls.ts"() {
      "use strict";
      import_is_valid_domain = __toESM(require_is_valid_domain());
      init_normalize_url();
      init_general();
    }
  });

  // ../howdju-common/lib/zodRefinements.ts
  var import_moment3, import_isURL, urlRefinement, urlString, momentObject;
  var init_zodRefinements = __esm({
    "../howdju-common/lib/zodRefinements.ts"() {
      "use strict";
      init_lib();
      import_moment3 = __toESM(require_moment());
      import_isURL = __toESM(require_isURL());
      init_urls();
      urlRefinement = (options) => (val, ctx) => {
        const { domain: domainPattern } = options != null ? options : {};
        const require_tld = false;
        if (!(0, import_isURL.default)(val, {
          protocols: ["http", "https"],
          require_protocol: true,
          require_tld
        })) {
          ctx.addIssue({
            code: mod.ZodIssueCode.custom,
            message: "Must be a valid URL",
            params: {
              val,
              require_tld
            }
          });
        }
        if (domainPattern) {
          const domain = extractDomain(val);
          if (!domain || !domainPattern.test(domain)) {
            ctx.addIssue({
              code: mod.ZodIssueCode.custom,
              message: `URL domain must match: ${domainPattern}.`,
              params: {
                val
              }
            });
          }
        }
      };
      urlString = (options) => mod.string().superRefine(urlRefinement(options != null ? options : {}));
      momentObject = mod.instanceof(
        import_moment3.default,
        {
          message: "Must be a moment timestamp."
        }
      );
    }
  });

  // ../howdju-common/lib/zodSchemas.ts
  function refineCreateMediaExcerpt(val, ctx) {
    if ((0, import_lodash6.keys)(val.localRep).length < 1) {
      ctx.addIssue({
        code: mod.ZodIssueCode.custom,
        message: `At least one of ${(0, import_lodash6.keys)(
          MediaExcerpt.shape.localRep.shape
        )} is required.`
      });
    }
    if (!val.locators && (!val.citations || val.citations.length < 1)) {
      ctx.addIssue({
        code: mod.ZodIssueCode.custom,
        message: `At least one of locators or citations is required.`
      });
    }
    if (val.locators && (0, import_lodash6.keys)(val.locators).length < 1) {
      ctx.addIssue({
        code: mod.ZodIssueCode.custom,
        message: `Locators must contain at least one of ${(0, import_lodash6.keys)(
          MediaExcerpt.shape.locators.shape
        )} is required.`
      });
    }
  }
  var import_lodash6, Entity, CreateModel, PersistedEntity, UserExternalIds, User, UserBlurb, Proposition, UpdatePropositionInput, UpdateProposition, Tag, CreateTag, CreateTagInput, tagVotePolarities, PropositionTagVote, PropositionTagVotePolarities, CreatePropositionTagVote, CreatePropositionTagVoteInput, CreatePropositionInput, CreateProposition, Persorg, CreatePersorg, CreatePersorgInput, UpdatePersorg, UpdatePersorgInput, sentenceTypes, baseStatement, Statement, SentenceTypes, CreateStatementInput, CreateStatement, Writ, CreateWrit, CreateWritInput, UpdateWrit, UpdateWritInput, DomAnchor, CreateDomAnchor, UrlTarget, Url, CreateUrl, CreateUrlInput, UrlLocator, WritQuote, PicRegion, VidSegment, AudSegment, sourceExcerptTypes, SourceExcerpt, SourceExcerptTypes, CreateUrlLocator, CreateUrlLocatorInput, Source, CreateSource, CreateSourceInput, UpdateSource, UpdateSourceInput, MediaExcerptCitation, CreateMediaExcerptCitation, CreateMediaExcerptCitationInput, DeleteMediaExcerptCitation, MediaExcerptSpeaker, CreateMediaExcerptSpeaker, CreateMediaExcerptSpeakerInput, MediaExcerpt, Appearance, CreateAppearance, CreateAppearanceInput, PropositionCompoundAtom, PropositionCompound, CreatePropositionCompoundAtomInput, UpdatePropositionCompoundAtomInput, CreatePropositionCompoundInput, CreatePropositionCompoundAtom, UpdatePropositionCompoundAtom, CreatePropositionCompound, UpdatePropositionCompoundInput, UpdatePropositionCompound, JustificationPolarity, JustificationPolarities, RelationPolarity2, JustificationRootPolarity, JustificationRootPolarities, JustificationBasisType, JustificationBasisTypes, justificationBaseShape, JustificationRootTargetType, JustificationRootTargetTypes, JustificationTargetType2, Justification, JustificationTargetTypes, PropositionRef, StatementRef, JustificationRef, JustificationVoteRef, PropositionCompoundRef, SourceExcerptRef, WritQuoteRef, WritRef, PersorgRef, TagRef, TagVoteRef, UrlRef, UserRef, PropositionTagVoteRef, RegistrationRequestRef, PasswordResetRequestRef, AccountSettingsRef, ContentReportRef, UrlLocatorRef, MediaExcerptRef, SourceRef, CreateWritQuoteInput, CreateWritQuote, UpdateWritQuoteInput, UpdateWritQuote, CreateVidSegmentInput, CreateVidSegment, CreateAudSegmentInput, CreateAudSegment, UpdateVidSegmentInput, UpdateVidSegment, CreatePicRegionInput, CreatePicRegion, UpdatePicRegionInput, UpdatePicRegion, CreateSourceExcerptInput, CreateSourceExcerpt, CreateMediaExcerptBase, CreateMediaExcerpt, CreateMediaExcerptInput, UpdateMediaExcerpt, UpdateMediaExcerptInput, CreateUrlLocatorsInput, createJustificationBaseShape, createJustificationInputBaseShape, CreateJustificationInput, CreateJustification, CreateCounterJustificationInput, CreateCounterJustification, justificationVotePolarities, JustificationVote, JustificationVotePolarities, CreateJustificationVote, DeleteJustificationVote, TaggableEntityType, TagVote, TagVotePolarities, CreateTagVote, EntityType, EntityTypes, ContentReportType, ContentReportTypes, ContentReport, CreateContentReport, CreateContentReportInput, CreateUser, AccountSettings, CreateAccountSettings, UpdateAccountSettings, CreateJustifiedSentenceInput, CreateJustifiedSentence, RegistrationRequest, CreateRegistrationRequest, CreateRegistrationRequestInput, Password, RegistrationConfirmation, CreateRegistrationConfirmation, CreateRegistrationConfirmationInput, PasswordResetRequest, Credentials;
  var init_zodSchemas = __esm({
    "../howdju-common/lib/zodSchemas.ts"() {
      "use strict";
      import_lodash6 = __toESM(require_lodash());
      init_lib();
      init_zodRefinements();
      Entity = mod.object({
        // Entities have an ID after they have been persisted.
        id: mod.string().optional()
      });
      CreateModel = mod.object({
        _isCreateModel: mod.boolean().optional()
      });
      PersistedEntity = Entity.required();
      UserExternalIds = mod.object({
        googleAnalyticsId: mod.string(),
        heapAnalyticsId: mod.string(),
        mixpanelId: mod.string(),
        sentryId: mod.string()
      });
      User = Entity.extend({
        email: mod.string().email().max(512),
        username: mod.string().regex(/[A-Za-z0-9_]+/).min(3).max(64),
        shortName: mod.string().min(1).max(32).optional(),
        longName: mod.string().min(1).max(64),
        // We currently don't request phone number
        phoneNumber: mod.string().optional(),
        created: momentObject,
        isActive: mod.boolean(),
        externalIds: UserExternalIds.optional()
      });
      UserBlurb = User.pick({
        longName: true
      }).merge(PersistedEntity);
      Proposition = Entity.extend({
        /**
         * The text of the proposition.
         *
         * Text should be a concise, neutral point of view, unambiguous, declarative independent clause.
         */
        text: mod.string().min(1),
        created: momentObject
      });
      UpdatePropositionInput = Proposition.merge(PersistedEntity).omit({
        created: true
      });
      UpdateProposition = UpdatePropositionInput;
      Tag = Entity.extend({
        name: mod.string()
      });
      CreateTag = Tag;
      CreateTagInput = CreateTag;
      tagVotePolarities = mod.enum(["POSITIVE", "NEGATIVE"]);
      PropositionTagVote = mod.lazy(
        () => Entity.extend({
          proposition: mod.union([Proposition, PropositionRef]),
          polarity: tagVotePolarities,
          tag: Tag
        })
      );
      PropositionTagVotePolarities = tagVotePolarities.Enum;
      CreatePropositionTagVote = mod.lazy(
        () => Entity.extend({
          proposition: mod.union([PropositionRef, CreateProposition]),
          polarity: tagVotePolarities,
          tag: mod.union([TagRef, CreateTag])
        })
      );
      CreatePropositionTagVoteInput = mod.lazy(
        () => Entity.extend({
          proposition: mod.union([CreatePropositionInput, PropositionRef]),
          polarity: tagVotePolarities,
          tag: mod.union([TagRef, CreateTagInput])
        })
      );
      CreatePropositionInput = Proposition.omit({
        created: true
      }).extend({
        tags: mod.array(CreateTagInput).optional(),
        propositionTagVotes: mod.array(CreatePropositionTagVoteInput).optional()
      });
      CreateProposition = CreatePropositionInput.extend({
        tags: mod.array(CreateTag).optional(),
        propositionTagVotes: mod.array(CreatePropositionTagVote).optional()
      });
      Persorg = Entity.extend({
        isOrganization: mod.boolean(),
        /** The person or organization's official or most well-known name. */
        name: mod.string().min(1),
        /**
         * Why the person or organization is noteworthy.
         *
         * This field can help disambiguate persons with identical or similar names, or provide context on
         * the speaker's statements.
         *
         * Persorgs should respect privacy, and so generally the system should maintain only noteworthy
         * statements. A statement can be noteworthy because the person making it is generally noteworthy,
         * or because in the context it was made, it is noteworthy.
         */
        knownFor: mod.string().optional(),
        /** The official or primary website representing the persorg. */
        websiteUrl: urlString().optional(),
        /** The persorg's Twitter. */
        twitterUrl: urlString({ domain: /twitter.com$/ }).optional(),
        /** The persorg's Wikipedia URL. */
        wikipediaUrl: urlString({ domain: /wikipedia.org$/ }).optional(),
        created: momentObject,
        creatorUserId: mod.string()
      });
      CreatePersorg = Persorg.omit({
        id: true,
        created: true,
        creatorUserId: true,
        creator: true
      });
      CreatePersorgInput = CreatePersorg;
      UpdatePersorg = Persorg.merge(PersistedEntity).omit({
        created: true,
        creatorUserId: true,
        creator: true
      });
      UpdatePersorgInput = UpdatePersorg;
      sentenceTypes = mod.enum(["PROPOSITION", "STATEMENT"]);
      baseStatement = {
        speaker: Persorg,
        created: momentObject
      };
      Statement = mod.lazy(
        () => mod.discriminatedUnion("sentenceType", [
          Entity.extend(__spreadValues({
            sentenceType: mod.literal(sentenceTypes.Enum.PROPOSITION),
            sentence: Proposition
          }, baseStatement)),
          Entity.extend(__spreadValues({
            sentenceType: mod.literal(sentenceTypes.Enum.STATEMENT),
            sentence: Statement
          }, baseStatement))
        ])
      );
      SentenceTypes = sentenceTypes.Enum;
      CreateStatementInput = mod.lazy(
        () => mod.discriminatedUnion("sentenceType", [
          Entity.extend({
            sentenceType: mod.literal(sentenceTypes.Enum.PROPOSITION),
            sentence: CreatePropositionInput,
            speaker: Persorg
          }),
          Entity.extend({
            sentenceType: mod.literal(sentenceTypes.Enum.STATEMENT),
            sentence: CreateStatementInput,
            speaker: Persorg
          })
        ])
      );
      CreateStatement = mod.lazy(
        () => mod.discriminatedUnion("sentenceType", [
          Entity.extend({
            sentenceType: mod.literal(sentenceTypes.Enum.PROPOSITION),
            sentence: CreateProposition,
            speaker: CreatePersorg
          }),
          Entity.extend({
            sentenceType: mod.literal(sentenceTypes.Enum.STATEMENT),
            sentence: CreateStatement,
            speaker: CreatePersorg
          })
        ])
      );
      Writ = Entity.extend({
        title: mod.string().min(1).max(512),
        created: momentObject
      });
      CreateWrit = Writ.omit({
        created: true
      });
      CreateWritInput = CreateWrit;
      UpdateWrit = Writ;
      UpdateWritInput = UpdateWrit;
      DomAnchor = mod.object({
        /**
         * The text this anchor targets
         *
         * See dom-anchor-text-quote.
         */
        exactText: mod.string(),
        /**
         * The text appearing before the exactText
         *
         * See dom-anchor-text-quote.
         */
        prefixText: mod.string(),
        /**
         * The text appearing after the exactText
         *
         * See dom-anchor-text-quote.
         */
        suffixText: mod.string(),
        /**
         * The character offset of the beginning of exactText in the DOM
         *
         * See dom-anchor-text-position.
         */
        startOffset: mod.number(),
        /**
         * The character offset of the end of exactText in the DOM
         *
         * See dom-anchor-text-position.
         */
        endOffset: mod.number(),
        urlLocatorId: mod.string(),
        created: momentObject,
        creatorUserId: mod.string()
      });
      CreateDomAnchor = DomAnchor.omit({
        created: true,
        creatorUserId: true,
        urlLocatorId: true
      });
      UrlTarget = Entity.extend({
        anchors: mod.array(DomAnchor)
      });
      Url = Entity.extend({
        url: urlString(),
        /** If the user provides the canonical URL, we will confirm it. */
        canonicalUrl: urlString().optional(),
        /** @deprecated TODO(38) replace with UrlLocator.anchors */
        target: UrlTarget.optional()
      });
      CreateUrl = Url.omit({
        target: true
      });
      CreateUrlInput = CreateUrl;
      UrlLocator = Entity.extend({
        mediaExcerptId: mod.string(),
        url: Url,
        // If we have inferred a text fragment URL for the UrlLocator based on its MediaExcerpt's localRep.
        textFragmentUrl: urlString().optional(),
        anchors: mod.array(DomAnchor).optional(),
        created: momentObject,
        creatorUserId: mod.string(),
        creator: UserBlurb
      });
      WritQuote = Entity.extend({
        quoteText: mod.string().min(1).max(4096),
        writ: Writ,
        urls: mod.array(Url),
        created: momentObject
      });
      PicRegion = Entity;
      VidSegment = Entity;
      AudSegment = Entity;
      sourceExcerptTypes = mod.enum(["WRIT_QUOTE", "PIC_REGION", "VID_SEGMENT"]);
      SourceExcerpt = mod.discriminatedUnion("type", [
        Entity.extend({
          type: mod.literal(sourceExcerptTypes.Enum.WRIT_QUOTE),
          entity: WritQuote
        }),
        Entity.extend({
          type: mod.literal(sourceExcerptTypes.Enum.PIC_REGION),
          entity: PicRegion
        }),
        Entity.extend({
          type: mod.literal(sourceExcerptTypes.Enum.VID_SEGMENT),
          entity: VidSegment
        })
      ]);
      SourceExcerptTypes = sourceExcerptTypes.Enum;
      CreateUrlLocator = UrlLocator.omit({
        id: true,
        mediaExcerptId: true,
        created: true,
        creatorUserId: true,
        creator: true
      }).extend({
        url: CreateUrl,
        anchors: mod.array(CreateDomAnchor).optional()
      });
      CreateUrlLocatorInput = CreateUrlLocator;
      Source = Entity.extend({
        /**
         * A description of the source.
         *
         * The preferred style is MLA-like, but omitting the Authors:
         *
         * - The title of the source comes first and should be in quotes unless it is the only field.
         * - The date format should be ISO 8601 (YYYY-MM-DD) unless:
         *   - the source frequently omits the month and year, such as in academic journals, in which
         *     case the year is sufficient.
         *   - the source is updated frequently, in which case including the time is recommended.
         *
         * Because we can't guarantee that users will follow this style, we will later need a means
         * to vote on preferred manifestations of Sources.
         *
         * Examples:
         *
         * - “Russia Accuses Prigozhin of Trying to Mount a Coup: Live Updates” The New York Times (2023-06-23)
         * - “Comparison of Blood and Brain Mercury Levels in Infant Monkeys Exposed to Methylmercury or Vaccines Containing Thimerosal” Environmental Health Perspectives vol. 113,8 (2005): 1015. doi:10.1289/ehp.7712
         */
        description: mod.string().min(1).max(1024),
        normalDescription: mod.string().max(1024),
        created: momentObject,
        deleted: momentObject.optional(),
        creatorUserId: mod.string(),
        creator: UserBlurb
      });
      CreateSource = Source.omit({
        normalDescription: true,
        created: true,
        deleted: true,
        creator: true,
        creatorUserId: true
      });
      CreateSourceInput = CreateSource;
      UpdateSource = CreateSource.extend({
        id: mod.string()
      });
      UpdateSourceInput = UpdateSource;
      MediaExcerptCitation = mod.object({
        mediaExcerptId: mod.string(),
        source: Source,
        pincite: mod.string().min(1).max(64).optional(),
        normalPincite: mod.string().min(1).max(64).optional(),
        created: momentObject,
        creatorUserId: mod.string()
      });
      CreateMediaExcerptCitation = MediaExcerptCitation.extend({
        source: CreateSource
      }).omit({
        // A CreateMediaExcerptCitation must be associated with a CreateMediaExcerpt, the ID of which
        // will be substituted for the mediaExcerptId.
        mediaExcerptId: true,
        normalPincite: true,
        created: true,
        creatorUserId: true
      });
      CreateMediaExcerptCitationInput = CreateMediaExcerptCitation.extend({
        source: CreateSourceInput,
        // An empty pincite translates to null upon creation.
        pincite: mod.string().max(64).optional()
      });
      DeleteMediaExcerptCitation = mod.object({
        mediaExcerptId: mod.string(),
        source: mod.object({
          id: mod.string()
        }),
        normalPincite: mod.string().optional()
      });
      MediaExcerptSpeaker = mod.object({
        mediaExcerptId: mod.string(),
        persorg: Persorg,
        created: momentObject,
        creatorUserId: mod.string()
      });
      CreateMediaExcerptSpeaker = MediaExcerptSpeaker.extend({
        persorg: CreatePersorg
      }).omit({
        // A CreateMediaExcerptSpeaker must be associated with a CreateMediaExcerpt, the ID of which
        // will be substituted for the mediaExcerptId.
        mediaExcerptId: true,
        created: true,
        creatorUserId: true
      });
      CreateMediaExcerptSpeakerInput = CreateMediaExcerptSpeaker;
      MediaExcerpt = Entity.extend({
        /**
         * One or more local representations of the excerpt.
         *
         * If there is more than one representation, they must all represent the same
         * part of the source and the same speech. (What do we do if they don't?)
         *
         * Potential additional fields:
         *
         * Text-based:
         *  - focusText: a part of quotation that is the substance of the excerpt, while the rest of
         *    quotation provides additional context. The focusText must appear within the quotation.
         *  - contextText: text that encompasses the focusText to provie additional context, but which
         *    does not convey the substance of the excerpt.
         *  - description: a textual description of non-textual content. Like an img alt text. (How do
         *    users provite signal for an inaccurate description? The more literal the localRep, the less
         *    possibility for interpretation.)
         *  - transcription: text that appears in an image or as speech in audio/video. (Should we just
         *    reuse quotation for this?)
         * Image-based:
         *  - screenshot: a screenshot of the text in situ.
         *  - copied low-res image with optional highlighted focused region
         *  - copied image cropped to focused region
         *  - embedded picture with optional focused region
         * Video-based:
         *  - copied low-res video cropped to focused segment
         *  - embedded video (with offset if possible)
         * Audio-based:
         *  - embedded audio (with offset if possible)
         */
        localRep: mod.object({
          /**
           * Text or speech that literally appears in the media and conveys the substance of the speech.
           *
           * Users may use this field either for focusText or for contextText (as described above.) It's
           * an open question how we would migrate this field to a focusText/contextText split if we
           * decided to do that.
           *
           * For textual media, this text must appear in the media. For audio and video media, this
           * text must be a transcription of the speech that appears in the media.
           */
          quotation: mod.string().min(1).max(4096),
          normalQuotation: mod.string().min(1).max(4096)
        }),
        /**
         * Provides a procedure for locating the local representation in situ remotely.
         *
         * Currently only urlLocators, but possibly in the future: ThirdPartyContentId
         * (YouTube Video ID, Tweet ID, Facebook Post ID.), scripted web browser actions
         * (e.g. navigate to URL, click on expander, highlight DomAnchor to reveal excerpt.)
         */
        locators: mod.object({
          /** A way to locate a source excerpt at a part of a URL resource. */
          urlLocators: mod.array(UrlLocator)
        }),
        /**
         * Sources users have identified as represented (at least in part) by the source excerpt.
         *
         * The locators may point to online copies or excerpts of other sources, such as books or journal
         * articles, such as when a news article quotes a journal article or a blog post quotes a book.
         * The source field allows associating that source with the in situ appearance of the
         * mediaExcerpt at the locators.
         */
        citations: mod.array(MediaExcerptCitation),
        /** Persorgs to whom users have attributed the speech in the source excerpt. */
        speakers: mod.array(MediaExcerptSpeaker),
        created: momentObject,
        creatorUserId: mod.string(),
        creator: UserBlurb
      });
      Appearance = Entity.extend({
        /**
         * Where the entity appears.
         */
        mediaExcerpt: MediaExcerpt,
        /**
         * The entity that appears at the MediaExcerpt.
         *
         * We can make this a discriminatedUnion on type to support additional appearing entities.
         */
        apparition: mod.object({
          type: mod.literal("PROPOSITION"),
          entity: Proposition
        })
      });
      CreateAppearance = mod.object({
        mediaExcerptId: mod.string(),
        apparition: mod.object({
          type: mod.literal("PROPOSITION"),
          entity: CreateProposition
        })
      });
      CreateAppearanceInput = mod.object({
        mediaExcerptId: mod.string(),
        apparition: mod.object({
          type: mod.literal("PROPOSITION"),
          entity: CreatePropositionInput
        })
      });
      PropositionCompoundAtom = mod.object({
        /**
         * A reference to this atom's parent compound.
         *
         * TODO(440) do we need this?
         */
        propositionCompoundId: mod.string(),
        entity: Proposition
      });
      PropositionCompound = Entity.extend({
        atoms: mod.array(PropositionCompoundAtom).min(1),
        created: momentObject.optional(),
        creatorUserId: mod.string().optional()
      });
      CreatePropositionCompoundAtomInput = mod.object({
        entity: CreatePropositionInput
      });
      UpdatePropositionCompoundAtomInput = mod.object({
        entity: UpdatePropositionInput
      });
      CreatePropositionCompoundInput = Entity.extend({
        atoms: mod.array(CreatePropositionCompoundAtomInput).min(1)
      });
      CreatePropositionCompoundAtom = mod.object({
        entity: CreateProposition
      });
      UpdatePropositionCompoundAtom = mod.object({
        entity: UpdateProposition
      });
      CreatePropositionCompound = Entity.extend({
        atoms: mod.array(CreatePropositionCompoundAtom).min(1)
      });
      UpdatePropositionCompoundInput = Entity.extend({
        atoms: mod.array(UpdatePropositionCompoundAtomInput).min(1)
      });
      UpdatePropositionCompound = Entity.extend({
        atoms: mod.array(UpdatePropositionCompoundAtom).min(1)
      });
      JustificationPolarity = mod.enum(["POSITIVE", "NEGATIVE"]);
      JustificationPolarities = JustificationPolarity.Enum;
      RelationPolarity2 = mod.enum(["POSITIVE", "NEGATIVE", "NEUTRAL"]);
      JustificationRootPolarity = mod.enum(["POSITIVE", "NEGATIVE"]);
      JustificationRootPolarities = JustificationRootPolarity.Enum;
      JustificationBasisType = mod.enum([
        "PROPOSITION_COMPOUND",
        "MEDIA_EXCERPT",
        "SOURCE_EXCERPT",
        /** @deprecated */
        "WRIT_QUOTE",
        /**
         * A mixture of Propositions and WritQuotes.
         *
         * @deprecated We decided not to mix 'claims' (Propositions) and 'evidence' (SourceExcerpts).
         * Instead, a justification must be a PropositionCompound or a SourceExcerpt.
         */
        "JUSTIFICATION_BASIS_COMPOUND"
      ]);
      JustificationBasisTypes = JustificationBasisType.Enum;
      justificationBaseShape = {
        polarity: JustificationPolarity,
        basis: mod.discriminatedUnion("type", [
          mod.object({
            type: mod.literal(JustificationBasisTypes.PROPOSITION_COMPOUND),
            entity: PropositionCompound
          }),
          mod.object({
            type: mod.literal("MEDIA_EXCERPT"),
            entity: MediaExcerpt
          }),
          mod.object({
            type: mod.literal(JustificationBasisTypes.SOURCE_EXCERPT),
            entity: SourceExcerpt
          })
        ]),
        rootPolarity: JustificationRootPolarity,
        created: momentObject
      };
      JustificationRootTargetType = mod.enum(["PROPOSITION", "STATEMENT"]);
      JustificationRootTargetTypes = JustificationRootTargetType.Enum;
      JustificationTargetType2 = mod.enum([
        "PROPOSITION",
        "STATEMENT",
        "JUSTIFICATION"
      ]);
      Justification = mod.lazy(
        () => mod.discriminatedUnion("rootTargetType", [
          Entity.extend(__spreadProps(__spreadValues({}, justificationBaseShape), {
            rootTargetType: mod.literal(JustificationRootTargetTypes.PROPOSITION),
            rootTarget: Proposition,
            target: mod.discriminatedUnion("type", [
              mod.object({
                type: mod.literal(JustificationTargetType2.Enum.PROPOSITION),
                entity: Proposition
              }),
              mod.object({
                type: mod.literal(JustificationTargetType2.Enum.STATEMENT),
                entity: Statement
              }),
              mod.object({
                type: mod.literal(JustificationTargetType2.Enum.JUSTIFICATION),
                entity: Justification
              })
            ])
          })),
          Entity.extend(__spreadProps(__spreadValues({}, justificationBaseShape), {
            rootTargetType: mod.literal(JustificationRootTargetTypes.STATEMENT),
            rootTarget: Statement,
            target: mod.discriminatedUnion("type", [
              mod.object({
                type: mod.literal(JustificationTargetType2.Enum.PROPOSITION),
                entity: Proposition
              }),
              mod.object({
                type: mod.literal(JustificationTargetType2.Enum.STATEMENT),
                entity: Statement
              }),
              mod.object({
                type: mod.literal(JustificationTargetType2.Enum.JUSTIFICATION),
                entity: Justification
              })
            ])
          }))
        ])
      );
      JustificationTargetTypes = JustificationTargetType2.Enum;
      PropositionRef = Entity.required().brand();
      StatementRef = Entity.required().brand();
      JustificationRef = Entity.required().brand();
      JustificationVoteRef = Entity.required().brand();
      PropositionCompoundRef = Entity.required().brand();
      SourceExcerptRef = Entity.required().brand();
      WritQuoteRef = Entity.required().brand();
      WritRef = Entity.required().brand();
      PersorgRef = Entity.required().brand();
      TagRef = Entity.required().brand();
      TagVoteRef = Entity.required().brand();
      UrlRef = Entity.required().brand();
      UserRef = Entity.required().brand();
      PropositionTagVoteRef = Entity.required().brand();
      RegistrationRequestRef = Entity.required().brand();
      PasswordResetRequestRef = Entity.required().brand();
      AccountSettingsRef = Entity.required().brand();
      ContentReportRef = Entity.required().brand();
      UrlLocatorRef = Entity.required().brand();
      MediaExcerptRef = Entity.required().brand();
      SourceRef = Entity.required().brand();
      CreateWritQuoteInput = Entity.extend({
        quoteText: WritQuote.shape.quoteText,
        writ: CreateWritInput,
        urls: mod.array(CreateUrlInput)
      });
      CreateWritQuote = CreateWritQuoteInput;
      UpdateWritQuoteInput = WritQuote;
      UpdateWritQuote = WritQuote.merge(PersistedEntity);
      CreateVidSegmentInput = VidSegment;
      CreateVidSegment = VidSegment;
      CreateAudSegmentInput = AudSegment;
      CreateAudSegment = AudSegment;
      UpdateVidSegmentInput = VidSegment;
      UpdateVidSegment = VidSegment;
      CreatePicRegionInput = PicRegion;
      CreatePicRegion = PicRegion;
      UpdatePicRegionInput = PicRegion;
      UpdatePicRegion = PicRegion;
      CreateSourceExcerptInput = Entity.extend({
        type: mod.enum(["WRIT_QUOTE", "PIC_REGION", "VID_SEGMENT"]),
        writQuote: CreateWritQuoteInput,
        picRegion: CreatePicRegionInput,
        vidSegment: CreateVidSegmentInput
      });
      CreateSourceExcerpt = mod.discriminatedUnion("type", [
        Entity.extend({
          type: mod.literal("WRIT_QUOTE"),
          entity: CreateWritQuote
        }),
        Entity.extend({
          type: mod.literal("PIC_REGION"),
          entity: CreatePicRegion
        }),
        Entity.extend({
          type: mod.literal("VID_SEGMENT"),
          entity: CreateVidSegment
        })
      ]);
      CreateMediaExcerptBase = MediaExcerpt.omit({
        id: true,
        created: true,
        creatorUserId: true,
        creator: true
      }).merge(CreateModel).extend({
        localRep: MediaExcerpt.shape.localRep.omit({ normalQuotation: true }),
        locators: mod.object({
          // urlLocators can become optional if we add other locator types.
          urlLocators: mod.array(CreateUrlLocator)
        }).optional(),
        citations: mod.array(CreateMediaExcerptCitation).optional(),
        speakers: mod.array(CreateMediaExcerptSpeaker).optional()
      });
      CreateMediaExcerpt = CreateMediaExcerptBase.superRefine(
        refineCreateMediaExcerpt
      );
      CreateMediaExcerptInput = CreateMediaExcerptBase.extend({
        citations: mod.array(CreateMediaExcerptCitationInput).optional()
      }).superRefine(refineCreateMediaExcerpt);
      UpdateMediaExcerpt = CreateMediaExcerpt;
      UpdateMediaExcerptInput = UpdateMediaExcerpt;
      CreateUrlLocatorsInput = mod.object({
        mediaExcerptId: mod.string(),
        urlLocators: mod.array(CreateUrlLocator)
      });
      createJustificationBaseShape = __spreadProps(__spreadValues({}, (0, import_lodash6.omit)(justificationBaseShape, ["created"])), {
        basis: mod.object({
          type: mod.enum([
            "PROPOSITION_COMPOUND",
            "MEDIA_EXCERPT",
            "SOURCE_EXCERPT",
            "WRIT_QUOTE"
          ]),
          propositionCompound: mod.union([
            CreatePropositionCompound,
            PropositionCompoundRef
          ]),
          mediaExcerpt: MediaExcerptRef.optional(),
          sourceExcerpt: mod.union([CreateSourceExcerpt, SourceExcerptRef]),
          writQuote: mod.union([CreateWritQuote, WritQuoteRef]),
          justificationBasisCompound: Entity.optional()
        })
      });
      createJustificationInputBaseShape = __spreadProps(__spreadValues({}, (0, import_lodash6.omit)(createJustificationBaseShape, ["basis"])), {
        basis: mod.object({
          type: mod.enum([
            "PROPOSITION_COMPOUND",
            "MEDIA_EXCERPT",
            "SOURCE_EXCERPT",
            "WRIT_QUOTE"
          ]),
          propositionCompound: mod.union([
            CreatePropositionCompoundInput,
            PropositionCompoundRef
          ]),
          mediaExcerpt: MediaExcerptRef,
          sourceExcerpt: mod.union([CreateSourceExcerptInput, SourceExcerptRef]),
          writQuote: mod.union([CreateWritQuoteInput, WritQuoteRef]),
          justificationBasisCompound: Entity.optional()
        })
      });
      CreateJustificationInput = mod.lazy(
        () => Entity.extend(__spreadProps(__spreadValues({}, createJustificationInputBaseShape), {
          target: mod.object({
            type: mod.enum(["PROPOSITION", "STATEMENT", "JUSTIFICATION"]),
            proposition: mod.union([CreatePropositionInput, PropositionRef]),
            statement: mod.union([CreateStatementInput, StatementRef]),
            justification: mod.union([CreateJustificationInput, JustificationRef]).optional()
          }),
          // TODO(151) move rootTargetType onto rootTarget to make it an encapsulated discriminated union.
          // that way we gain type safety but don't need alternative definitions of CreateJustification like
          // for Justification above.
          rootTargetType: mod.enum(["PROPOSITION", "STATEMENT"]),
          rootTarget: mod.union([
            Proposition,
            PropositionRef,
            Statement,
            StatementRef
          ])
        }))
      );
      CreateJustification = mod.lazy(
        () => Entity.extend(__spreadProps(__spreadValues({}, (0, import_lodash6.omit)(createJustificationBaseShape, ["rootPolarity"])), {
          basis: mod.discriminatedUnion("type", [
            mod.object({
              type: mod.literal("PROPOSITION_COMPOUND"),
              entity: mod.union([CreatePropositionCompound, PropositionCompoundRef])
            }),
            mod.object({
              type: mod.literal("MEDIA_EXCERPT"),
              entity: mod.union([CreateMediaExcerpt, MediaExcerptRef])
            }),
            mod.object({
              type: mod.literal("SOURCE_EXCERPT"),
              entity: mod.union([CreateSourceExcerpt, SourceExcerptRef])
            }),
            mod.object({
              type: mod.literal("WRIT_QUOTE"),
              entity: mod.union([CreateWritQuote, WritQuoteRef])
            })
          ]),
          target: mod.discriminatedUnion("type", [
            mod.object({
              type: mod.literal("PROPOSITION"),
              entity: mod.union([CreateProposition, PropositionRef])
            }),
            mod.object({
              type: mod.literal("STATEMENT"),
              entity: mod.union([CreateStatement, StatementRef])
            }),
            mod.object({
              type: mod.literal("JUSTIFICATION"),
              entity: mod.union([CreateJustification, JustificationRef])
            })
          ])
        }))
      );
      CreateCounterJustificationInput = Entity.extend(__spreadProps(__spreadValues({}, createJustificationInputBaseShape), {
        polarity: mod.literal("NEGATIVE"),
        basis: mod.object({
          type: mod.literal("PROPOSITION_COMPOUND"),
          propositionCompound: mod.union([
            CreatePropositionCompoundInput,
            PropositionCompoundRef
          ])
        }),
        target: mod.object({
          type: mod.literal("JUSTIFICATION"),
          justification: mod.union([CreateJustificationInput, JustificationRef])
        })
      }));
      CreateCounterJustification = CreateCounterJustificationInput.extend({
        basis: mod.object({
          type: mod.literal("PROPOSITION_COMPOUND"),
          entity: mod.union([CreatePropositionCompound, PropositionCompoundRef])
        }),
        target: mod.object({
          type: mod.literal("JUSTIFICATION"),
          entity: mod.union([CreateJustification, JustificationRef])
        })
      });
      justificationVotePolarities = mod.enum(["POSITIVE", "NEGATIVE"]);
      JustificationVote = Entity.extend({
        polarity: justificationVotePolarities,
        // TODO(256): replace justificationId with justification.id.
        justificationId: mod.string(),
        justification: JustificationRef
      });
      JustificationVotePolarities = justificationVotePolarities.Enum;
      CreateJustificationVote = JustificationVote.omit({
        justification: true
      });
      DeleteJustificationVote = CreateJustificationVote;
      TaggableEntityType = mod.enum(["PROPOSITION", "STATEMENT"]);
      TagVote = Entity.extend({
        target: Entity,
        targetType: TaggableEntityType,
        polarity: tagVotePolarities,
        tag: Tag
      });
      TagVotePolarities = tagVotePolarities.Enum;
      CreateTagVote = TagVote.extend({
        tag: mod.union([TagRef, CreateTag])
      });
      EntityType = mod.enum([
        "APPEARANCE",
        "JUSTIFICATION",
        "JUSTIFICATION_VOTE",
        "MEDIA_EXCERPT",
        "PASSWORD_HASH",
        "PASSWORD_RESET_REQUEST",
        "PERSORG",
        "PROPOSITION",
        "PROPOSITION_TAG_VOTE",
        "REGISTRATION_REQUEST",
        "SOURCE",
        "STATEMENT",
        "TAG_VOTE",
        "URL",
        "URL_LOCATOR",
        "USER",
        "WRIT",
        "WRIT_QUOTE"
      ]);
      EntityTypes = EntityType.Enum;
      ContentReportType = mod.enum([
        "HARASSMENT",
        "THREATENING_VIOLENCE",
        "HATEFUL",
        "OBSCENE",
        "SEXUALIZATION_OF_MINORS",
        "SHARING_PRIVATE_PERSONAL_INFORMATION",
        "PORNOGRAPHY",
        "ILLEGAL_ACTIVITY",
        "IMPERSONATION",
        "COPYRIGHT_VIOLATION",
        "TRADEMARK_VIOLATION",
        "SPAM",
        "OTHER"
      ]);
      ContentReportTypes = ContentReportType.Enum;
      ContentReport = Entity.extend({
        entityType: EntityType,
        entityId: mod.string(),
        // When creating or reading a content report, we only need to keep the unique types.
        types: mod.array(ContentReportType),
        description: mod.string(),
        url: urlString(),
        reporterUserId: mod.string(),
        created: momentObject
      });
      CreateContentReport = ContentReport.omit({
        reporterUserId: true,
        created: true
      });
      CreateContentReportInput = ContentReport.extend({
        // When creating a content report, we maintain a map of whether any particular type is selected.
        checkedByType: mod.map(ContentReportType, mod.boolean())
      });
      CreateUser = User.omit({
        created: true,
        externalIds: true
      }).extend({
        doesAcceptTerms: mod.literal(true, {
          required_error: "Must accept the terms.",
          invalid_type_error: "Must accept the terms."
        }),
        is13YearsOrOlder: mod.literal(true, {
          required_error: "Must be 13 years or older.",
          invalid_type_error: "Must be 13 years or older."
        }),
        hasMajorityConsent: mod.literal(true, {
          required_error: "Must have adult consent.",
          invalid_type_error: "Must have adult consent."
        }),
        isNotGdpr: mod.literal(true, {
          required_error: "Must not be subject to the GDPR.",
          invalid_type_error: "Must not be subject to the GDPR."
        })
      });
      AccountSettings = Entity.extend({
        paidContributionsDisclosure: mod.string().max(4096)
      });
      CreateAccountSettings = AccountSettings;
      UpdateAccountSettings = AccountSettings;
      CreateJustifiedSentenceInput = mod.object({
        proposition: CreatePropositionInput,
        speakers: mod.array(CreatePersorgInput),
        doCreateJustification: mod.boolean(),
        justification: CreateJustificationInput
      });
      CreateJustifiedSentence = mod.object({
        proposition: CreateProposition,
        speakers: mod.array(CreatePersorg),
        doCreateJustification: mod.boolean(),
        justification: CreateJustification
      });
      RegistrationRequest = Entity.extend({
        email: User.shape.email,
        registrationCode: mod.string(),
        isConsumed: mod.boolean(),
        expires: momentObject,
        created: momentObject
      });
      CreateRegistrationRequest = RegistrationRequest.pick({
        email: true
      });
      CreateRegistrationRequestInput = CreateRegistrationRequest;
      Password = mod.string().min(6).max(64);
      RegistrationConfirmation = mod.object({
        registrationCode: mod.string().min(1).max(256),
        phoneNumber: User.shape.phoneNumber,
        username: User.shape.username,
        shortName: User.shape.shortName,
        longName: User.shape.longName,
        password: Password,
        doesAcceptTerms: CreateUser.shape.doesAcceptTerms,
        is13YearsOrOlder: CreateUser.shape.is13YearsOrOlder,
        hasMajorityConsent: CreateUser.shape.hasMajorityConsent,
        isNotGdpr: CreateUser.shape.isNotGdpr
      });
      CreateRegistrationConfirmation = RegistrationConfirmation;
      CreateRegistrationConfirmationInput = RegistrationConfirmation;
      PasswordResetRequest = Entity.extend({
        userId: mod.string(),
        email: User.shape.email,
        passwordResetCode: mod.string(),
        expires: momentObject,
        isConsumed: mod.boolean(),
        created: momentObject
      });
      Credentials = mod.object({
        email: User.shape.email,
        password: Password
      });
    }
  });

  // ../howdju-common/lib/schemas.ts
  var import_lodash8, schemaSettings, definitionsSchema, passwordResetRequest, passwordResetConfirmation, user, contentReport, writ, writQuote, persorg, schemas, schemasById;
  var init_schemas = __esm({
    "../howdju-common/lib/schemas.ts"() {
      "use strict";
      import_lodash8 = __toESM(require_lodash());
      init_zodSchemas();
      schemaSettings = {
        propositionTextMaxLength: 512,
        tagNameMaxLength: 64,
        writQuoteQuoteTextMaxLength: 4096,
        writTitleMaxLength: 512,
        persorgNameMaxLength: 2048,
        persorgKnownForMaxLength: 4096,
        urlMaxLength: 8096,
        userEmailMaxLength: 128,
        usernameMinLength: 2,
        usernameMaxLength: 64,
        longNameMaxLength: 64,
        shortNameMaxLength: 32,
        passwordMinLength: 6,
        passwordMaxLength: 64,
        reportContentDescriptionMaxLength: 4096
      };
      definitionsSchema = {
        $id: "https://howdju.com/schemas/definitions.json",
        $schema: "http://json-schema.org/draft-07/schema#",
        title: "Definitions",
        description: "Contains re-usable definitions for other schemas",
        definitions: {
          username: {
            type: "string",
            pattern: "^[A-Za-z0-9_]+$",
            description: "The user-selected identifier by which the user is publicly known in the system.  Letters, numbers, and underscore.",
            minLength: schemaSettings.usernameMinLength,
            maxLength: schemaSettings.usernameMaxLength
          },
          password: {
            type: "string",
            description: "The user's selected password",
            minLength: schemaSettings.passwordMinLength,
            maxLength: schemaSettings.passwordMaxLength
          },
          userEmail: {
            type: "string",
            format: "email",
            description: "The user's preferred email for receiving correspondence about the system",
            maxLength: schemaSettings.userEmailMaxLength
          },
          shortName: {
            type: "string",
            description: "The user's preferred first name or common name",
            examples: ["Carl", "Rich", "Anu"],
            maxLength: schemaSettings.shortNameMaxLength
          },
          longName: {
            type: "string",
            description: "The user's actual full legal name",
            examples: ["Carl Gieringer", "Anuradha Sathya"],
            minLength: 1,
            maxLength: schemaSettings.longNameMaxLength
          },
          entityId: {
            type: "string",
            format: "int32",
            description: "An identifier for an entity. Usually used in the database to identify the entity. A positive integer formatted as a string.",
            examples: ["1", "2", "42"]
          }
        }
      };
      passwordResetRequest = {
        $id: "https://howdju.com/schemas/password-reset-request.schema.json",
        $schema: "http://json-schema.org/draft-07/schema#",
        title: "PasswordResetRequest",
        description: "A request to reset a password",
        type: "object",
        required: ["email"],
        properties: {
          email: { $ref: "definitions.json#/definitions/userEmail" }
        }
      };
      passwordResetConfirmation = {
        $id: "https://howdju.com/schemas/password-reset-confirmation.schema.json",
        $schema: "http://json-schema.org/draft-07/schema#",
        title: "PasswordResetConfirmation",
        description: "A confirmation to reset a password",
        type: "object",
        required: ["newPassword"],
        properties: {
          newPassword: { $ref: "definitions.json#/definitions/password" }
        }
      };
      user = {
        $id: "https://howdju.com/schemas/user.schema.json",
        $schema: "http://json-schema.org/draft-07/schema#",
        title: "User",
        description: "A user of the system",
        type: "object",
        required: [
          "email",
          "username",
          "longName",
          "acceptedTerms",
          "affirmedMajorityConsent",
          "affirmed13YearsOrOlder",
          "affirmedNotGdpr"
        ],
        properties: {
          username: { $ref: "definitions.json#/definitions/username" },
          email: { $ref: "definitions.json#/definitions/userEmail" },
          shortName: { $ref: "definitions.json#/definitions/shortName" },
          longName: { $ref: "definitions.json#/definitions/longName" },
          acceptedTerms: {
            description: "The time when the user accepted the terms.",
            type: "string",
            format: "date-time"
          },
          affirmedMajorityConsent: {
            description: "The time when the user affirmed that they had majority consent to accept the terms.",
            type: "string",
            format: "date-time"
          },
          affirmed13YearsOrOlder: {
            description: "The time when the user affirmed that they are older than 13 years.",
            type: "string",
            format: "date-time"
          },
          affirmedNotGdpr: {
            description: "The time when the user affirmed that GDPR does not apply to them.",
            type: "string",
            format: "date-time"
          }
        }
      };
      contentReport = {
        $id: "https://howdju.com/schemas/content-report.schema.json",
        $schema: "http://json-schema.org/draft-07/schema#",
        title: "Content Report",
        description: "A user-submitted report of content that may violate our policies.",
        type: "object",
        required: ["url", "types"],
        properties: {
          entityType: {
            description: "The type of entity being reported, if the report can pertain to a particular entity.",
            enum: (0, import_lodash8.keys)(EntityTypes)
          },
          entityId: { $ref: "definitions.json#/definitions/entityId" },
          url: {
            description: "The URL upon which the user made the report, and so likely an URL where the content appears.",
            type: "string",
            format: "uri"
          },
          types: {
            type: "array",
            uniqueItems: true,
            items: { enum: (0, import_lodash8.keys)(ContentReportTypes) },
            // A report must have at least one type
            minItems: 1
          },
          description: {
            description: "The user's description of the report.",
            type: "string",
            maxLength: schemaSettings.reportContentDescriptionMaxLength
          }
        }
      };
      writ = {
        $id: "https://howdju.com/schemas/writ.schema.json",
        $schema: "http://json-schema.org/draft-07/schema#",
        title: "Writ",
        description: "A textual media source. Ex a book or news article.",
        type: "object",
        required: ["textQuote", "writ"],
        properties: {
          title: {
            type: "string",
            maxLength: schemaSettings.writTitleMaxLength,
            description: "The title of the Writ. Ex: the title of a book."
          }
        }
      };
      writQuote = {
        $id: "https://howdju.com/schemas/writ-quote.schema.json",
        $schema: "http://json-schema.org/draft-07/schema#",
        title: "WritQuote",
        description: "A quoted excerpt from textual media.",
        type: "object",
        required: ["textQuote", "writ"],
        properties: {
          textQuote: {
            type: "string",
            maxLength: schemaSettings.writQuoteQuoteTextMaxLength,
            description: "The text quoted from the media."
          },
          writ: { $ref: "https://howdju.com/schemas/writ.schema.json" },
          urls: {
            description: "URLs where users can find the quote.",
            type: "array",
            items: {
              type: "string",
              format: "uri"
            }
          }
        }
      };
      persorg = {
        $id: "https://howdju.com/schemas/persorg.schema.json",
        $schema: "http://json-schema.org/draft-07/schema#",
        title: "Persorg",
        description: "A person or organization. Something that can be a speaker.",
        type: "object",
        required: ["name", "isOrganization", "knownFor"],
        properties: {
          name: {
            type: "string",
            maxLength: schemaSettings.persorgNameMaxLength,
            description: "The name of the persorg."
          },
          isOrganization: {
            type: "boolean",
            description: "Whether the persorg is an organization (or a person.)"
          },
          knownFor: {
            type: "string",
            maxLength: schemaSettings.persorgKnownForMaxLength,
            description: "A short desription of what the persorg is known for, to help distinguish the persorg from other persorgs, to provide context about the persorg's significance, or to provide context about the significance or motivationi for the persorg's speech."
          },
          websiteUrl: {
            type: "string",
            format: "uri",
            maxLength: schemaSettings.urlMaxLength,
            description: "The URL of the website the persorg represents as its primary website. If there is none, then then the generally accepted primary website representing the persorg."
          },
          twitterUrl: {
            type: "string",
            format: "uri",
            maxLength: schemaSettings.urlMaxLength,
            description: "The URL of the Twitter profile that the persorg represents as belonging to it. If the persorg does not publicly represent that it has a Twitter account, then no unofficial Twitter account should be substituted here."
          },
          wikipediaUrl: {
            type: "string",
            format: "uri",
            maxLength: schemaSettings.urlMaxLength,
            description: "The URL of the Wikipedia page representing the persorg. The persorg need not endorse this page."
          }
        }
      };
      schemas = {
        contentReport,
        passwordResetRequest,
        passwordResetConfirmation,
        persorg,
        user,
        writ,
        writQuote
      };
      schemasById = {
        [contentReport["$id"]]: contentReport,
        [passwordResetRequest["$id"]]: passwordResetRequest,
        [passwordResetConfirmation["$id"]]: passwordResetConfirmation,
        [persorg["$id"]]: persorg,
        [user["$id"]]: user,
        [writ["$id"]]: writ,
        [writQuote["$id"]]: writQuote
      };
    }
  });

  // ../node_modules/ajv/dist/compile/codegen/code.js
  var require_code = __commonJS({
    "../node_modules/ajv/dist/compile/codegen/code.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.regexpCode = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
      var _CodeOrName = class {
      };
      exports._CodeOrName = _CodeOrName;
      exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      var Name = class extends _CodeOrName {
        constructor(s3) {
          super();
          if (!exports.IDENTIFIER.test(s3))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = s3;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return false;
        }
        get names() {
          return { [this.str]: 1 };
        }
      };
      exports.Name = Name;
      var _Code = class extends _CodeOrName {
        constructor(code) {
          super();
          this._items = typeof code === "string" ? [code] : code;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return false;
          const item = this._items[0];
          return item === "" || item === '""';
        }
        get str() {
          var _a;
          return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s3, c3) => `${s3}${c3}`, "");
        }
        get names() {
          var _a;
          return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c3) => {
            if (c3 instanceof Name)
              names[c3.str] = (names[c3.str] || 0) + 1;
            return names;
          }, {});
        }
      };
      exports._Code = _Code;
      exports.nil = new _Code("");
      function _3(strs, ...args) {
        const code = [strs[0]];
        let i3 = 0;
        while (i3 < args.length) {
          addCodeArg(code, args[i3]);
          code.push(strs[++i3]);
        }
        return new _Code(code);
      }
      exports._ = _3;
      var plus = new _Code("+");
      function str2(strs, ...args) {
        const expr = [safeStringify(strs[0])];
        let i3 = 0;
        while (i3 < args.length) {
          expr.push(plus);
          addCodeArg(expr, args[i3]);
          expr.push(plus, safeStringify(strs[++i3]));
        }
        optimize(expr);
        return new _Code(expr);
      }
      exports.str = str2;
      function addCodeArg(code, arg) {
        if (arg instanceof _Code)
          code.push(...arg._items);
        else if (arg instanceof Name)
          code.push(arg);
        else
          code.push(interpolate(arg));
      }
      exports.addCodeArg = addCodeArg;
      function optimize(expr) {
        let i3 = 1;
        while (i3 < expr.length - 1) {
          if (expr[i3] === plus) {
            const res = mergeExprItems(expr[i3 - 1], expr[i3 + 1]);
            if (res !== void 0) {
              expr.splice(i3 - 1, 3, res);
              continue;
            }
            expr[i3++] = "+";
          }
          i3++;
        }
      }
      function mergeExprItems(a3, b3) {
        if (b3 === '""')
          return a3;
        if (a3 === '""')
          return b3;
        if (typeof a3 == "string") {
          if (b3 instanceof Name || a3[a3.length - 1] !== '"')
            return;
          if (typeof b3 != "string")
            return `${a3.slice(0, -1)}${b3}"`;
          if (b3[0] === '"')
            return a3.slice(0, -1) + b3.slice(1);
          return;
        }
        if (typeof b3 == "string" && b3[0] === '"' && !(a3 instanceof Name))
          return `"${a3}${b3.slice(1)}`;
        return;
      }
      function strConcat(c1, c22) {
        return c22.emptyStr() ? c1 : c1.emptyStr() ? c22 : str2`${c1}${c22}`;
      }
      exports.strConcat = strConcat;
      function interpolate(x3) {
        return typeof x3 == "number" || typeof x3 == "boolean" || x3 === null ? x3 : safeStringify(Array.isArray(x3) ? x3.join(",") : x3);
      }
      function stringify(x3) {
        return new _Code(safeStringify(x3));
      }
      exports.stringify = stringify;
      function safeStringify(x3) {
        return JSON.stringify(x3).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      exports.safeStringify = safeStringify;
      function getProperty(key) {
        return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _3`[${key}]`;
      }
      exports.getProperty = getProperty;
      function regexpCode(rx) {
        return new _Code(rx.toString());
      }
      exports.regexpCode = regexpCode;
    }
  });

  // ../node_modules/ajv/dist/compile/codegen/scope.js
  var require_scope = __commonJS({
    "../node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
      var code_1 = require_code();
      var ValueError = class extends Error {
        constructor(name) {
          super(`CodeGen: "code" for ${name} not defined`);
          this.value = name.value;
        }
      };
      var UsedValueState;
      (function(UsedValueState2) {
        UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
        UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
      })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
      exports.varKinds = {
        const: new code_1.Name("const"),
        let: new code_1.Name("let"),
        var: new code_1.Name("var")
      };
      var Scope = class {
        constructor({ prefixes, parent } = {}) {
          this._names = {};
          this._prefixes = prefixes;
          this._parent = parent;
        }
        toName(nameOrPrefix) {
          return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
        }
        name(prefix) {
          return new code_1.Name(this._newName(prefix));
        }
        _newName(prefix) {
          const ng = this._names[prefix] || this._nameGroup(prefix);
          return `${prefix}${ng.index++}`;
        }
        _nameGroup(prefix) {
          var _a, _b;
          if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
          }
          return this._names[prefix] = { prefix, index: 0 };
        }
      };
      exports.Scope = Scope;
      var ValueScopeName = class extends code_1.Name {
        constructor(prefix, nameStr) {
          super(nameStr);
          this.prefix = prefix;
        }
        setValue(value, { property, itemIndex }) {
          this.value = value;
          this.scopePath = code_1._`.${new code_1.Name(property)}[${itemIndex}]`;
        }
      };
      exports.ValueScopeName = ValueScopeName;
      var line = code_1._`\n`;
      var ValueScope = class extends Scope {
        constructor(opts) {
          super(opts);
          this._values = {};
          this._scope = opts.scope;
          this.opts = __spreadProps(__spreadValues({}, opts), { _n: opts.lines ? line : code_1.nil });
        }
        get() {
          return this._scope;
        }
        name(prefix) {
          return new ValueScopeName(prefix, this._newName(prefix));
        }
        value(nameOrPrefix, value) {
          var _a;
          if (value.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const name = this.toName(nameOrPrefix);
          const { prefix } = name;
          const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
          let vs = this._values[prefix];
          if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
              return _name;
          } else {
            vs = this._values[prefix] = /* @__PURE__ */ new Map();
          }
          vs.set(valueKey, name);
          const s3 = this._scope[prefix] || (this._scope[prefix] = []);
          const itemIndex = s3.length;
          s3[itemIndex] = value.ref;
          name.setValue(value, { property: prefix, itemIndex });
          return name;
        }
        getValue(prefix, keyOrRef) {
          const vs = this._values[prefix];
          if (!vs)
            return;
          return vs.get(keyOrRef);
        }
        scopeRefs(scopeName, values2 = this._values) {
          return this._reduceValues(values2, (name) => {
            if (name.scopePath === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return code_1._`${scopeName}${name.scopePath}`;
          });
        }
        scopeCode(values2 = this._values, usedValues, getCode) {
          return this._reduceValues(values2, (name) => {
            if (name.value === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
          }, usedValues, getCode);
        }
        _reduceValues(values2, valueCode, usedValues = {}, getCode) {
          let code = code_1.nil;
          for (const prefix in values2) {
            const vs = values2[prefix];
            if (!vs)
              continue;
            const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
            vs.forEach((name) => {
              if (nameSet.has(name))
                return;
              nameSet.set(name, UsedValueState.Started);
              let c3 = valueCode(name);
              if (c3) {
                const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                code = code_1._`${code}${def} ${name} = ${c3};${this.opts._n}`;
              } else if (c3 = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
                code = code_1._`${code}${c3}${this.opts._n}`;
              } else {
                throw new ValueError(name);
              }
              nameSet.set(name, UsedValueState.Completed);
            });
          }
          return code;
        }
      };
      exports.ValueScope = ValueScope;
    }
  });

  // ../node_modules/ajv/dist/compile/codegen/index.js
  var require_codegen = __commonJS({
    "../node_modules/ajv/dist/compile/codegen/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
      var code_1 = require_code();
      var scope_1 = require_scope();
      var code_2 = require_code();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return code_2._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return code_2.str;
      } });
      Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
        return code_2.strConcat;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return code_2.nil;
      } });
      Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
        return code_2.getProperty;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return code_2.stringify;
      } });
      Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
        return code_2.regexpCode;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return code_2.Name;
      } });
      var scope_2 = require_scope();
      Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
        return scope_2.Scope;
      } });
      Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
        return scope_2.ValueScope;
      } });
      Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
        return scope_2.ValueScopeName;
      } });
      Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
        return scope_2.varKinds;
      } });
      exports.operators = {
        GT: new code_1._Code(">"),
        GTE: new code_1._Code(">="),
        LT: new code_1._Code("<"),
        LTE: new code_1._Code("<="),
        EQ: new code_1._Code("==="),
        NEQ: new code_1._Code("!=="),
        NOT: new code_1._Code("!"),
        OR: new code_1._Code("||"),
        AND: new code_1._Code("&&"),
        ADD: new code_1._Code("+")
      };
      var Node2 = class {
        optimizeNodes() {
          return this;
        }
        optimizeNames(_names, _constants) {
          return this;
        }
      };
      var Def = class extends Node2 {
        constructor(varKind, name, rhs) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.rhs = rhs;
        }
        render({ es5, _n }) {
          const varKind = es5 ? scope_1.varKinds.var : this.varKind;
          const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${varKind} ${this.name}${rhs};` + _n;
        }
        optimizeNames(names, constants) {
          if (!names[this.name.str])
            return;
          if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names, constants);
          return this;
        }
        get names() {
          return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
        }
      };
      var Assign = class extends Node2 {
        constructor(lhs, rhs, sideEffects) {
          super();
          this.lhs = lhs;
          this.rhs = rhs;
          this.sideEffects = sideEffects;
        }
        render({ _n }) {
          return `${this.lhs} = ${this.rhs};` + _n;
        }
        optimizeNames(names, constants) {
          if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
            return;
          this.rhs = optimizeExpr(this.rhs, names, constants);
          return this;
        }
        get names() {
          const names = this.lhs instanceof code_1.Name ? {} : __spreadValues({}, this.lhs.names);
          return addExprNames(names, this.rhs);
        }
      };
      var AssignOp = class extends Assign {
        constructor(lhs, op, rhs, sideEffects) {
          super(lhs, rhs, sideEffects);
          this.op = op;
        }
        render({ _n }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
        }
      };
      var Label = class extends Node2 {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          return `${this.label}:` + _n;
        }
      };
      var Break = class extends Node2 {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          const label = this.label ? ` ${this.label}` : "";
          return `break${label};` + _n;
        }
      };
      var Throw = class extends Node2 {
        constructor(error) {
          super();
          this.error = error;
        }
        render({ _n }) {
          return `throw ${this.error};` + _n;
        }
        get names() {
          return this.error.names;
        }
      };
      var AnyCode = class extends Node2 {
        constructor(code) {
          super();
          this.code = code;
        }
        render({ _n }) {
          return `${this.code};` + _n;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(names, constants) {
          this.code = optimizeExpr(this.code, names, constants);
          return this;
        }
        get names() {
          return this.code instanceof code_1._CodeOrName ? this.code.names : {};
        }
      };
      var ParentNode = class extends Node2 {
        constructor(nodes = []) {
          super();
          this.nodes = nodes;
        }
        render(opts) {
          return this.nodes.reduce((code, n3) => code + n3.render(opts), "");
        }
        optimizeNodes() {
          const { nodes } = this;
          let i3 = nodes.length;
          while (i3--) {
            const n3 = nodes[i3].optimizeNodes();
            if (Array.isArray(n3))
              nodes.splice(i3, 1, ...n3);
            else if (n3)
              nodes[i3] = n3;
            else
              nodes.splice(i3, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        optimizeNames(names, constants) {
          const { nodes } = this;
          let i3 = nodes.length;
          while (i3--) {
            const n3 = nodes[i3];
            if (n3.optimizeNames(names, constants))
              continue;
            subtractNames(names, n3.names);
            nodes.splice(i3, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((names, n3) => addNames(names, n3.names), {});
        }
      };
      var BlockNode = class extends ParentNode {
        render(opts) {
          return "{" + opts._n + super.render(opts) + "}" + opts._n;
        }
      };
      var Root = class extends ParentNode {
      };
      var Else = class extends BlockNode {
      };
      Else.kind = "else";
      var If = class _If extends BlockNode {
        constructor(condition, nodes) {
          super(nodes);
          this.condition = condition;
        }
        render(opts) {
          let code = `if(${this.condition})` + super.render(opts);
          if (this.else)
            code += "else " + this.else.render(opts);
          return code;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const cond = this.condition;
          if (cond === true)
            return this.nodes;
          let e2 = this.else;
          if (e2) {
            const ns = e2.optimizeNodes();
            e2 = this.else = Array.isArray(ns) ? new Else(ns) : ns;
          }
          if (e2) {
            if (cond === false)
              return e2 instanceof _If ? e2 : e2.nodes;
            if (this.nodes.length)
              return this;
            return new _If(not(cond), e2 instanceof _If ? [e2] : e2.nodes);
          }
          if (cond === false || !this.nodes.length)
            return void 0;
          return this;
        }
        optimizeNames(names, constants) {
          var _a;
          this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
          if (!(super.optimizeNames(names, constants) || this.else))
            return;
          this.condition = optimizeExpr(this.condition, names, constants);
          return this;
        }
        get names() {
          const names = super.names;
          addExprNames(names, this.condition);
          if (this.else)
            addNames(names, this.else.names);
          return names;
        }
      };
      If.kind = "if";
      var For = class extends BlockNode {
      };
      For.kind = "for";
      var ForLoop = class extends For {
        constructor(iteration) {
          super();
          this.iteration = iteration;
        }
        render(opts) {
          return `for(${this.iteration})` + super.render(opts);
        }
        optimizeNames(names, constants) {
          if (!super.optimizeNames(names, constants))
            return;
          this.iteration = optimizeExpr(this.iteration, names, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iteration.names);
        }
      };
      var ForRange = class extends For {
        constructor(varKind, name, from, to) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.from = from;
          this.to = to;
        }
        render(opts) {
          const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
          const { name, from, to } = this;
          return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
        }
        get names() {
          const names = addExprNames(super.names, this.from);
          return addExprNames(names, this.to);
        }
      };
      var ForIter = class extends For {
        constructor(loop, varKind, name, iterable) {
          super();
          this.loop = loop;
          this.varKind = varKind;
          this.name = name;
          this.iterable = iterable;
        }
        render(opts) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
        }
        optimizeNames(names, constants) {
          if (!super.optimizeNames(names, constants))
            return;
          this.iterable = optimizeExpr(this.iterable, names, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iterable.names);
        }
      };
      var Func = class extends BlockNode {
        constructor(name, args, async) {
          super();
          this.name = name;
          this.args = args;
          this.async = async;
        }
        render(opts) {
          const _async = this.async ? "async " : "";
          return `${_async}function ${this.name}(${this.args})` + super.render(opts);
        }
      };
      Func.kind = "func";
      var Return = class extends ParentNode {
        render(opts) {
          return "return " + super.render(opts);
        }
      };
      Return.kind = "return";
      var Try = class extends BlockNode {
        render(opts) {
          let code = "try" + super.render(opts);
          if (this.catch)
            code += this.catch.render(opts);
          if (this.finally)
            code += this.finally.render(opts);
          return code;
        }
        optimizeNodes() {
          var _a, _b;
          super.optimizeNodes();
          (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
          return this;
        }
        optimizeNames(names, constants) {
          var _a, _b;
          super.optimizeNames(names, constants);
          (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
          return this;
        }
        get names() {
          const names = super.names;
          if (this.catch)
            addNames(names, this.catch.names);
          if (this.finally)
            addNames(names, this.finally.names);
          return names;
        }
      };
      var Catch = class extends BlockNode {
        constructor(error) {
          super();
          this.error = error;
        }
        render(opts) {
          return `catch(${this.error})` + super.render(opts);
        }
      };
      Catch.kind = "catch";
      var Finally = class extends BlockNode {
        render(opts) {
          return "finally" + super.render(opts);
        }
      };
      Finally.kind = "finally";
      var CodeGen = class {
        constructor(extScope, opts = {}) {
          this._values = {};
          this._blockStarts = [];
          this._constants = {};
          this.opts = __spreadProps(__spreadValues({}, opts), { _n: opts.lines ? "\n" : "" });
          this._extScope = extScope;
          this._scope = new scope_1.Scope({ parent: extScope });
          this._nodes = [new Root()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(prefix) {
          return this._scope.name(prefix);
        }
        // reserves unique name in the external scope
        scopeName(prefix) {
          return this._extScope.name(prefix);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(prefixOrName, value) {
          const name = this._extScope.value(prefixOrName, value);
          const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
          vs.add(name);
          return name;
        }
        getScopeValue(prefix, keyOrRef) {
          return this._extScope.getValue(prefix, keyOrRef);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(scopeName) {
          return this._extScope.scopeRefs(scopeName, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
          const name = this._scope.toName(nameOrPrefix);
          if (rhs !== void 0 && constant)
            this._constants[name.str] = rhs;
          this._leafNode(new Def(varKind, name, rhs));
          return name;
        }
        // `const` declaration (`var` in es5 mode)
        const(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
        }
        // `var` declaration with optional assignment
        var(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
        }
        // assignment code
        assign(lhs, rhs, sideEffects) {
          return this._leafNode(new Assign(lhs, rhs, sideEffects));
        }
        // `+=` code
        add(lhs, rhs) {
          return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
        }
        // appends passed SafeExpr to code or executes Block
        code(c3) {
          if (typeof c3 == "function")
            c3();
          else if (c3 !== code_1.nil)
            this._leafNode(new AnyCode(c3));
          return this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...keyValues) {
          const code = ["{"];
          for (const [key, value] of keyValues) {
            if (code.length > 1)
              code.push(",");
            code.push(key);
            if (key !== value || this.opts.es5) {
              code.push(":");
              code_1.addCodeArg(code, value);
            }
          }
          code.push("}");
          return new code_1._Code(code);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(condition, thenBody, elseBody) {
          this._blockNode(new If(condition));
          if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
          } else if (thenBody) {
            this.code(thenBody).endIf();
          } else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
          }
          return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(condition) {
          return this._elseNode(new If(condition));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new Else());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(If, Else);
        }
        _for(node, forBody) {
          this._blockNode(node);
          if (forBody)
            this.code(forBody).endFor();
          return this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(iteration, forBody) {
          return this._for(new ForLoop(iteration), forBody);
        }
        // `for` statement for a range of values
        forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
          const name = this._scope.toName(nameOrPrefix);
          if (this.opts.es5) {
            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, code_1._`${arr}.length`, (i3) => {
              this.var(name, code_1._`${arr}[${i3}]`);
              forBody(name);
            });
          }
          return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
          if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, code_1._`Object.keys(${obj})`, forBody);
          }
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(For);
        }
        // `label` statement
        label(label) {
          return this._leafNode(new Label(label));
        }
        // `break` statement
        break(label) {
          return this._leafNode(new Break(label));
        }
        // `return` statement
        return(value) {
          const node = new Return();
          this._blockNode(node);
          this.code(value);
          if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(Return);
        }
        // `try` statement
        try(tryBody, catchCode, finallyCode) {
          if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const node = new Try();
          this._blockNode(node);
          this.code(tryBody);
          if (catchCode) {
            const error = this.name("e");
            this._currNode = node.catch = new Catch(error);
            catchCode(error);
          }
          if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
          }
          return this._endBlockNode(Catch, Finally);
        }
        // `throw` statement
        throw(error) {
          return this._leafNode(new Throw(error));
        }
        // start self-balancing block
        block(body, nodeCount) {
          this._blockStarts.push(this._nodes.length);
          if (body)
            this.code(body).endBlock(nodeCount);
          return this;
        }
        // end the current self-balancing block
        endBlock(nodeCount) {
          const len = this._blockStarts.pop();
          if (len === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const toClose = this._nodes.length - len;
          if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
          }
          this._nodes.length = len;
          return this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(name, args = code_1.nil, async, funcBody) {
          this._blockNode(new Func(name, args, async));
          if (funcBody)
            this.code(funcBody).endFunc();
          return this;
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(Func);
        }
        optimize(n3 = 1) {
          while (n3-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
          }
        }
        _leafNode(node) {
          this._currNode.nodes.push(node);
          return this;
        }
        _blockNode(node) {
          this._currNode.nodes.push(node);
          this._nodes.push(node);
        }
        _endBlockNode(N1, N22) {
          const n3 = this._currNode;
          if (n3 instanceof N1 || N22 && n3 instanceof N22) {
            this._nodes.pop();
            return this;
          }
          throw new Error(`CodeGen: not in block "${N22 ? `${N1.kind}/${N22.kind}` : N1.kind}"`);
        }
        _elseNode(node) {
          const n3 = this._currNode;
          if (!(n3 instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
          }
          this._currNode = n3.else = node;
          return this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const ns = this._nodes;
          return ns[ns.length - 1];
        }
        set _currNode(node) {
          const ns = this._nodes;
          ns[ns.length - 1] = node;
        }
      };
      exports.CodeGen = CodeGen;
      function addNames(names, from) {
        for (const n3 in from)
          names[n3] = (names[n3] || 0) + (from[n3] || 0);
        return names;
      }
      function addExprNames(names, from) {
        return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
      }
      function optimizeExpr(expr, names, constants) {
        if (expr instanceof code_1.Name)
          return replaceName(expr);
        if (!canOptimize(expr))
          return expr;
        return new code_1._Code(expr._items.reduce((items, c3) => {
          if (c3 instanceof code_1.Name)
            c3 = replaceName(c3);
          if (c3 instanceof code_1._Code)
            items.push(...c3._items);
          else
            items.push(c3);
          return items;
        }, []));
        function replaceName(n3) {
          const c3 = constants[n3.str];
          if (c3 === void 0 || names[n3.str] !== 1)
            return n3;
          delete names[n3.str];
          return c3;
        }
        function canOptimize(e2) {
          return e2 instanceof code_1._Code && e2._items.some((c3) => c3 instanceof code_1.Name && names[c3.str] === 1 && constants[c3.str] !== void 0);
        }
      }
      function subtractNames(names, from) {
        for (const n3 in from)
          names[n3] = (names[n3] || 0) - (from[n3] || 0);
      }
      function not(x3) {
        return typeof x3 == "boolean" || typeof x3 == "number" || x3 === null ? !x3 : code_1._`!${par(x3)}`;
      }
      exports.not = not;
      var andCode = mappend(exports.operators.AND);
      function and(...args) {
        return args.reduce(andCode);
      }
      exports.and = and;
      var orCode = mappend(exports.operators.OR);
      function or(...args) {
        return args.reduce(orCode);
      }
      exports.or = or;
      function mappend(op) {
        return (x3, y3) => x3 === code_1.nil ? y3 : y3 === code_1.nil ? x3 : code_1._`${par(x3)} ${op} ${par(y3)}`;
      }
      function par(x3) {
        return x3 instanceof code_1.Name ? x3 : code_1._`(${x3})`;
      }
    }
  });

  // ../node_modules/ajv/dist/compile/util.js
  var require_util = __commonJS({
    "../node_modules/ajv/dist/compile/util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
      var codegen_1 = require_codegen();
      var code_1 = require_code();
      function toHash(arr) {
        const hash = {};
        for (const item of arr)
          hash[item] = true;
        return hash;
      }
      exports.toHash = toHash;
      function alwaysValidSchema(it, schema) {
        if (typeof schema == "boolean")
          return schema;
        if (Object.keys(schema).length === 0)
          return true;
        checkUnknownRules(it, schema);
        return !schemaHasRules(schema, it.self.RULES.all);
      }
      exports.alwaysValidSchema = alwaysValidSchema;
      function checkUnknownRules(it, schema = it.schema) {
        const { opts, self: self2 } = it;
        if (!opts.strictSchema)
          return;
        if (typeof schema === "boolean")
          return;
        const rules = self2.RULES.keywords;
        for (const key in schema) {
          if (!rules[key])
            checkStrictMode(it, `unknown keyword: "${key}"`);
        }
      }
      exports.checkUnknownRules = checkUnknownRules;
      function schemaHasRules(schema, rules) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (rules[key])
            return true;
        return false;
      }
      exports.schemaHasRules = schemaHasRules;
      function schemaHasRulesButRef(schema, RULES) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (key !== "$ref" && RULES.all[key])
            return true;
        return false;
      }
      exports.schemaHasRulesButRef = schemaHasRulesButRef;
      function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
        if (!$data) {
          if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
          if (typeof schema == "string")
            return codegen_1._`${schema}`;
        }
        return codegen_1._`${topSchemaRef}${schemaPath}${codegen_1.getProperty(keyword)}`;
      }
      exports.schemaRefOrVal = schemaRefOrVal;
      function unescapeFragment(str2) {
        return unescapeJsonPointer(decodeURIComponent(str2));
      }
      exports.unescapeFragment = unescapeFragment;
      function escapeFragment(str2) {
        return encodeURIComponent(escapeJsonPointer(str2));
      }
      exports.escapeFragment = escapeFragment;
      function escapeJsonPointer(str2) {
        if (typeof str2 == "number")
          return `${str2}`;
        return str2.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      exports.escapeJsonPointer = escapeJsonPointer;
      function unescapeJsonPointer(str2) {
        return str2.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      exports.unescapeJsonPointer = unescapeJsonPointer;
      function eachItem(xs, f3) {
        if (Array.isArray(xs)) {
          for (const x3 of xs)
            f3(x3);
        } else {
          f3(xs);
        }
      }
      exports.eachItem = eachItem;
      function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
        return (gen, from, to, toName) => {
          const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues2(from, to);
          return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
        };
      }
      exports.mergeEvaluated = {
        props: makeMergeEvaluated({
          mergeNames: (gen, from, to) => gen.if(codegen_1._`${to} !== true && ${from} !== undefined`, () => {
            gen.if(codegen_1._`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, codegen_1._`${to} || {}`).code(codegen_1._`Object.assign(${to}, ${from})`));
          }),
          mergeToName: (gen, from, to) => gen.if(codegen_1._`${to} !== true`, () => {
            if (from === true) {
              gen.assign(to, true);
            } else {
              gen.assign(to, codegen_1._`${to} || {}`);
              setEvaluated(gen, to, from);
            }
          }),
          mergeValues: (from, to) => from === true ? true : __spreadValues(__spreadValues({}, from), to),
          resultToName: evaluatedPropsToName
        }),
        items: makeMergeEvaluated({
          mergeNames: (gen, from, to) => gen.if(codegen_1._`${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_1._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
          mergeToName: (gen, from, to) => gen.if(codegen_1._`${to} !== true`, () => gen.assign(to, from === true ? true : codegen_1._`${to} > ${from} ? ${to} : ${from}`)),
          mergeValues: (from, to) => from === true ? true : Math.max(from, to),
          resultToName: (gen, items) => gen.var("items", items)
        })
      };
      function evaluatedPropsToName(gen, ps) {
        if (ps === true)
          return gen.var("props", true);
        const props = gen.var("props", codegen_1._`{}`);
        if (ps !== void 0)
          setEvaluated(gen, props, ps);
        return props;
      }
      exports.evaluatedPropsToName = evaluatedPropsToName;
      function setEvaluated(gen, props, ps) {
        Object.keys(ps).forEach((p3) => gen.assign(codegen_1._`${props}${codegen_1.getProperty(p3)}`, true));
      }
      exports.setEvaluated = setEvaluated;
      var snippets = {};
      function useFunc(gen, f3) {
        return gen.scopeValue("func", {
          ref: f3,
          code: snippets[f3.code] || (snippets[f3.code] = new code_1._Code(f3.code))
        });
      }
      exports.useFunc = useFunc;
      var Type;
      (function(Type2) {
        Type2[Type2["Num"] = 0] = "Num";
        Type2[Type2["Str"] = 1] = "Str";
      })(Type = exports.Type || (exports.Type = {}));
      function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
        if (dataProp instanceof codegen_1.Name) {
          const isNumber2 = dataPropType === Type.Num;
          return jsPropertySyntax ? isNumber2 ? codegen_1._`"[" + ${dataProp} + "]"` : codegen_1._`"['" + ${dataProp} + "']"` : isNumber2 ? codegen_1._`"/" + ${dataProp}` : codegen_1._`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
        }
        return jsPropertySyntax ? codegen_1.getProperty(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
      }
      exports.getErrorPath = getErrorPath;
      function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
        if (!mode)
          return;
        msg = `strict mode: ${msg}`;
        if (mode === true)
          throw new Error(msg);
        it.self.logger.warn(msg);
      }
      exports.checkStrictMode = checkStrictMode;
    }
  });

  // ../node_modules/ajv/dist/compile/names.js
  var require_names = __commonJS({
    "../node_modules/ajv/dist/compile/names.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var names = {
        // validation function arguments
        data: new codegen_1.Name("data"),
        // args passed from referencing schema
        valCxt: new codegen_1.Name("valCxt"),
        instancePath: new codegen_1.Name("instancePath"),
        parentData: new codegen_1.Name("parentData"),
        parentDataProperty: new codegen_1.Name("parentDataProperty"),
        rootData: new codegen_1.Name("rootData"),
        dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
        // function scoped variables
        vErrors: new codegen_1.Name("vErrors"),
        errors: new codegen_1.Name("errors"),
        this: new codegen_1.Name("this"),
        // "globals"
        self: new codegen_1.Name("self"),
        scope: new codegen_1.Name("scope"),
        // JTD serialize/parse name for JSON string and position
        json: new codegen_1.Name("json"),
        jsonPos: new codegen_1.Name("jsonPos"),
        jsonLen: new codegen_1.Name("jsonLen"),
        jsonPart: new codegen_1.Name("jsonPart")
      };
      exports.default = names;
    }
  });

  // ../node_modules/ajv/dist/compile/errors.js
  var require_errors = __commonJS({
    "../node_modules/ajv/dist/compile/errors.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var names_1 = require_names();
      exports.keywordError = {
        message: ({ keyword }) => codegen_1.str`should pass "${keyword}" keyword validation`
      };
      exports.keyword$DataError = {
        message: ({ keyword, schemaType }) => schemaType ? codegen_1.str`"${keyword}" keyword must be ${schemaType} ($data)` : codegen_1.str`"${keyword}" keyword is invalid ($data)`
      };
      function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
          addError(gen, errObj);
        } else {
          returnErrors(it, codegen_1._`[${errObj}]`);
        }
      }
      exports.reportError = reportError;
      function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        addError(gen, errObj);
        if (!(compositeRule || allErrors)) {
          returnErrors(it, names_1.default.vErrors);
        }
      }
      exports.reportExtraError = reportExtraError;
      function resetErrorsCount(gen, errsCount) {
        gen.assign(names_1.default.errors, errsCount);
        gen.if(codegen_1._`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_1._`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
      }
      exports.resetErrorsCount = resetErrorsCount;
      function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
        if (errsCount === void 0)
          throw new Error("ajv implementation error");
        const err = gen.name("err");
        gen.forRange("i", errsCount, names_1.default.errors, (i3) => {
          gen.const(err, codegen_1._`${names_1.default.vErrors}[${i3}]`);
          gen.if(codegen_1._`${err}.instancePath === undefined`, () => gen.assign(codegen_1._`${err}.instancePath`, codegen_1.strConcat(names_1.default.instancePath, it.errorPath)));
          gen.assign(codegen_1._`${err}.schemaPath`, codegen_1.str`${it.errSchemaPath}/${keyword}`);
          if (it.opts.verbose) {
            gen.assign(codegen_1._`${err}.schema`, schemaValue);
            gen.assign(codegen_1._`${err}.data`, data);
          }
        });
      }
      exports.extendErrors = extendErrors;
      function addError(gen, errObj) {
        const err = gen.const("err", errObj);
        gen.if(codegen_1._`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, codegen_1._`[${err}]`), codegen_1._`${names_1.default.vErrors}.push(${err})`);
        gen.code(codegen_1._`${names_1.default.errors}++`);
      }
      function returnErrors(it, errs) {
        const { gen, validateName, schemaEnv } = it;
        if (schemaEnv.$async) {
          gen.throw(codegen_1._`new ${it.ValidationError}(${errs})`);
        } else {
          gen.assign(codegen_1._`${validateName}.errors`, errs);
          gen.return(false);
        }
      }
      var E3 = {
        keyword: new codegen_1.Name("keyword"),
        schemaPath: new codegen_1.Name("schemaPath"),
        params: new codegen_1.Name("params"),
        propertyName: new codegen_1.Name("propertyName"),
        message: new codegen_1.Name("message"),
        schema: new codegen_1.Name("schema"),
        parentSchema: new codegen_1.Name("parentSchema")
      };
      function errorObjectCode(cxt, error, errorPaths) {
        const { createErrors } = cxt.it;
        if (createErrors === false)
          return codegen_1._`{}`;
        return errorObject(cxt, error, errorPaths);
      }
      function errorObject(cxt, error, errorPaths = {}) {
        const { gen, it } = cxt;
        const keyValues = [
          errorInstancePath(it, errorPaths),
          errorSchemaPath(cxt, errorPaths)
        ];
        extraErrorProps(cxt, error, keyValues);
        return gen.object(...keyValues);
      }
      function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath ? codegen_1.str`${errorPath}${util_1.getErrorPath(instancePath, util_1.Type.Str)}` : errorPath;
        return [names_1.default.instancePath, codegen_1.strConcat(names_1.default.instancePath, instPath)];
      }
      function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
        let schPath = parentSchema ? errSchemaPath : codegen_1.str`${errSchemaPath}/${keyword}`;
        if (schemaPath) {
          schPath = codegen_1.str`${schPath}${util_1.getErrorPath(schemaPath, util_1.Type.Str)}`;
        }
        return [E3.schemaPath, schPath];
      }
      function extraErrorProps(cxt, { params, message }, keyValues) {
        const { keyword, data, schemaValue, it } = cxt;
        const { opts, propertyName, topSchemaRef, schemaPath } = it;
        keyValues.push([E3.keyword, keyword], [E3.params, typeof params == "function" ? params(cxt) : params || codegen_1._`{}`]);
        if (opts.messages) {
          keyValues.push([E3.message, typeof message == "function" ? message(cxt) : message]);
        }
        if (opts.verbose) {
          keyValues.push([E3.schema, schemaValue], [E3.parentSchema, codegen_1._`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
        }
        if (propertyName)
          keyValues.push([E3.propertyName, propertyName]);
      }
    }
  });

  // ../node_modules/ajv/dist/compile/validate/boolSchema.js
  var require_boolSchema = __commonJS({
    "../node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
      var errors_1 = require_errors();
      var codegen_1 = require_codegen();
      var names_1 = require_names();
      var boolError = {
        message: "boolean schema is false"
      };
      function topBoolOrEmptySchema(it) {
        const { gen, schema, validateName } = it;
        if (schema === false) {
          falseSchemaError(it, false);
        } else if (typeof schema == "object" && schema.$async === true) {
          gen.return(names_1.default.data);
        } else {
          gen.assign(codegen_1._`${validateName}.errors`, null);
          gen.return(true);
        }
      }
      exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
      function boolOrEmptySchema(it, valid) {
        const { gen, schema } = it;
        if (schema === false) {
          gen.var(valid, false);
          falseSchemaError(it);
        } else {
          gen.var(valid, true);
        }
      }
      exports.boolOrEmptySchema = boolOrEmptySchema;
      function falseSchemaError(it, overrideAllErrors) {
        const { gen, data } = it;
        const cxt = {
          gen,
          keyword: "false schema",
          data,
          schema: false,
          schemaCode: false,
          schemaValue: false,
          params: {},
          it
        };
        errors_1.reportError(cxt, boolError, void 0, overrideAllErrors);
      }
    }
  });

  // ../node_modules/ajv/dist/compile/rules.js
  var require_rules = __commonJS({
    "../node_modules/ajv/dist/compile/rules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getRules = exports.isJSONType = void 0;
      var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
      var jsonTypes = new Set(_jsonTypes);
      function isJSONType(x3) {
        return typeof x3 == "string" && jsonTypes.has(x3);
      }
      exports.isJSONType = isJSONType;
      function getRules() {
        const groups = {
          number: { type: "number", rules: [] },
          string: { type: "string", rules: [] },
          array: { type: "array", rules: [] },
          object: { type: "object", rules: [] }
        };
        return {
          types: __spreadProps(__spreadValues({}, groups), { integer: true, boolean: true, null: true }),
          rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
          post: { rules: [] },
          all: {},
          keywords: {}
        };
      }
      exports.getRules = getRules;
    }
  });

  // ../node_modules/ajv/dist/compile/validate/applicability.js
  var require_applicability = __commonJS({
    "../node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
      function schemaHasRulesForType({ schema, self: self2 }, type) {
        const group = self2.RULES.types[type];
        return group && group !== true && shouldUseGroup(schema, group);
      }
      exports.schemaHasRulesForType = schemaHasRulesForType;
      function shouldUseGroup(schema, group) {
        return group.rules.some((rule) => shouldUseRule(schema, rule));
      }
      exports.shouldUseGroup = shouldUseGroup;
      function shouldUseRule(schema, rule) {
        var _a;
        return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
      }
      exports.shouldUseRule = shouldUseRule;
    }
  });

  // ../node_modules/ajv/dist/compile/validate/dataType.js
  var require_dataType = __commonJS({
    "../node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
      var rules_1 = require_rules();
      var applicability_1 = require_applicability();
      var errors_1 = require_errors();
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var DataType;
      (function(DataType2) {
        DataType2[DataType2["Correct"] = 0] = "Correct";
        DataType2[DataType2["Wrong"] = 1] = "Wrong";
      })(DataType = exports.DataType || (exports.DataType = {}));
      function getSchemaTypes(schema) {
        const types = getJSONTypes(schema.type);
        const hasNull = types.includes("null");
        if (hasNull) {
          if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
        } else {
          if (!types.length && schema.nullable !== void 0) {
            throw new Error('"nullable" cannot be used without "type"');
          }
          if (schema.nullable === true)
            types.push("null");
        }
        return types;
      }
      exports.getSchemaTypes = getSchemaTypes;
      function getJSONTypes(ts) {
        const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
        if (types.every(rules_1.isJSONType))
          return types;
        throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
      }
      exports.getJSONTypes = getJSONTypes;
      function coerceAndCheckDataType(it, types) {
        const { gen, data, opts } = it;
        const coerceTo = coerceToTypes(types, opts.coerceTypes);
        const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && applicability_1.schemaHasRulesForType(it, types[0]));
        if (checkTypes) {
          const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
          gen.if(wrongType, () => {
            if (coerceTo.length)
              coerceData(it, types, coerceTo);
            else
              reportTypeError(it);
          });
        }
        return checkTypes;
      }
      exports.coerceAndCheckDataType = coerceAndCheckDataType;
      var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
      function coerceToTypes(types, coerceTypes) {
        return coerceTypes ? types.filter((t3) => COERCIBLE.has(t3) || coerceTypes === "array" && t3 === "array") : [];
      }
      function coerceData(it, types, coerceTo) {
        const { gen, data, opts } = it;
        const dataType = gen.let("dataType", codegen_1._`typeof ${data}`);
        const coerced = gen.let("coerced", codegen_1._`undefined`);
        if (opts.coerceTypes === "array") {
          gen.if(codegen_1._`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, codegen_1._`${data}[0]`).assign(dataType, codegen_1._`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
        }
        gen.if(codegen_1._`${coerced} !== undefined`);
        for (const t3 of coerceTo) {
          if (COERCIBLE.has(t3) || t3 === "array" && opts.coerceTypes === "array") {
            coerceSpecificType(t3);
          }
        }
        gen.else();
        reportTypeError(it);
        gen.endIf();
        gen.if(codegen_1._`${coerced} !== undefined`, () => {
          gen.assign(data, coerced);
          assignParentData(it, coerced);
        });
        function coerceSpecificType(t3) {
          switch (t3) {
            case "string":
              gen.elseIf(codegen_1._`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, codegen_1._`"" + ${data}`).elseIf(codegen_1._`${data} === null`).assign(coerced, codegen_1._`""`);
              return;
            case "number":
              gen.elseIf(codegen_1._`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, codegen_1._`+${data}`);
              return;
            case "integer":
              gen.elseIf(codegen_1._`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, codegen_1._`+${data}`);
              return;
            case "boolean":
              gen.elseIf(codegen_1._`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf(codegen_1._`${data} === "true" || ${data} === 1`).assign(coerced, true);
              return;
            case "null":
              gen.elseIf(codegen_1._`${data} === "" || ${data} === 0 || ${data} === false`);
              gen.assign(coerced, null);
              return;
            case "array":
              gen.elseIf(codegen_1._`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, codegen_1._`[${data}]`);
          }
        }
      }
      function assignParentData({ gen, parentData, parentDataProperty }, expr) {
        gen.if(codegen_1._`${parentData} !== undefined`, () => gen.assign(codegen_1._`${parentData}[${parentDataProperty}]`, expr));
      }
      function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
        const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
        let cond;
        switch (dataType) {
          case "null":
            return codegen_1._`${data} ${EQ} null`;
          case "array":
            cond = codegen_1._`Array.isArray(${data})`;
            break;
          case "object":
            cond = codegen_1._`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
            break;
          case "integer":
            cond = numCond(codegen_1._`!(${data} % 1) && !isNaN(${data})`);
            break;
          case "number":
            cond = numCond();
            break;
          default:
            return codegen_1._`typeof ${data} ${EQ} ${dataType}`;
        }
        return correct === DataType.Correct ? cond : codegen_1.not(cond);
        function numCond(_cond = codegen_1.nil) {
          return codegen_1.and(codegen_1._`typeof ${data} == "number"`, _cond, strictNums ? codegen_1._`isFinite(${data})` : codegen_1.nil);
        }
      }
      exports.checkDataType = checkDataType;
      function checkDataTypes(dataTypes, data, strictNums, correct) {
        if (dataTypes.length === 1) {
          return checkDataType(dataTypes[0], data, strictNums, correct);
        }
        let cond;
        const types = util_1.toHash(dataTypes);
        if (types.array && types.object) {
          const notObj = codegen_1._`typeof ${data} != "object"`;
          cond = types.null ? notObj : codegen_1._`!${data} || ${notObj}`;
          delete types.null;
          delete types.array;
          delete types.object;
        } else {
          cond = codegen_1.nil;
        }
        if (types.number)
          delete types.integer;
        for (const t3 in types)
          cond = codegen_1.and(cond, checkDataType(t3, data, strictNums, correct));
        return cond;
      }
      exports.checkDataTypes = checkDataTypes;
      var typeError = {
        message: ({ schema }) => `must be ${schema}`,
        params: ({ schema, schemaValue }) => typeof schema == "string" ? codegen_1._`{type: ${schema}}` : codegen_1._`{type: ${schemaValue}}`
      };
      function reportTypeError(it) {
        const cxt = getTypeErrorContext(it);
        errors_1.reportError(cxt, typeError);
      }
      exports.reportTypeError = reportTypeError;
      function getTypeErrorContext(it) {
        const { gen, data, schema } = it;
        const schemaCode = util_1.schemaRefOrVal(it, schema, "type");
        return {
          gen,
          keyword: "type",
          data,
          schema: schema.type,
          schemaCode,
          schemaValue: schemaCode,
          parentSchema: schema,
          params: {},
          it
        };
      }
    }
  });

  // ../node_modules/ajv/dist/compile/validate/defaults.js
  var require_defaults = __commonJS({
    "../node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.assignDefaults = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      function assignDefaults(it, ty) {
        const { properties, items } = it.schema;
        if (ty === "object" && properties) {
          for (const key in properties) {
            assignDefault(it, key, properties[key].default);
          }
        } else if (ty === "array" && Array.isArray(items)) {
          items.forEach((sch, i3) => assignDefault(it, i3, sch.default));
        }
      }
      exports.assignDefaults = assignDefaults;
      function assignDefault(it, prop, defaultValue) {
        const { gen, compositeRule, data, opts } = it;
        if (defaultValue === void 0)
          return;
        const childData = codegen_1._`${data}${codegen_1.getProperty(prop)}`;
        if (compositeRule) {
          util_1.checkStrictMode(it, `default is ignored for: ${childData}`);
          return;
        }
        let condition = codegen_1._`${childData} === undefined`;
        if (opts.useDefaults === "empty") {
          condition = codegen_1._`${condition} || ${childData} === null || ${childData} === ""`;
        }
        gen.if(condition, codegen_1._`${childData} = ${codegen_1.stringify(defaultValue)}`);
      }
    }
  });

  // ../node_modules/ajv/dist/vocabularies/code.js
  var require_code2 = __commonJS({
    "../node_modules/ajv/dist/vocabularies/code.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var names_1 = require_names();
      function checkReportMissingProp(cxt, prop) {
        const { gen, data, it } = cxt;
        gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
          cxt.setParams({ missingProperty: codegen_1._`${prop}` }, true);
          cxt.error();
        });
      }
      exports.checkReportMissingProp = checkReportMissingProp;
      function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
        return codegen_1.or(...properties.map((prop) => codegen_1.and(noPropertyInData(gen, data, prop, opts.ownProperties), codegen_1._`${missing} = ${prop}`)));
      }
      exports.checkMissingProp = checkMissingProp;
      function reportMissingProp(cxt, missing) {
        cxt.setParams({ missingProperty: missing }, true);
        cxt.error();
      }
      exports.reportMissingProp = reportMissingProp;
      function hasPropFunc(gen) {
        return gen.scopeValue("func", {
          // eslint-disable-next-line @typescript-eslint/unbound-method
          ref: Object.prototype.hasOwnProperty,
          code: codegen_1._`Object.prototype.hasOwnProperty`
        });
      }
      exports.hasPropFunc = hasPropFunc;
      function isOwnProperty(gen, data, property) {
        return codegen_1._`${hasPropFunc(gen)}.call(${data}, ${property})`;
      }
      exports.isOwnProperty = isOwnProperty;
      function propertyInData(gen, data, property, ownProperties) {
        const cond = codegen_1._`${data}${codegen_1.getProperty(property)} !== undefined`;
        return ownProperties ? codegen_1._`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
      }
      exports.propertyInData = propertyInData;
      function noPropertyInData(gen, data, property, ownProperties) {
        const cond = codegen_1._`${data}${codegen_1.getProperty(property)} === undefined`;
        return ownProperties ? codegen_1.or(cond, codegen_1.not(isOwnProperty(gen, data, property))) : cond;
      }
      exports.noPropertyInData = noPropertyInData;
      function allSchemaProperties(schemaMap) {
        return schemaMap ? Object.keys(schemaMap).filter((p3) => p3 !== "__proto__") : [];
      }
      exports.allSchemaProperties = allSchemaProperties;
      function schemaProperties(it, schemaMap) {
        return allSchemaProperties(schemaMap).filter((p3) => !util_1.alwaysValidSchema(it, schemaMap[p3]));
      }
      exports.schemaProperties = schemaProperties;
      function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
        const dataAndSchema = passSchema ? codegen_1._`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
        const valCxt = [
          [names_1.default.instancePath, codegen_1.strConcat(names_1.default.instancePath, errorPath)],
          [names_1.default.parentData, it.parentData],
          [names_1.default.parentDataProperty, it.parentDataProperty],
          [names_1.default.rootData, names_1.default.rootData]
        ];
        if (it.opts.dynamicRef)
          valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
        const args = codegen_1._`${dataAndSchema}, ${gen.object(...valCxt)}`;
        return context !== codegen_1.nil ? codegen_1._`${func}.call(${context}, ${args})` : codegen_1._`${func}(${args})`;
      }
      exports.callValidateCode = callValidateCode;
      function usePattern({ gen, it: { opts } }, pattern) {
        const u3 = opts.unicodeRegExp ? "u" : "";
        return gen.scopeValue("pattern", {
          key: pattern,
          ref: new RegExp(pattern, u3),
          code: codegen_1._`new RegExp(${pattern}, ${u3})`
        });
      }
      exports.usePattern = usePattern;
      function validateArray(cxt) {
        const { gen, data, keyword, it } = cxt;
        const valid = gen.name("valid");
        if (it.allErrors) {
          const validArr = gen.let("valid", true);
          validateItems(() => gen.assign(validArr, false));
          return validArr;
        }
        gen.var(valid, true);
        validateItems(() => gen.break());
        return valid;
        function validateItems(notValid) {
          const len = gen.const("len", codegen_1._`${data}.length`);
          gen.forRange("i", 0, len, (i3) => {
            cxt.subschema({
              keyword,
              dataProp: i3,
              dataPropType: util_1.Type.Num
            }, valid);
            gen.if(codegen_1.not(valid), notValid);
          });
        }
      }
      exports.validateArray = validateArray;
      function validateUnion(cxt) {
        const { gen, schema, keyword, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const alwaysValid = schema.some((sch) => util_1.alwaysValidSchema(it, sch));
        if (alwaysValid && !it.opts.unevaluated)
          return;
        const valid = gen.let("valid", false);
        const schValid = gen.name("_valid");
        gen.block(() => schema.forEach((_sch, i3) => {
          const schCxt = cxt.subschema({
            keyword,
            schemaProp: i3,
            compositeRule: true
          }, schValid);
          gen.assign(valid, codegen_1._`${valid} || ${schValid}`);
          const merged = cxt.mergeValidEvaluated(schCxt, schValid);
          if (!merged)
            gen.if(codegen_1.not(valid));
        }));
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      }
      exports.validateUnion = validateUnion;
    }
  });

  // ../node_modules/ajv/dist/compile/validate/keyword.js
  var require_keyword = __commonJS({
    "../node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
      var codegen_1 = require_codegen();
      var names_1 = require_names();
      var code_1 = require_code2();
      var errors_1 = require_errors();
      function macroKeywordCode(cxt, def) {
        const { gen, keyword, schema, parentSchema, it } = cxt;
        const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
        const schemaRef = useKeyword(gen, keyword, macroSchema);
        if (it.opts.validateSchema !== false)
          it.self.validateSchema(macroSchema, true);
        const valid = gen.name("valid");
        cxt.subschema({
          schema: macroSchema,
          schemaPath: codegen_1.nil,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`,
          topSchemaRef: schemaRef,
          compositeRule: true
        }, valid);
        cxt.pass(valid, () => cxt.error(true));
      }
      exports.macroKeywordCode = macroKeywordCode;
      function funcKeywordCode(cxt, def) {
        var _a;
        const { gen, keyword, schema, parentSchema, $data, it } = cxt;
        checkAsyncKeyword(it, def);
        const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
        const validateRef = useKeyword(gen, keyword, validate);
        const valid = gen.let("valid");
        cxt.block$data(valid, validateKeyword);
        cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
        function validateKeyword() {
          if (def.errors === false) {
            assignValid();
            if (def.modifying)
              modifyData(cxt);
            reportErrs(() => cxt.error());
          } else {
            const ruleErrs = def.async ? validateAsync() : validateSync();
            if (def.modifying)
              modifyData(cxt);
            reportErrs(() => addErrs(cxt, ruleErrs));
          }
        }
        function validateAsync() {
          const ruleErrs = gen.let("ruleErrs", null);
          gen.try(() => assignValid(codegen_1._`await `), (e2) => gen.assign(valid, false).if(codegen_1._`${e2} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1._`${e2}.errors`), () => gen.throw(e2)));
          return ruleErrs;
        }
        function validateSync() {
          const validateErrs = codegen_1._`${validateRef}.errors`;
          gen.assign(validateErrs, null);
          assignValid(codegen_1.nil);
          return validateErrs;
        }
        function assignValid(_await = def.async ? codegen_1._`await ` : codegen_1.nil) {
          const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
          const passSchema = !("compile" in def && !$data || def.schema === false);
          gen.assign(valid, codegen_1._`${_await}${code_1.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
        }
        function reportErrs(errors) {
          var _a2;
          gen.if(codegen_1.not((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
        }
      }
      exports.funcKeywordCode = funcKeywordCode;
      function modifyData(cxt) {
        const { gen, data, it } = cxt;
        gen.if(it.parentData, () => gen.assign(data, codegen_1._`${it.parentData}[${it.parentDataProperty}]`));
      }
      function addErrs(cxt, errs) {
        const { gen } = cxt;
        gen.if(codegen_1._`Array.isArray(${errs})`, () => {
          gen.assign(names_1.default.vErrors, codegen_1._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, codegen_1._`${names_1.default.vErrors}.length`);
          errors_1.extendErrors(cxt);
        }, () => cxt.error());
      }
      function checkAsyncKeyword({ schemaEnv }, def) {
        if (def.async && !schemaEnv.$async)
          throw new Error("async keyword in sync schema");
      }
      function useKeyword(gen, keyword, result) {
        if (result === void 0)
          throw new Error(`keyword "${keyword}" failed to compile`);
        return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: codegen_1.stringify(result) });
      }
      function validSchemaType(schema, schemaType, allowUndefined = false) {
        return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
      }
      exports.validSchemaType = validSchemaType;
      function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
        if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
          throw new Error("ajv implementation error");
        }
        const deps = def.dependencies;
        if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
          throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
        }
        if (def.validateSchema) {
          const valid = def.validateSchema(schema[keyword]);
          if (!valid) {
            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
            if (opts.validateSchema === "log")
              self2.logger.error(msg);
            else
              throw new Error(msg);
          }
        }
      }
      exports.validateKeywordUsage = validateKeywordUsage;
    }
  });

  // ../node_modules/ajv/dist/compile/validate/subschema.js
  var require_subschema = __commonJS({
    "../node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
        if (keyword !== void 0 && schema !== void 0) {
          throw new Error('both "keyword" and "schema" passed, only one allowed');
        }
        if (keyword !== void 0) {
          const sch = it.schema[keyword];
          return schemaProp === void 0 ? {
            schema: sch,
            schemaPath: codegen_1._`${it.schemaPath}${codegen_1.getProperty(keyword)}`,
            errSchemaPath: `${it.errSchemaPath}/${keyword}`
          } : {
            schema: sch[schemaProp],
            schemaPath: codegen_1._`${it.schemaPath}${codegen_1.getProperty(keyword)}${codegen_1.getProperty(schemaProp)}`,
            errSchemaPath: `${it.errSchemaPath}/${keyword}/${util_1.escapeFragment(schemaProp)}`
          };
        }
        if (schema !== void 0) {
          if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
          }
          return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath
          };
        }
        throw new Error('either "keyword" or "schema" must be passed');
      }
      exports.getSubschema = getSubschema;
      function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
        if (data !== void 0 && dataProp !== void 0) {
          throw new Error('both "data" and "dataProp" passed, only one allowed');
        }
        const { gen } = it;
        if (dataProp !== void 0) {
          const { errorPath, dataPathArr, opts } = it;
          const nextData = gen.let("data", codegen_1._`${it.data}${codegen_1.getProperty(dataProp)}`, true);
          dataContextProps(nextData);
          subschema.errorPath = codegen_1.str`${errorPath}${util_1.getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`;
          subschema.parentDataProperty = codegen_1._`${dataProp}`;
          subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
        }
        if (data !== void 0) {
          const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
          dataContextProps(nextData);
          if (propertyName !== void 0)
            subschema.propertyName = propertyName;
        }
        if (dataTypes)
          subschema.dataTypes = dataTypes;
        function dataContextProps(_nextData) {
          subschema.data = _nextData;
          subschema.dataLevel = it.dataLevel + 1;
          subschema.dataTypes = [];
          it.definedProperties = /* @__PURE__ */ new Set();
          subschema.parentData = it.data;
          subschema.dataNames = [...it.dataNames, _nextData];
        }
      }
      exports.extendSubschemaData = extendSubschemaData;
      function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
        if (compositeRule !== void 0)
          subschema.compositeRule = compositeRule;
        if (createErrors !== void 0)
          subschema.createErrors = createErrors;
        if (allErrors !== void 0)
          subschema.allErrors = allErrors;
        subschema.jtdDiscriminator = jtdDiscriminator;
        subschema.jtdMetadata = jtdMetadata;
      }
      exports.extendSubschemaMode = extendSubschemaMode;
    }
  });

  // ../node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "../node_modules/fast-deep-equal/index.js"(exports, module) {
      "use strict";
      module.exports = function equal(a3, b3) {
        if (a3 === b3)
          return true;
        if (a3 && b3 && typeof a3 == "object" && typeof b3 == "object") {
          if (a3.constructor !== b3.constructor)
            return false;
          var length, i3, keys4;
          if (Array.isArray(a3)) {
            length = a3.length;
            if (length != b3.length)
              return false;
            for (i3 = length; i3-- !== 0; )
              if (!equal(a3[i3], b3[i3]))
                return false;
            return true;
          }
          if (a3.constructor === RegExp)
            return a3.source === b3.source && a3.flags === b3.flags;
          if (a3.valueOf !== Object.prototype.valueOf)
            return a3.valueOf() === b3.valueOf();
          if (a3.toString !== Object.prototype.toString)
            return a3.toString() === b3.toString();
          keys4 = Object.keys(a3);
          length = keys4.length;
          if (length !== Object.keys(b3).length)
            return false;
          for (i3 = length; i3-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b3, keys4[i3]))
              return false;
          for (i3 = length; i3-- !== 0; ) {
            var key = keys4[i3];
            if (!equal(a3[key], b3[key]))
              return false;
          }
          return true;
        }
        return a3 !== a3 && b3 !== b3;
      };
    }
  });

  // ../node_modules/json-schema-traverse/index.js
  var require_json_schema_traverse = __commonJS({
    "../node_modules/json-schema-traverse/index.js"(exports, module) {
      "use strict";
      var traverse = module.exports = function(schema, opts, cb) {
        if (typeof opts == "function") {
          cb = opts;
          opts = {};
        }
        cb = opts.cb || cb;
        var pre = typeof cb == "function" ? cb : cb.pre || function() {
        };
        var post = cb.post || function() {
        };
        _traverse(opts, pre, post, schema, "", schema);
      };
      traverse.keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true,
        if: true,
        then: true,
        else: true
      };
      traverse.arrayKeywords = {
        items: true,
        allOf: true,
        anyOf: true,
        oneOf: true
      };
      traverse.propsKeywords = {
        $defs: true,
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true
      };
      traverse.skipKeywords = {
        default: true,
        enum: true,
        const: true,
        required: true,
        maximum: true,
        minimum: true,
        exclusiveMaximum: true,
        exclusiveMinimum: true,
        multipleOf: true,
        maxLength: true,
        minLength: true,
        pattern: true,
        format: true,
        maxItems: true,
        minItems: true,
        uniqueItems: true,
        maxProperties: true,
        minProperties: true
      };
      function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (schema && typeof schema == "object" && !Array.isArray(schema)) {
          pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
          for (var key in schema) {
            var sch = schema[key];
            if (Array.isArray(sch)) {
              if (key in traverse.arrayKeywords) {
                for (var i3 = 0; i3 < sch.length; i3++)
                  _traverse(opts, pre, post, sch[i3], jsonPtr + "/" + key + "/" + i3, rootSchema, jsonPtr, key, schema, i3);
              }
            } else if (key in traverse.propsKeywords) {
              if (sch && typeof sch == "object") {
                for (var prop in sch)
                  _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
              }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
              _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
            }
          }
          post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        }
      }
      function escapeJsonPtr(str2) {
        return str2.replace(/~/g, "~0").replace(/\//g, "~1");
      }
    }
  });

  // ../node_modules/uri-js/dist/es5/uri.all.js
  var require_uri_all = __commonJS({
    "../node_modules/uri-js/dist/es5/uri.all.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
      })(exports, function(exports2) {
        "use strict";
        function merge4() {
          for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
            sets[_key] = arguments[_key];
          }
          if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1);
            var xl = sets.length - 1;
            for (var x3 = 1; x3 < xl; ++x3) {
              sets[x3] = sets[x3].slice(1, -1);
            }
            sets[xl] = sets[xl].slice(1);
            return sets.join("");
          } else {
            return sets[0];
          }
        }
        function subexp(str2) {
          return "(?:" + str2 + ")";
        }
        function typeOf(o3) {
          return o3 === void 0 ? "undefined" : o3 === null ? "null" : Object.prototype.toString.call(o3).split(" ").pop().split("]").shift().toLowerCase();
        }
        function toUpperCase(str2) {
          return str2.toUpperCase();
        }
        function toArray(obj) {
          return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
        }
        function assign4(target, source) {
          var obj = target;
          if (source) {
            for (var key in source) {
              obj[key] = source[key];
            }
          }
          return obj;
        }
        function buildExps(isIRI2) {
          var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge4(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge4(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge4(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge4(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge4(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge4(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge4(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge4(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge4(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge4("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
          return {
            NOT_SCHEME: new RegExp(merge4("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(merge4("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_HOST: new RegExp(merge4("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_PATH: new RegExp(merge4("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_PATH_NOSCHEME: new RegExp(merge4("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_QUERY: new RegExp(merge4("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
            NOT_FRAGMENT: new RegExp(merge4("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
            ESCAPE: new RegExp(merge4("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
            OTHER_CHARS: new RegExp(merge4("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
            PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
            IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
            IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
            //RFC 6874, with relaxed parsing rules
          };
        }
        var URI_PROTOCOL = buildExps(false);
        var IRI_PROTOCOL = buildExps(true);
        var slicedToArray = function() {
          function sliceIterator(arr, i3) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i3 && _arr.length === i3)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i3) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i3);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var toConsumableArray = function(arr) {
          if (Array.isArray(arr)) {
            for (var i3 = 0, arr2 = Array(arr.length); i3 < arr.length; i3++)
              arr2[i3] = arr[i3];
            return arr2;
          } else {
            return Array.from(arr);
          }
        };
        var maxInt = 2147483647;
        var base = 36;
        var tMin = 1;
        var tMax = 26;
        var skew = 38;
        var damp = 700;
        var initialBias = 72;
        var initialN = 128;
        var delimiter = "-";
        var regexPunycode = /^xn--/;
        var regexNonASCII = /[^\0-\x7E]/;
        var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
        var errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        };
        var baseMinusTMin = base - tMin;
        var floor = Math.floor;
        var stringFromCharCode = String.fromCharCode;
        function error$1(type) {
          throw new RangeError(errors[type]);
        }
        function map4(array, fn2) {
          var result = [];
          var length = array.length;
          while (length--) {
            result[length] = fn2(array[length]);
          }
          return result;
        }
        function mapDomain(string, fn2) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map4(labels, fn2).join(".");
          return result + encoded;
        }
        function ucs2decode(string) {
          var output = [];
          var counter = 0;
          var length = string.length;
          while (counter < length) {
            var value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              var extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        var ucs2encode = function ucs2encode2(array) {
          return String.fromCodePoint.apply(String, toConsumableArray(array));
        };
        var basicToDigit = function basicToDigit2(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        };
        var digitToBasic = function digitToBasic2(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        };
        var adapt = function adapt2(delta, numPoints, firstTime) {
          var k3 = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (
            ;
            /* no initialization */
            delta > baseMinusTMin * tMax >> 1;
            k3 += base
          ) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k3 + (baseMinusTMin + 1) * delta / (delta + skew));
        };
        var decode = function decode2(input) {
          var output = [];
          var inputLength = input.length;
          var i3 = 0;
          var n3 = initialN;
          var bias = initialBias;
          var basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (var j3 = 0; j3 < basic; ++j3) {
            if (input.charCodeAt(j3) >= 128) {
              error$1("not-basic");
            }
            output.push(input.charCodeAt(j3));
          }
          for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            var oldi = i3;
            for (
              var w3 = 1, k3 = base;
              ;
              /* no condition */
              k3 += base
            ) {
              if (index >= inputLength) {
                error$1("invalid-input");
              }
              var digit = basicToDigit(input.charCodeAt(index++));
              if (digit >= base || digit > floor((maxInt - i3) / w3)) {
                error$1("overflow");
              }
              i3 += digit * w3;
              var t3 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
              if (digit < t3) {
                break;
              }
              var baseMinusT = base - t3;
              if (w3 > floor(maxInt / baseMinusT)) {
                error$1("overflow");
              }
              w3 *= baseMinusT;
            }
            var out = output.length + 1;
            bias = adapt(i3 - oldi, out, oldi == 0);
            if (floor(i3 / out) > maxInt - n3) {
              error$1("overflow");
            }
            n3 += floor(i3 / out);
            i3 %= out;
            output.splice(i3++, 0, n3);
          }
          return String.fromCodePoint.apply(String, output);
        };
        var encode = function encode2(input) {
          var output = [];
          input = ucs2decode(input);
          var inputLength = input.length;
          var n3 = initialN;
          var delta = 0;
          var bias = initialBias;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _currentValue2 = _step.value;
              if (_currentValue2 < 128) {
                output.push(stringFromCharCode(_currentValue2));
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          var basicLength = output.length;
          var handledCPCount = basicLength;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            var m3 = maxInt;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var currentValue = _step2.value;
                if (currentValue >= n3 && currentValue < m3) {
                  m3 = currentValue;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
            var handledCPCountPlusOne = handledCPCount + 1;
            if (m3 - n3 > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error$1("overflow");
            }
            delta += (m3 - n3) * handledCPCountPlusOne;
            n3 = m3;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = void 0;
            try {
              for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _currentValue = _step3.value;
                if (_currentValue < n3 && ++delta > maxInt) {
                  error$1("overflow");
                }
                if (_currentValue == n3) {
                  var q3 = delta;
                  for (
                    var k3 = base;
                    ;
                    /* no condition */
                    k3 += base
                  ) {
                    var t3 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
                    if (q3 < t3) {
                      break;
                    }
                    var qMinusT = q3 - t3;
                    var baseMinusT = base - t3;
                    output.push(stringFromCharCode(digitToBasic(t3 + qMinusT % baseMinusT, 0)));
                    q3 = floor(qMinusT / baseMinusT);
                  }
                  output.push(stringFromCharCode(digitToBasic(q3, 0)));
                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                  delta = 0;
                  ++handledCPCount;
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
            ++delta;
            ++n3;
          }
          return output.join("");
        };
        var toUnicode = function toUnicode2(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        };
        var toASCII = function toASCII2(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
          });
        };
        var punycode = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          "version": "2.1.0",
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode,
          "encode": encode,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        var SCHEMES = {};
        function pctEncChar(chr) {
          var c3 = chr.charCodeAt(0);
          var e2 = void 0;
          if (c3 < 16)
            e2 = "%0" + c3.toString(16).toUpperCase();
          else if (c3 < 128)
            e2 = "%" + c3.toString(16).toUpperCase();
          else if (c3 < 2048)
            e2 = "%" + (c3 >> 6 | 192).toString(16).toUpperCase() + "%" + (c3 & 63 | 128).toString(16).toUpperCase();
          else
            e2 = "%" + (c3 >> 12 | 224).toString(16).toUpperCase() + "%" + (c3 >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c3 & 63 | 128).toString(16).toUpperCase();
          return e2;
        }
        function pctDecChars(str2) {
          var newStr = "";
          var i3 = 0;
          var il = str2.length;
          while (i3 < il) {
            var c3 = parseInt(str2.substr(i3 + 1, 2), 16);
            if (c3 < 128) {
              newStr += String.fromCharCode(c3);
              i3 += 3;
            } else if (c3 >= 194 && c3 < 224) {
              if (il - i3 >= 6) {
                var c22 = parseInt(str2.substr(i3 + 4, 2), 16);
                newStr += String.fromCharCode((c3 & 31) << 6 | c22 & 63);
              } else {
                newStr += str2.substr(i3, 6);
              }
              i3 += 6;
            } else if (c3 >= 224) {
              if (il - i3 >= 9) {
                var _c = parseInt(str2.substr(i3 + 4, 2), 16);
                var c32 = parseInt(str2.substr(i3 + 7, 2), 16);
                newStr += String.fromCharCode((c3 & 15) << 12 | (_c & 63) << 6 | c32 & 63);
              } else {
                newStr += str2.substr(i3, 9);
              }
              i3 += 9;
            } else {
              newStr += str2.substr(i3, 3);
              i3 += 3;
            }
          }
          return newStr;
        }
        function _normalizeComponentEncoding(components, protocol) {
          function decodeUnreserved2(str2) {
            var decStr = pctDecChars(str2);
            return !decStr.match(protocol.UNRESERVED) ? str2 : decStr;
          }
          if (components.scheme)
            components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
          if (components.userinfo !== void 0)
            components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.host !== void 0)
            components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.path !== void 0)
            components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.query !== void 0)
            components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.fragment !== void 0)
            components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          return components;
        }
        function _stripLeadingZeros(str2) {
          return str2.replace(/^0*(.*)/, "$1") || "0";
        }
        function _normalizeIPv4(host, protocol) {
          var matches = host.match(protocol.IPV4ADDRESS) || [];
          var _matches = slicedToArray(matches, 2), address = _matches[1];
          if (address) {
            return address.split(".").map(_stripLeadingZeros).join(".");
          } else {
            return host;
          }
        }
        function _normalizeIPv6(host, protocol) {
          var matches = host.match(protocol.IPV6ADDRESS) || [];
          var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
          if (address) {
            var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
            var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
            var lastFields = last.split(":").map(_stripLeadingZeros);
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
            var fieldCount = isLastFieldIPv4Address ? 7 : 8;
            var lastFieldsStart = lastFields.length - fieldCount;
            var fields = Array(fieldCount);
            for (var x3 = 0; x3 < fieldCount; ++x3) {
              fields[x3] = firstFields[x3] || lastFields[lastFieldsStart + x3] || "";
            }
            if (isLastFieldIPv4Address) {
              fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
            }
            var allZeroFields = fields.reduce(function(acc, field, index) {
              if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                  lastLongest.length++;
                } else {
                  acc.push({ index, length: 1 });
                }
              }
              return acc;
            }, []);
            var longestZeroFields = allZeroFields.sort(function(a3, b3) {
              return b3.length - a3.length;
            })[0];
            var newHost = void 0;
            if (longestZeroFields && longestZeroFields.length > 1) {
              var newFirst = fields.slice(0, longestZeroFields.index);
              var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
              newHost = newFirst.join(":") + "::" + newLast.join(":");
            } else {
              newHost = fields.join(":");
            }
            if (zone) {
              newHost += "%" + zone;
            }
            return newHost;
          } else {
            return host;
          }
        }
        var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
        var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
        function parse(uriString) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var components = {};
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
          if (options.reference === "suffix")
            uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
          var matches = uriString.match(URI_PARSE);
          if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
              components.scheme = matches[1];
              components.userinfo = matches[3];
              components.host = matches[4];
              components.port = parseInt(matches[5], 10);
              components.path = matches[6] || "";
              components.query = matches[7];
              components.fragment = matches[8];
              if (isNaN(components.port)) {
                components.port = matches[5];
              }
            } else {
              components.scheme = matches[1] || void 0;
              components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
              components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
              components.port = parseInt(matches[5], 10);
              components.path = matches[6] || "";
              components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
              components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
              if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
              }
            }
            if (components.host) {
              components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
            }
            if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
              components.reference = "same-document";
            } else if (components.scheme === void 0) {
              components.reference = "relative";
            } else if (components.fragment === void 0) {
              components.reference = "absolute";
            } else {
              components.reference = "uri";
            }
            if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
              components.error = components.error || "URI is not a " + options.reference + " reference.";
            }
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
              if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                try {
                  components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e2) {
                  components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e2;
                }
              }
              _normalizeComponentEncoding(components, URI_PROTOCOL);
            } else {
              _normalizeComponentEncoding(components, protocol);
            }
            if (schemeHandler && schemeHandler.parse) {
              schemeHandler.parse(components, options);
            }
          } else {
            components.error = components.error || "URI can not be parsed.";
          }
          return components;
        }
        function _recomposeAuthority(components, options) {
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
          var uriTokens = [];
          if (components.userinfo !== void 0) {
            uriTokens.push(components.userinfo);
            uriTokens.push("@");
          }
          if (components.host !== void 0) {
            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_3, $1, $2) {
              return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
            }));
          }
          if (typeof components.port === "number" || typeof components.port === "string") {
            uriTokens.push(":");
            uriTokens.push(String(components.port));
          }
          return uriTokens.length ? uriTokens.join("") : void 0;
        }
        var RDS1 = /^\.\.?\//;
        var RDS2 = /^\/\.(\/|$)/;
        var RDS3 = /^\/\.\.(\/|$)/;
        var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
        function removeDotSegments(input) {
          var output = [];
          while (input.length) {
            if (input.match(RDS1)) {
              input = input.replace(RDS1, "");
            } else if (input.match(RDS2)) {
              input = input.replace(RDS2, "/");
            } else if (input.match(RDS3)) {
              input = input.replace(RDS3, "/");
              output.pop();
            } else if (input === "." || input === "..") {
              input = "";
            } else {
              var im = input.match(RDS5);
              if (im) {
                var s3 = im[0];
                input = input.slice(s3.length);
                output.push(s3);
              } else {
                throw new Error("Unexpected dot segment condition");
              }
            }
          }
          return output.join("");
        }
        function serialize(components) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
          var uriTokens = [];
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (schemeHandler && schemeHandler.serialize)
            schemeHandler.serialize(components, options);
          if (components.host) {
            if (protocol.IPV6ADDRESS.test(components.host)) {
            } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
              try {
                components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
              } catch (e2) {
                components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e2;
              }
            }
          }
          _normalizeComponentEncoding(components, protocol);
          if (options.reference !== "suffix" && components.scheme) {
            uriTokens.push(components.scheme);
            uriTokens.push(":");
          }
          var authority = _recomposeAuthority(components, options);
          if (authority !== void 0) {
            if (options.reference !== "suffix") {
              uriTokens.push("//");
            }
            uriTokens.push(authority);
            if (components.path && components.path.charAt(0) !== "/") {
              uriTokens.push("/");
            }
          }
          if (components.path !== void 0) {
            var s3 = components.path;
            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
              s3 = removeDotSegments(s3);
            }
            if (authority === void 0) {
              s3 = s3.replace(/^\/\//, "/%2F");
            }
            uriTokens.push(s3);
          }
          if (components.query !== void 0) {
            uriTokens.push("?");
            uriTokens.push(components.query);
          }
          if (components.fragment !== void 0) {
            uriTokens.push("#");
            uriTokens.push(components.fragment);
          }
          return uriTokens.join("");
        }
        function resolveComponents(base2, relative) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var skipNormalization = arguments[3];
          var target = {};
          if (!skipNormalization) {
            base2 = parse(serialize(base2, options), options);
            relative = parse(serialize(relative, options), options);
          }
          options = options || {};
          if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
              target.userinfo = relative.userinfo;
              target.host = relative.host;
              target.port = relative.port;
              target.path = removeDotSegments(relative.path || "");
              target.query = relative.query;
            } else {
              if (!relative.path) {
                target.path = base2.path;
                if (relative.query !== void 0) {
                  target.query = relative.query;
                } else {
                  target.query = base2.query;
                }
              } else {
                if (relative.path.charAt(0) === "/") {
                  target.path = removeDotSegments(relative.path);
                } else {
                  if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                    target.path = "/" + relative.path;
                  } else if (!base2.path) {
                    target.path = relative.path;
                  } else {
                    target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                  }
                  target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
              }
              target.userinfo = base2.userinfo;
              target.host = base2.host;
              target.port = base2.port;
            }
            target.scheme = base2.scheme;
          }
          target.fragment = relative.fragment;
          return target;
        }
        function resolve(baseURI, relativeURI, options) {
          var schemelessOptions = assign4({ scheme: "null" }, options);
          return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
        }
        function normalize(uri, options) {
          if (typeof uri === "string") {
            uri = serialize(parse(uri, options), options);
          } else if (typeOf(uri) === "object") {
            uri = parse(serialize(uri, options), options);
          }
          return uri;
        }
        function equal(uriA, uriB, options) {
          if (typeof uriA === "string") {
            uriA = serialize(parse(uriA, options), options);
          } else if (typeOf(uriA) === "object") {
            uriA = serialize(uriA, options);
          }
          if (typeof uriB === "string") {
            uriB = serialize(parse(uriB, options), options);
          } else if (typeOf(uriB) === "object") {
            uriB = serialize(uriB, options);
          }
          return uriA === uriB;
        }
        function escapeComponent(str2, options) {
          return str2 && str2.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
        }
        function unescapeComponent(str2, options) {
          return str2 && str2.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
        }
        var handler = {
          scheme: "http",
          domainHost: true,
          parse: function parse2(components, options) {
            if (!components.host) {
              components.error = components.error || "HTTP URIs must have a host.";
            }
            return components;
          },
          serialize: function serialize2(components, options) {
            var secure = String(components.scheme).toLowerCase() === "https";
            if (components.port === (secure ? 443 : 80) || components.port === "") {
              components.port = void 0;
            }
            if (!components.path) {
              components.path = "/";
            }
            return components;
          }
        };
        var handler$1 = {
          scheme: "https",
          domainHost: handler.domainHost,
          parse: handler.parse,
          serialize: handler.serialize
        };
        function isSecure(wsComponents) {
          return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
        }
        var handler$2 = {
          scheme: "ws",
          domainHost: true,
          parse: function parse2(components, options) {
            var wsComponents = components;
            wsComponents.secure = isSecure(wsComponents);
            wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
            wsComponents.path = void 0;
            wsComponents.query = void 0;
            return wsComponents;
          },
          serialize: function serialize2(wsComponents, options) {
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
              wsComponents.port = void 0;
            }
            if (typeof wsComponents.secure === "boolean") {
              wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
              wsComponents.secure = void 0;
            }
            if (wsComponents.resourceName) {
              var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
              wsComponents.path = path && path !== "/" ? path : void 0;
              wsComponents.query = query;
              wsComponents.resourceName = void 0;
            }
            wsComponents.fragment = void 0;
            return wsComponents;
          }
        };
        var handler$3 = {
          scheme: "wss",
          domainHost: handler$2.domainHost,
          parse: handler$2.parse,
          serialize: handler$2.serialize
        };
        var O3 = {};
        var isIRI = true;
        var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
        var HEXDIG$$ = "[0-9A-Fa-f]";
        var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
        var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
        var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
        var VCHAR$$ = merge4(QTEXT$$, '[\\"\\\\]');
        var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
        var UNRESERVED = new RegExp(UNRESERVED$$, "g");
        var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
        var NOT_LOCAL_PART = new RegExp(merge4("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
        var NOT_HFNAME = new RegExp(merge4("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
        var NOT_HFVALUE = NOT_HFNAME;
        function decodeUnreserved(str2) {
          var decStr = pctDecChars(str2);
          return !decStr.match(UNRESERVED) ? str2 : decStr;
        }
        var handler$4 = {
          scheme: "mailto",
          parse: function parse$$1(components, options) {
            var mailtoComponents = components;
            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
            mailtoComponents.path = void 0;
            if (mailtoComponents.query) {
              var unknownHeaders = false;
              var headers = {};
              var hfields = mailtoComponents.query.split("&");
              for (var x3 = 0, xl = hfields.length; x3 < xl; ++x3) {
                var hfield = hfields[x3].split("=");
                switch (hfield[0]) {
                  case "to":
                    var toAddrs = hfield[1].split(",");
                    for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                      to.push(toAddrs[_x]);
                    }
                    break;
                  case "subject":
                    mailtoComponents.subject = unescapeComponent(hfield[1], options);
                    break;
                  case "body":
                    mailtoComponents.body = unescapeComponent(hfield[1], options);
                    break;
                  default:
                    unknownHeaders = true;
                    headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                    break;
                }
              }
              if (unknownHeaders)
                mailtoComponents.headers = headers;
            }
            mailtoComponents.query = void 0;
            for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
              var addr = to[_x2].split("@");
              addr[0] = unescapeComponent(addr[0]);
              if (!options.unicodeSupport) {
                try {
                  addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e2) {
                  mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e2;
                }
              } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
              }
              to[_x2] = addr.join("@");
            }
            return mailtoComponents;
          },
          serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents;
            var to = toArray(mailtoComponents.to);
            if (to) {
              for (var x3 = 0, xl = to.length; x3 < xl; ++x3) {
                var toAddr = String(to[x3]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                try {
                  domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e2) {
                  components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e2;
                }
                to[x3] = localPart + "@" + domain;
              }
              components.path = to.join(",");
            }
            var headers = mailtoComponents.headers = mailtoComponents.headers || {};
            if (mailtoComponents.subject)
              headers["subject"] = mailtoComponents.subject;
            if (mailtoComponents.body)
              headers["body"] = mailtoComponents.body;
            var fields = [];
            for (var name in headers) {
              if (headers[name] !== O3[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
              }
            }
            if (fields.length) {
              components.query = fields.join("&");
            }
            return components;
          }
        };
        var URN_PARSE = /^([^\:]+)\:(.*)/;
        var handler$5 = {
          scheme: "urn",
          parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE);
            var urnComponents = components;
            if (matches) {
              var scheme = options.scheme || urnComponents.scheme || "urn";
              var nid = matches[1].toLowerCase();
              var nss = matches[2];
              var urnScheme = scheme + ":" + (options.nid || nid);
              var schemeHandler = SCHEMES[urnScheme];
              urnComponents.nid = nid;
              urnComponents.nss = nss;
              urnComponents.path = void 0;
              if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
              }
            } else {
              urnComponents.error = urnComponents.error || "URN can not be parsed.";
            }
            return urnComponents;
          },
          serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = urnComponents.nid;
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) {
              urnComponents = schemeHandler.serialize(urnComponents, options);
            }
            var uriComponents = urnComponents;
            var nss = urnComponents.nss;
            uriComponents.path = (nid || options.nid) + ":" + nss;
            return uriComponents;
          }
        };
        var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
        var handler$6 = {
          scheme: "urn:uuid",
          parse: function parse2(urnComponents, options) {
            var uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = void 0;
            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
              uuidComponents.error = uuidComponents.error || "UUID is not valid.";
            }
            return uuidComponents;
          },
          serialize: function serialize2(uuidComponents, options) {
            var urnComponents = uuidComponents;
            urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
            return urnComponents;
          }
        };
        SCHEMES[handler.scheme] = handler;
        SCHEMES[handler$1.scheme] = handler$1;
        SCHEMES[handler$2.scheme] = handler$2;
        SCHEMES[handler$3.scheme] = handler$3;
        SCHEMES[handler$4.scheme] = handler$4;
        SCHEMES[handler$5.scheme] = handler$5;
        SCHEMES[handler$6.scheme] = handler$6;
        exports2.SCHEMES = SCHEMES;
        exports2.pctEncChar = pctEncChar;
        exports2.pctDecChars = pctDecChars;
        exports2.parse = parse;
        exports2.removeDotSegments = removeDotSegments;
        exports2.serialize = serialize;
        exports2.resolveComponents = resolveComponents;
        exports2.resolve = resolve;
        exports2.normalize = normalize;
        exports2.equal = equal;
        exports2.escapeComponent = escapeComponent;
        exports2.unescapeComponent = unescapeComponent;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../node_modules/ajv/dist/compile/resolve.js
  var require_resolve = __commonJS({
    "../node_modules/ajv/dist/compile/resolve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
      var util_1 = require_util();
      var equal = require_fast_deep_equal();
      var traverse = require_json_schema_traverse();
      var URI = require_uri_all();
      var SIMPLE_INLINED = /* @__PURE__ */ new Set([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum",
        "const"
      ]);
      function inlineRef(schema, limit = true) {
        if (typeof schema == "boolean")
          return true;
        if (limit === true)
          return !hasRef(schema);
        if (!limit)
          return false;
        return countKeys(schema) <= limit;
      }
      exports.inlineRef = inlineRef;
      var REF_KEYWORDS = /* @__PURE__ */ new Set([
        "$ref",
        "$recursiveRef",
        "$recursiveAnchor",
        "$dynamicRef",
        "$dynamicAnchor"
      ]);
      function hasRef(schema) {
        for (const key in schema) {
          if (REF_KEYWORDS.has(key))
            return true;
          const sch = schema[key];
          if (Array.isArray(sch) && sch.some(hasRef))
            return true;
          if (typeof sch == "object" && hasRef(sch))
            return true;
        }
        return false;
      }
      function countKeys(schema) {
        let count = 0;
        for (const key in schema) {
          if (key === "$ref")
            return Infinity;
          count++;
          if (SIMPLE_INLINED.has(key))
            continue;
          if (typeof schema[key] == "object") {
            util_1.eachItem(schema[key], (sch) => count += countKeys(sch));
          }
          if (count === Infinity)
            return Infinity;
        }
        return count;
      }
      function getFullPath(id = "", normalize) {
        if (normalize !== false)
          id = normalizeId(id);
        const p3 = URI.parse(id);
        return _getFullPath(p3);
      }
      exports.getFullPath = getFullPath;
      function _getFullPath(p3) {
        return URI.serialize(p3).split("#")[0] + "#";
      }
      exports._getFullPath = _getFullPath;
      var TRAILING_SLASH_HASH = /#\/?$/;
      function normalizeId(id) {
        return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
      }
      exports.normalizeId = normalizeId;
      function resolveUrl(baseId, id) {
        id = normalizeId(id);
        return URI.resolve(baseId, id);
      }
      exports.resolveUrl = resolveUrl;
      var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
      function getSchemaRefs(schema) {
        if (typeof schema == "boolean")
          return {};
        const schemaId = normalizeId(schema.$id);
        const baseIds = { "": schemaId };
        const pathPrefix = getFullPath(schemaId, false);
        const localRefs = {};
        const schemaRefs = /* @__PURE__ */ new Set();
        traverse(schema, { allKeys: true }, (sch, jsonPtr, _3, parentJsonPtr) => {
          if (parentJsonPtr === void 0)
            return;
          const fullPath = pathPrefix + jsonPtr;
          let baseId = baseIds[parentJsonPtr];
          if (typeof sch.$id == "string")
            baseId = addRef.call(this, sch.$id);
          addAnchor.call(this, sch.$anchor);
          addAnchor.call(this, sch.$dynamicAnchor);
          baseIds[jsonPtr] = baseId;
          function addRef(ref) {
            ref = normalizeId(baseId ? URI.resolve(baseId, ref) : ref);
            if (schemaRefs.has(ref))
              throw ambiguos(ref);
            schemaRefs.add(ref);
            let schOrRef = this.refs[ref];
            if (typeof schOrRef == "string")
              schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
              checkAmbiguosRef(sch, schOrRef.schema, ref);
            } else if (ref !== normalizeId(fullPath)) {
              if (ref[0] === "#") {
                checkAmbiguosRef(sch, localRefs[ref], ref);
                localRefs[ref] = sch;
              } else {
                this.refs[ref] = fullPath;
              }
            }
            return ref;
          }
          function addAnchor(anchor) {
            if (typeof anchor == "string") {
              if (!ANCHOR.test(anchor))
                throw new Error(`invalid anchor "${anchor}"`);
              addRef.call(this, `#${anchor}`);
            }
          }
        });
        return localRefs;
        function checkAmbiguosRef(sch1, sch2, ref) {
          if (sch2 !== void 0 && !equal(sch1, sch2))
            throw ambiguos(ref);
        }
        function ambiguos(ref) {
          return new Error(`reference "${ref}" resolves to more than one schema`);
        }
      }
      exports.getSchemaRefs = getSchemaRefs;
    }
  });

  // ../node_modules/ajv/dist/compile/validate/index.js
  var require_validate = __commonJS({
    "../node_modules/ajv/dist/compile/validate/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
      var boolSchema_1 = require_boolSchema();
      var dataType_1 = require_dataType();
      var applicability_1 = require_applicability();
      var dataType_2 = require_dataType();
      var defaults_1 = require_defaults();
      var keyword_1 = require_keyword();
      var subschema_1 = require_subschema();
      var codegen_1 = require_codegen();
      var names_1 = require_names();
      var resolve_1 = require_resolve();
      var util_1 = require_util();
      var errors_1 = require_errors();
      function validateFunctionCode(it) {
        if (isSchemaObj(it)) {
          checkKeywords(it);
          if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
          }
        }
        validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));
      }
      exports.validateFunctionCode = validateFunctionCode;
      function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
        if (opts.code.es5) {
          gen.func(validateName, codegen_1._`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
            gen.code(codegen_1._`"use strict"; ${funcSourceUrl(schema, opts)}`);
            destructureValCxtES5(gen, opts);
            gen.code(body);
          });
        } else {
          gen.func(validateName, codegen_1._`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
        }
      }
      function destructureValCxt(opts) {
        return codegen_1._`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen_1._`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
      }
      function destructureValCxtES5(gen, opts) {
        gen.if(names_1.default.valCxt, () => {
          gen.var(names_1.default.instancePath, codegen_1._`${names_1.default.valCxt}.${names_1.default.instancePath}`);
          gen.var(names_1.default.parentData, codegen_1._`${names_1.default.valCxt}.${names_1.default.parentData}`);
          gen.var(names_1.default.parentDataProperty, codegen_1._`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
          gen.var(names_1.default.rootData, codegen_1._`${names_1.default.valCxt}.${names_1.default.rootData}`);
          if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, codegen_1._`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
        }, () => {
          gen.var(names_1.default.instancePath, codegen_1._`""`);
          gen.var(names_1.default.parentData, codegen_1._`undefined`);
          gen.var(names_1.default.parentDataProperty, codegen_1._`undefined`);
          gen.var(names_1.default.rootData, names_1.default.data);
          if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, codegen_1._`{}`);
        });
      }
      function topSchemaObjCode(it) {
        const { schema, opts, gen } = it;
        validateFunction(it, () => {
          if (opts.$comment && schema.$comment)
            commentKeyword(it);
          checkNoDefault(it);
          gen.let(names_1.default.vErrors, null);
          gen.let(names_1.default.errors, 0);
          if (opts.unevaluated)
            resetEvaluated(it);
          typeAndKeywords(it);
          returnResults(it);
        });
        return;
      }
      function resetEvaluated(it) {
        const { gen, validateName } = it;
        it.evaluated = gen.const("evaluated", codegen_1._`${validateName}.evaluated`);
        gen.if(codegen_1._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1._`${it.evaluated}.props`, codegen_1._`undefined`));
        gen.if(codegen_1._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1._`${it.evaluated}.items`, codegen_1._`undefined`));
      }
      function funcSourceUrl(schema, opts) {
        return typeof schema == "object" && schema.$id && (opts.code.source || opts.code.process) ? codegen_1._`/*# sourceURL=${schema.$id} */` : codegen_1.nil;
      }
      function subschemaCode(it, valid) {
        if (isSchemaObj(it)) {
          checkKeywords(it);
          if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
          }
        }
        boolSchema_1.boolOrEmptySchema(it, valid);
      }
      function schemaCxtHasRules({ schema, self: self2 }) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (self2.RULES.all[key])
            return true;
        return false;
      }
      function isSchemaObj(it) {
        return typeof it.schema != "boolean";
      }
      function subSchemaObjCode(it, valid) {
        const { schema, gen, opts } = it;
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        updateContext(it);
        checkAsyncSchema(it);
        const errsCount = gen.const("_errs", names_1.default.errors);
        typeAndKeywords(it, errsCount);
        gen.var(valid, codegen_1._`${errsCount} === ${names_1.default.errors}`);
      }
      function checkKeywords(it) {
        util_1.checkUnknownRules(it);
        checkRefsAndKeywords(it);
      }
      function typeAndKeywords(it, errsCount) {
        if (it.opts.jtd)
          return schemaKeywords(it, [], false, errsCount);
        const types = dataType_1.getSchemaTypes(it.schema);
        const checkedTypes = dataType_1.coerceAndCheckDataType(it, types);
        schemaKeywords(it, types, !checkedTypes, errsCount);
      }
      function checkRefsAndKeywords(it) {
        const { schema, errSchemaPath, opts, self: self2 } = it;
        if (schema.$ref && opts.ignoreKeywordsWithRef && util_1.schemaHasRulesButRef(schema, self2.RULES)) {
          self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
        }
      }
      function checkNoDefault(it) {
        const { schema, opts } = it;
        if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
          util_1.checkStrictMode(it, "default is ignored in the schema root");
        }
      }
      function updateContext(it) {
        if (it.schema.$id)
          it.baseId = resolve_1.resolveUrl(it.baseId, it.schema.$id);
      }
      function checkAsyncSchema(it) {
        if (it.schema.$async && !it.schemaEnv.$async)
          throw new Error("async schema in sync schema");
      }
      function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
        const msg = schema.$comment;
        if (opts.$comment === true) {
          gen.code(codegen_1._`${names_1.default.self}.logger.log(${msg})`);
        } else if (typeof opts.$comment == "function") {
          const schemaPath = codegen_1.str`${errSchemaPath}/$comment`;
          const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
          gen.code(codegen_1._`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
        }
      }
      function returnResults(it) {
        const { gen, schemaEnv, validateName, ValidationError, opts } = it;
        if (schemaEnv.$async) {
          gen.if(codegen_1._`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw(codegen_1._`new ${ValidationError}(${names_1.default.vErrors})`));
        } else {
          gen.assign(codegen_1._`${validateName}.errors`, names_1.default.vErrors);
          if (opts.unevaluated)
            assignEvaluated(it);
          gen.return(codegen_1._`${names_1.default.errors} === 0`);
        }
      }
      function assignEvaluated({ gen, evaluated, props, items }) {
        if (props instanceof codegen_1.Name)
          gen.assign(codegen_1._`${evaluated}.props`, props);
        if (items instanceof codegen_1.Name)
          gen.assign(codegen_1._`${evaluated}.items`, items);
      }
      function schemaKeywords(it, types, typeErrors, errsCount) {
        const { gen, schema, data, allErrors, opts, self: self2 } = it;
        const { RULES } = self2;
        if (schema.$ref && (opts.ignoreKeywordsWithRef || !util_1.schemaHasRulesButRef(schema, RULES))) {
          gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
          return;
        }
        if (!opts.jtd)
          checkStrictTypes(it, types);
        gen.block(() => {
          for (const group of RULES.rules)
            groupKeywords(group);
          groupKeywords(RULES.post);
        });
        function groupKeywords(group) {
          if (!applicability_1.shouldUseGroup(schema, group))
            return;
          if (group.type) {
            gen.if(dataType_2.checkDataType(group.type, data, opts.strictNumbers));
            iterateKeywords(it, group);
            if (types.length === 1 && types[0] === group.type && typeErrors) {
              gen.else();
              dataType_2.reportTypeError(it);
            }
            gen.endIf();
          } else {
            iterateKeywords(it, group);
          }
          if (!allErrors)
            gen.if(codegen_1._`${names_1.default.errors} === ${errsCount || 0}`);
        }
      }
      function iterateKeywords(it, group) {
        const { gen, schema, opts: { useDefaults } } = it;
        if (useDefaults)
          defaults_1.assignDefaults(it, group.type);
        gen.block(() => {
          for (const rule of group.rules) {
            if (applicability_1.shouldUseRule(schema, rule)) {
              keywordCode(it, rule.keyword, rule.definition, group.type);
            }
          }
        });
      }
      function checkStrictTypes(it, types) {
        if (it.schemaEnv.meta || !it.opts.strictTypes)
          return;
        checkContextTypes(it, types);
        if (!it.opts.allowUnionTypes)
          checkMultipleTypes(it, types);
        checkKeywordTypes(it, it.dataTypes);
      }
      function checkContextTypes(it, types) {
        if (!types.length)
          return;
        if (!it.dataTypes.length) {
          it.dataTypes = types;
          return;
        }
        types.forEach((t3) => {
          if (!includesType(it.dataTypes, t3)) {
            strictTypesError(it, `type "${t3}" not allowed by context "${it.dataTypes.join(",")}"`);
          }
        });
        it.dataTypes = it.dataTypes.filter((t3) => includesType(types, t3));
      }
      function checkMultipleTypes(it, ts) {
        if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
          strictTypesError(it, "use allowUnionTypes to allow union type keyword");
        }
      }
      function checkKeywordTypes(it, ts) {
        const rules = it.self.RULES.all;
        for (const keyword in rules) {
          const rule = rules[keyword];
          if (typeof rule == "object" && applicability_1.shouldUseRule(it.schema, rule)) {
            const { type } = rule.definition;
            if (type.length && !type.some((t3) => hasApplicableType(ts, t3))) {
              strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
            }
          }
        }
      }
      function hasApplicableType(schTs, kwdT) {
        return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
      }
      function includesType(ts, t3) {
        return ts.includes(t3) || t3 === "integer" && ts.includes("number");
      }
      function strictTypesError(it, msg) {
        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
        msg += ` at "${schemaPath}" (strictTypes)`;
        util_1.checkStrictMode(it, msg, it.opts.strictTypes);
      }
      var KeywordCxt = class {
        constructor(it, def, keyword) {
          keyword_1.validateKeywordUsage(it, def, keyword);
          this.gen = it.gen;
          this.allErrors = it.allErrors;
          this.keyword = keyword;
          this.data = it.data;
          this.schema = it.schema[keyword];
          this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
          this.schemaValue = util_1.schemaRefOrVal(it, this.schema, keyword, this.$data);
          this.schemaType = def.schemaType;
          this.parentSchema = it.schema;
          this.params = {};
          this.it = it;
          this.def = def;
          if (this.$data) {
            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
          } else {
            this.schemaCode = this.schemaValue;
            if (!keyword_1.validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {
              throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
            }
          }
          if ("code" in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen.const("_errs", names_1.default.errors);
          }
        }
        result(condition, successAction, failAction) {
          this.gen.if(codegen_1.not(condition));
          if (failAction)
            failAction();
          else
            this.error();
          if (successAction) {
            this.gen.else();
            successAction();
            if (this.allErrors)
              this.gen.endIf();
          } else {
            if (this.allErrors)
              this.gen.endIf();
            else
              this.gen.else();
          }
        }
        pass(condition, failAction) {
          this.result(condition, void 0, failAction);
        }
        fail(condition) {
          if (condition === void 0) {
            this.error();
            if (!this.allErrors)
              this.gen.if(false);
            return;
          }
          this.gen.if(condition);
          this.error();
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
        fail$data(condition) {
          if (!this.$data)
            return this.fail(condition);
          const { schemaCode } = this;
          this.fail(codegen_1._`${schemaCode} !== undefined && (${codegen_1.or(this.invalid$data(), condition)})`);
        }
        error(append, errorParams, errorPaths) {
          if (errorParams) {
            this.setParams(errorParams);
            this._error(append, errorPaths);
            this.setParams({});
            return;
          }
          this._error(append, errorPaths);
        }
        _error(append, errorPaths) {
          ;
          (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
        }
        $dataError() {
          errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);
        }
        reset() {
          if (this.errsCount === void 0)
            throw new Error('add "trackErrors" to keyword definition');
          errors_1.resetErrorsCount(this.gen, this.errsCount);
        }
        ok(cond) {
          if (!this.allErrors)
            this.gen.if(cond);
        }
        setParams(obj, assign4) {
          if (assign4)
            Object.assign(this.params, obj);
          else
            this.params = obj;
        }
        block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
          this.gen.block(() => {
            this.check$data(valid, $dataValid);
            codeBlock();
          });
        }
        check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
          if (!this.$data)
            return;
          const { gen, schemaCode, schemaType, def } = this;
          gen.if(codegen_1.or(codegen_1._`${schemaCode} === undefined`, $dataValid));
          if (valid !== codegen_1.nil)
            gen.assign(valid, true);
          if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen_1.nil)
              gen.assign(valid, false);
          }
          gen.else();
        }
        invalid$data() {
          const { gen, schemaCode, schemaType, def, it } = this;
          return codegen_1.or(wrong$DataType(), invalid$DataSchema());
          function wrong$DataType() {
            if (schemaType.length) {
              if (!(schemaCode instanceof codegen_1.Name))
                throw new Error("ajv implementation error");
              const st = Array.isArray(schemaType) ? schemaType : [schemaType];
              return codegen_1._`${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
            }
            return codegen_1.nil;
          }
          function invalid$DataSchema() {
            if (def.validateSchema) {
              const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
              return codegen_1._`!${validateSchemaRef}(${schemaCode})`;
            }
            return codegen_1.nil;
          }
        }
        subschema(appl, valid) {
          const subschema = subschema_1.getSubschema(this.it, appl);
          subschema_1.extendSubschemaData(subschema, this.it, appl);
          subschema_1.extendSubschemaMode(subschema, appl);
          const nextContext = __spreadProps(__spreadValues(__spreadValues({}, this.it), subschema), { items: void 0, props: void 0 });
          subschemaCode(nextContext, valid);
          return nextContext;
        }
        mergeEvaluated(schemaCxt, toName) {
          const { it, gen } = this;
          if (!it.opts.unevaluated)
            return;
          if (it.props !== true && schemaCxt.props !== void 0) {
            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
          }
          if (it.items !== true && schemaCxt.items !== void 0) {
            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
          }
        }
        mergeValidEvaluated(schemaCxt, valid) {
          const { it, gen } = this;
          if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
            return true;
          }
        }
      };
      exports.KeywordCxt = KeywordCxt;
      function keywordCode(it, keyword, def, ruleType) {
        const cxt = new KeywordCxt(it, def, keyword);
        if ("code" in def) {
          def.code(cxt, ruleType);
        } else if (cxt.$data && def.validate) {
          keyword_1.funcKeywordCode(cxt, def);
        } else if ("macro" in def) {
          keyword_1.macroKeywordCode(cxt, def);
        } else if (def.compile || def.validate) {
          keyword_1.funcKeywordCode(cxt, def);
        }
      }
      var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
      var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
      function getData($data, { dataLevel, dataNames, dataPathArr }) {
        let jsonPointer;
        let data;
        if ($data === "")
          return names_1.default.rootData;
        if ($data[0] === "/") {
          if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`);
          jsonPointer = $data;
          data = names_1.default.rootData;
        } else {
          const matches = RELATIVE_JSON_POINTER.exec($data);
          if (!matches)
            throw new Error(`Invalid JSON-pointer: ${$data}`);
          const up = +matches[1];
          jsonPointer = matches[2];
          if (jsonPointer === "#") {
            if (up >= dataLevel)
              throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
          }
          if (up > dataLevel)
            throw new Error(errorMsg("data", up));
          data = dataNames[dataLevel - up];
          if (!jsonPointer)
            return data;
        }
        let expr = data;
        const segments = jsonPointer.split("/");
        for (const segment of segments) {
          if (segment) {
            data = codegen_1._`${data}${codegen_1.getProperty(util_1.unescapeJsonPointer(segment))}`;
            expr = codegen_1._`${expr} && ${data}`;
          }
        }
        return expr;
        function errorMsg(pointerType, up) {
          return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
        }
      }
      exports.getData = getData;
    }
  });

  // ../node_modules/ajv/dist/runtime/validation_error.js
  var require_validation_error = __commonJS({
    "../node_modules/ajv/dist/runtime/validation_error.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var ValidationError = class extends Error {
        constructor(errors) {
          super("validation failed");
          this.errors = errors;
          this.ajv = this.validation = true;
        }
      };
      exports.default = ValidationError;
    }
  });

  // ../node_modules/ajv/dist/compile/ref_error.js
  var require_ref_error = __commonJS({
    "../node_modules/ajv/dist/compile/ref_error.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var resolve_1 = require_resolve();
      var MissingRefError = class extends Error {
        constructor(baseId, ref, msg) {
          super(msg || `can't resolve reference ${ref} from id ${baseId}`);
          this.missingRef = resolve_1.resolveUrl(baseId, ref);
          this.missingSchema = resolve_1.normalizeId(resolve_1.getFullPath(this.missingRef));
        }
      };
      exports.default = MissingRefError;
    }
  });

  // ../node_modules/ajv/dist/compile/index.js
  var require_compile = __commonJS({
    "../node_modules/ajv/dist/compile/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
      var codegen_1 = require_codegen();
      var validation_error_1 = require_validation_error();
      var names_1 = require_names();
      var resolve_1 = require_resolve();
      var util_1 = require_util();
      var validate_1 = require_validate();
      var URI = require_uri_all();
      var SchemaEnv = class {
        constructor(env) {
          var _a;
          this.refs = {};
          this.dynamicAnchors = {};
          let schema;
          if (typeof env.schema == "object")
            schema = env.schema;
          this.schema = env.schema;
          this.root = env.root || this;
          this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema === null || schema === void 0 ? void 0 : schema.$id);
          this.schemaPath = env.schemaPath;
          this.localRefs = env.localRefs;
          this.meta = env.meta;
          this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
          this.refs = {};
        }
      };
      exports.SchemaEnv = SchemaEnv;
      function compileSchema(sch) {
        const _sch = getCompilingSchema.call(this, sch);
        if (_sch)
          return _sch;
        const rootId = resolve_1.getFullPath(sch.root.baseId);
        const { es5, lines } = this.opts.code;
        const { ownProperties } = this.opts;
        const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
        let _ValidationError;
        if (sch.$async) {
          _ValidationError = gen.scopeValue("Error", {
            ref: validation_error_1.default,
            code: codegen_1._`require("ajv/dist/runtime/validation_error").default`
          });
        }
        const validateName = gen.scopeName("validate");
        sch.validateName = validateName;
        const schemaCxt = {
          gen,
          allErrors: this.opts.allErrors,
          data: names_1.default.data,
          parentData: names_1.default.parentData,
          parentDataProperty: names_1.default.parentDataProperty,
          dataNames: [names_1.default.data],
          dataPathArr: [codegen_1.nil],
          dataLevel: 0,
          dataTypes: [],
          definedProperties: /* @__PURE__ */ new Set(),
          topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: codegen_1.stringify(sch.schema) } : { ref: sch.schema }),
          validateName,
          ValidationError: _ValidationError,
          schema: sch.schema,
          schemaEnv: sch,
          rootId,
          baseId: sch.baseId || rootId,
          schemaPath: codegen_1.nil,
          errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
          errorPath: codegen_1._`""`,
          opts: this.opts,
          self: this
        };
        let sourceCode;
        try {
          this._compilations.add(sch);
          validate_1.validateFunctionCode(schemaCxt);
          gen.optimize(this.opts.code.optimize);
          const validateCode = gen.toString();
          sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
          if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
          const makeValidate2 = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
          const validate = makeValidate2(this, this.scope.get());
          this.scope.value(validateName, { ref: validate });
          validate.errors = null;
          validate.schema = sch.schema;
          validate.schemaEnv = sch;
          if (sch.$async)
            validate.$async = true;
          if (this.opts.code.source === true) {
            validate.source = { validateName, validateCode, scopeValues: gen._values };
          }
          if (this.opts.unevaluated) {
            const { props, items } = schemaCxt;
            validate.evaluated = {
              props: props instanceof codegen_1.Name ? void 0 : props,
              items: items instanceof codegen_1.Name ? void 0 : items,
              dynamicProps: props instanceof codegen_1.Name,
              dynamicItems: items instanceof codegen_1.Name
            };
            if (validate.source)
              validate.source.evaluated = codegen_1.stringify(validate.evaluated);
          }
          sch.validate = validate;
          return sch;
        } catch (e2) {
          delete sch.validate;
          delete sch.validateName;
          if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
          throw e2;
        } finally {
          this._compilations.delete(sch);
        }
      }
      exports.compileSchema = compileSchema;
      function resolveRef(root, baseId, ref) {
        var _a;
        ref = resolve_1.resolveUrl(baseId, ref);
        const schOrFunc = root.refs[ref];
        if (schOrFunc)
          return schOrFunc;
        let _sch = resolve.call(this, root, ref);
        if (_sch === void 0) {
          const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
          if (schema)
            _sch = new SchemaEnv({ schema, root, baseId });
        }
        if (_sch === void 0)
          return;
        return root.refs[ref] = inlineOrCompile.call(this, _sch);
      }
      exports.resolveRef = resolveRef;
      function inlineOrCompile(sch) {
        if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs))
          return sch.schema;
        return sch.validate ? sch : compileSchema.call(this, sch);
      }
      function getCompilingSchema(schEnv) {
        for (const sch of this._compilations) {
          if (sameSchemaEnv(sch, schEnv))
            return sch;
        }
      }
      exports.getCompilingSchema = getCompilingSchema;
      function sameSchemaEnv(s1, s22) {
        return s1.schema === s22.schema && s1.root === s22.root && s1.baseId === s22.baseId;
      }
      function resolve(root, ref) {
        let sch;
        while (typeof (sch = this.refs[ref]) == "string")
          ref = sch;
        return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
      }
      function resolveSchema(root, ref) {
        const p3 = URI.parse(ref);
        const refPath = resolve_1._getFullPath(p3);
        let baseId = resolve_1.getFullPath(root.baseId);
        if (Object.keys(root.schema).length > 0 && refPath === baseId) {
          return getJsonPointer.call(this, p3, root);
        }
        const id = resolve_1.normalizeId(refPath);
        const schOrRef = this.refs[id] || this.schemas[id];
        if (typeof schOrRef == "string") {
          const sch = resolveSchema.call(this, root, schOrRef);
          if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
          return getJsonPointer.call(this, p3, sch);
        }
        if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
          return;
        if (!schOrRef.validate)
          compileSchema.call(this, schOrRef);
        if (id === resolve_1.normalizeId(ref)) {
          const { schema } = schOrRef;
          if (schema.$id)
            baseId = resolve_1.resolveUrl(baseId, schema.$id);
          return new SchemaEnv({ schema, root, baseId });
        }
        return getJsonPointer.call(this, p3, schOrRef);
      }
      exports.resolveSchema = resolveSchema;
      var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
        "properties",
        "patternProperties",
        "enum",
        "dependencies",
        "definitions"
      ]);
      function getJsonPointer(parsedRef, { baseId, schema, root }) {
        var _a;
        if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
          return;
        for (const part of parsedRef.fragment.slice(1).split("/")) {
          if (typeof schema == "boolean")
            return;
          schema = schema[util_1.unescapeFragment(part)];
          if (schema === void 0)
            return;
          if (!PREVENT_SCOPE_CHANGE.has(part) && typeof schema == "object" && schema.$id) {
            baseId = resolve_1.resolveUrl(baseId, schema.$id);
          }
        }
        let env;
        if (typeof schema != "boolean" && schema.$ref && !util_1.schemaHasRulesButRef(schema, this.RULES)) {
          const $ref = resolve_1.resolveUrl(baseId, schema.$ref);
          env = resolveSchema.call(this, root, $ref);
        }
        env = env || new SchemaEnv({ schema, root, baseId });
        if (env.schema !== env.root.schema)
          return env;
        return void 0;
      }
    }
  });

  // ../node_modules/ajv/dist/refs/data.json
  var require_data = __commonJS({
    "../node_modules/ajv/dist/refs/data.json"(exports, module) {
      module.exports = {
        $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
        description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
        type: "object",
        required: ["$data"],
        properties: {
          $data: {
            type: "string",
            anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
          }
        },
        additionalProperties: false
      };
    }
  });

  // ../node_modules/ajv/dist/core.js
  var require_core = __commonJS({
    "../node_modules/ajv/dist/core.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
      var validate_1 = require_validate();
      Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
        return validate_1.KeywordCxt;
      } });
      var codegen_1 = require_codegen();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return codegen_1._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return codegen_1.str;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return codegen_1.stringify;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return codegen_1.nil;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return codegen_1.Name;
      } });
      Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
        return codegen_1.CodeGen;
      } });
      var validation_error_1 = require_validation_error();
      var ref_error_1 = require_ref_error();
      var rules_1 = require_rules();
      var compile_1 = require_compile();
      var codegen_2 = require_codegen();
      var resolve_1 = require_resolve();
      var dataType_1 = require_dataType();
      var util_1 = require_util();
      var $dataRefSchema = require_data();
      var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
      var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
      ]);
      var removedOptions = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        schemaId: "JSON Schema draft-04 is not supported in Ajv v7/8.",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now, see option `strict`."
      };
      var deprecatedOptions = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
      };
      var MAX_EXPRESSION = 200;
      function requiredOptions(o3) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        const s3 = o3.strict;
        const _optz = (_a = o3.code) === null || _a === void 0 ? void 0 : _a.optimize;
        const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
        return {
          strictSchema: (_c = (_b = o3.strictSchema) !== null && _b !== void 0 ? _b : s3) !== null && _c !== void 0 ? _c : true,
          strictNumbers: (_e = (_d = o3.strictNumbers) !== null && _d !== void 0 ? _d : s3) !== null && _e !== void 0 ? _e : true,
          strictTypes: (_g = (_f = o3.strictTypes) !== null && _f !== void 0 ? _f : s3) !== null && _g !== void 0 ? _g : "log",
          strictTuples: (_j = (_h = o3.strictTuples) !== null && _h !== void 0 ? _h : s3) !== null && _j !== void 0 ? _j : "log",
          strictRequired: (_l = (_k = o3.strictRequired) !== null && _k !== void 0 ? _k : s3) !== null && _l !== void 0 ? _l : false,
          code: o3.code ? __spreadProps(__spreadValues({}, o3.code), { optimize }) : { optimize },
          loopRequired: (_m = o3.loopRequired) !== null && _m !== void 0 ? _m : MAX_EXPRESSION,
          loopEnum: (_o = o3.loopEnum) !== null && _o !== void 0 ? _o : MAX_EXPRESSION,
          meta: (_p = o3.meta) !== null && _p !== void 0 ? _p : true,
          messages: (_q = o3.messages) !== null && _q !== void 0 ? _q : true,
          inlineRefs: (_r = o3.inlineRefs) !== null && _r !== void 0 ? _r : true,
          addUsedSchema: (_s = o3.addUsedSchema) !== null && _s !== void 0 ? _s : true,
          validateSchema: (_t = o3.validateSchema) !== null && _t !== void 0 ? _t : true,
          validateFormats: (_u = o3.validateFormats) !== null && _u !== void 0 ? _u : true,
          unicodeRegExp: (_v = o3.unicodeRegExp) !== null && _v !== void 0 ? _v : true
        };
      }
      var Ajv2 = class {
        constructor(opts = {}) {
          this.schemas = {};
          this.refs = {};
          this.formats = {};
          this._compilations = /* @__PURE__ */ new Set();
          this._loading = {};
          this._cache = /* @__PURE__ */ new Map();
          opts = this.opts = __spreadValues(__spreadValues({}, opts), requiredOptions(opts));
          const { es5, lines } = this.opts.code;
          this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
          this.logger = getLogger(opts.logger);
          const formatOpt = opts.validateFormats;
          opts.validateFormats = false;
          this.RULES = rules_1.getRules();
          checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
          checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
          this._metaOpts = getMetaSchemaOptions.call(this);
          if (opts.formats)
            addInitialFormats.call(this);
          this._addVocabularies();
          this._addDefaultMetaSchema();
          if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
          if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
          addInitialSchemas.call(this);
          opts.validateFormats = formatOpt;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data, meta } = this.opts;
          if (meta && $data)
            this.addMetaSchema($dataRefSchema, $dataRefSchema.$id, false);
        }
        defaultMeta() {
          const { meta } = this.opts;
          return this.opts.defaultMeta = typeof meta == "object" ? meta.$id || meta : void 0;
        }
        validate(schemaKeyRef, data) {
          let v3;
          if (typeof schemaKeyRef == "string") {
            v3 = this.getSchema(schemaKeyRef);
            if (!v3)
              throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
          } else {
            v3 = this.compile(schemaKeyRef);
          }
          const valid = v3(data);
          if (!("$async" in v3))
            this.errors = v3.errors;
          return valid;
        }
        compile(schema, _meta) {
          const sch = this._addSchema(schema, _meta);
          return sch.validate || this._compileSchemaEnv(sch);
        }
        compileAsync(schema, meta) {
          if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
          }
          const { loadSchema } = this.opts;
          return runCompileAsync.call(this, schema, meta);
          function runCompileAsync(_schema, _meta) {
            return __async(this, null, function* () {
              yield loadMetaSchema.call(this, _schema.$schema);
              const sch = this._addSchema(_schema, _meta);
              return sch.validate || _compileAsync.call(this, sch);
            });
          }
          function loadMetaSchema($ref) {
            return __async(this, null, function* () {
              if ($ref && !this.getSchema($ref)) {
                yield runCompileAsync.call(this, { $ref }, true);
              }
            });
          }
          function _compileAsync(sch) {
            return __async(this, null, function* () {
              try {
                return this._compileSchemaEnv(sch);
              } catch (e2) {
                if (!(e2 instanceof ref_error_1.default))
                  throw e2;
                checkLoaded.call(this, e2);
                yield loadMissingSchema.call(this, e2.missingSchema);
                return _compileAsync.call(this, sch);
              }
            });
          }
          function checkLoaded({ missingSchema: ref, missingRef }) {
            if (this.refs[ref]) {
              throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
            }
          }
          function loadMissingSchema(ref) {
            return __async(this, null, function* () {
              const _schema = yield _loadSchema.call(this, ref);
              if (!this.refs[ref])
                yield loadMetaSchema.call(this, _schema.$schema);
              if (!this.refs[ref])
                this.addSchema(_schema, ref, meta);
            });
          }
          function _loadSchema(ref) {
            return __async(this, null, function* () {
              const p3 = this._loading[ref];
              if (p3)
                return p3;
              try {
                return yield this._loading[ref] = loadSchema(ref);
              } finally {
                delete this._loading[ref];
              }
            });
          }
        }
        // Adds schema to the instance
        addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
          if (Array.isArray(schema)) {
            for (const sch of schema)
              this.addSchema(sch, void 0, _meta, _validateSchema);
            return this;
          }
          let id;
          if (typeof schema === "object") {
            id = schema.$id;
            if (id !== void 0 && typeof id != "string")
              throw new Error("schema $id must be string");
          }
          key = resolve_1.normalizeId(key || id);
          this._checkUnique(key);
          this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
          return this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
          this.addSchema(schema, key, true, _validateSchema);
          return this;
        }
        //  Validate schema against its meta-schema
        validateSchema(schema, throwOrLogError) {
          if (typeof schema == "boolean")
            return true;
          let $schema;
          $schema = schema.$schema;
          if ($schema !== void 0 && typeof $schema != "string") {
            throw new Error("$schema must be a string");
          }
          $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
          if (!$schema) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
          }
          const valid = this.validate($schema, schema);
          if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
              this.logger.error(message);
            else
              throw new Error(message);
          }
          return valid;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(keyRef) {
          let sch;
          while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
          if (sch === void 0) {
            const root = new compile_1.SchemaEnv({ schema: {} });
            sch = compile_1.resolveSchema.call(this, root, keyRef);
            if (!sch)
              return;
            this.refs[keyRef] = sch;
          }
          return sch.validate || this._compileSchemaEnv(sch);
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(schemaKeyRef) {
          if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
          }
          switch (typeof schemaKeyRef) {
            case "undefined":
              this._removeAllSchemas(this.schemas);
              this._removeAllSchemas(this.refs);
              this._cache.clear();
              return this;
            case "string": {
              const sch = getSchEnv.call(this, schemaKeyRef);
              if (typeof sch == "object")
                this._cache.delete(sch.schema);
              delete this.schemas[schemaKeyRef];
              delete this.refs[schemaKeyRef];
              return this;
            }
            case "object": {
              const cacheKey = schemaKeyRef;
              this._cache.delete(cacheKey);
              let id = schemaKeyRef.$id;
              if (id) {
                id = resolve_1.normalizeId(id);
                delete this.schemas[id];
                delete this.refs[id];
              }
              return this;
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(definitions) {
          for (const def of definitions)
            this.addKeyword(def);
          return this;
        }
        addKeyword(kwdOrDef, def) {
          let keyword;
          if (typeof kwdOrDef == "string") {
            keyword = kwdOrDef;
            if (typeof def == "object") {
              this.logger.warn("these parameters are deprecated, see docs for addKeyword");
              def.keyword = keyword;
            }
          } else if (typeof kwdOrDef == "object" && def === void 0) {
            def = kwdOrDef;
            keyword = def.keyword;
            if (Array.isArray(keyword) && !keyword.length) {
              throw new Error("addKeywords: keyword must be string or non-empty array");
            }
          } else {
            throw new Error("invalid addKeywords parameters");
          }
          checkKeyword.call(this, keyword, def);
          if (!def) {
            util_1.eachItem(keyword, (kwd) => addRule.call(this, kwd));
            return this;
          }
          keywordMetaschema.call(this, def);
          const definition = __spreadProps(__spreadValues({}, def), {
            type: dataType_1.getJSONTypes(def.type),
            schemaType: dataType_1.getJSONTypes(def.schemaType)
          });
          util_1.eachItem(keyword, definition.type.length === 0 ? (k3) => addRule.call(this, k3, definition) : (k3) => definition.type.forEach((t3) => addRule.call(this, k3, definition, t3)));
          return this;
        }
        getKeyword(keyword) {
          const rule = this.RULES.all[keyword];
          return typeof rule == "object" ? rule.definition : !!rule;
        }
        // Remove keyword
        removeKeyword(keyword) {
          const { RULES } = this;
          delete RULES.keywords[keyword];
          delete RULES.all[keyword];
          for (const group of RULES.rules) {
            const i3 = group.rules.findIndex((rule) => rule.keyword === keyword);
            if (i3 >= 0)
              group.rules.splice(i3, 1);
          }
          return this;
        }
        // Add format
        addFormat(name, format) {
          if (typeof format == "string")
            format = new RegExp(format);
          this.formats[name] = format;
          return this;
        }
        errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
          if (!errors || errors.length === 0)
            return "No errors";
          return errors.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
        }
        $dataMetaSchema(metaSchema, keywordsJsonPointers) {
          const rules = this.RULES.all;
          metaSchema = JSON.parse(JSON.stringify(metaSchema));
          for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1);
            let keywords = metaSchema;
            for (const seg of segments)
              keywords = keywords[seg];
            for (const key in rules) {
              const rule = rules[key];
              if (typeof rule != "object")
                continue;
              const { $data } = rule.definition;
              const schema = keywords[key];
              if ($data && schema)
                keywords[key] = schemaOrData(schema);
            }
          }
          return metaSchema;
        }
        _removeAllSchemas(schemas2, regex) {
          for (const keyRef in schemas2) {
            const sch = schemas2[keyRef];
            if (!regex || regex.test(keyRef)) {
              if (typeof sch == "string") {
                delete schemas2[keyRef];
              } else if (sch && !sch.meta) {
                this._cache.delete(sch.schema);
                delete schemas2[keyRef];
              }
            }
          }
        }
        _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
          let id;
          if (typeof schema == "object") {
            id = schema.$id;
          } else {
            if (this.opts.jtd)
              throw new Error("schema must be object");
            else if (typeof schema != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let sch = this._cache.get(schema);
          if (sch !== void 0)
            return sch;
          const localRefs = resolve_1.getSchemaRefs.call(this, schema);
          baseId = resolve_1.normalizeId(id || baseId);
          sch = new compile_1.SchemaEnv({ schema, meta, baseId, localRefs });
          this._cache.set(sch.schema, sch);
          if (addSchema && !baseId.startsWith("#")) {
            if (baseId)
              this._checkUnique(baseId);
            this.refs[baseId] = sch;
          }
          if (validateSchema)
            this.validateSchema(schema, true);
          return sch;
        }
        _checkUnique(id) {
          if (this.schemas[id] || this.refs[id]) {
            throw new Error(`schema with key or id "${id}" already exists`);
          }
        }
        _compileSchemaEnv(sch) {
          if (sch.meta)
            this._compileMetaSchema(sch);
          else
            compile_1.compileSchema.call(this, sch);
          if (!sch.validate)
            throw new Error("ajv implementation error");
          return sch.validate;
        }
        _compileMetaSchema(sch) {
          const currentOpts = this.opts;
          this.opts = this._metaOpts;
          try {
            compile_1.compileSchema.call(this, sch);
          } finally {
            this.opts = currentOpts;
          }
        }
      };
      exports.default = Ajv2;
      Ajv2.ValidationError = validation_error_1.default;
      Ajv2.MissingRefError = ref_error_1.default;
      function checkOptions(checkOpts, options, msg, log = "error") {
        for (const key in checkOpts) {
          const opt = key;
          if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
        }
      }
      function getSchEnv(keyRef) {
        keyRef = resolve_1.normalizeId(keyRef);
        return this.schemas[keyRef] || this.refs[keyRef];
      }
      function addInitialSchemas() {
        const optsSchemas = this.opts.schemas;
        if (!optsSchemas)
          return;
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
      }
      function addInitialFormats() {
        for (const name in this.opts.formats) {
          const format = this.opts.formats[name];
          if (format)
            this.addFormat(name, format);
        }
      }
      function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
          this.addVocabulary(defs);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const keyword in defs) {
          const def = defs[keyword];
          if (!def.keyword)
            def.keyword = keyword;
          this.addKeyword(def);
        }
      }
      function getMetaSchemaOptions() {
        const metaOpts = __spreadValues({}, this.opts);
        for (const opt of META_IGNORE_OPTIONS)
          delete metaOpts[opt];
        return metaOpts;
      }
      var noLogs = { log() {
      }, warn() {
      }, error() {
      } };
      function getLogger(logger3) {
        if (logger3 === false)
          return noLogs;
        if (logger3 === void 0)
          return console;
        if (logger3.log && logger3.warn && logger3.error)
          return logger3;
        throw new Error("logger must implement log, warn and error methods");
      }
      var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
      function checkKeyword(keyword, def) {
        const { RULES } = this;
        util_1.eachItem(keyword, (kwd) => {
          if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
          if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
        });
        if (!def)
          return;
        if (def.$data && !("code" in def || "validate" in def)) {
          throw new Error('$data keyword must have "code" or "validate" function');
        }
      }
      function addRule(keyword, definition, dataType) {
        var _a;
        const post = definition === null || definition === void 0 ? void 0 : definition.post;
        if (dataType && post)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES } = this;
        let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t3 }) => t3 === dataType);
        if (!ruleGroup) {
          ruleGroup = { type: dataType, rules: [] };
          RULES.rules.push(ruleGroup);
        }
        RULES.keywords[keyword] = true;
        if (!definition)
          return;
        const rule = {
          keyword,
          definition: __spreadProps(__spreadValues({}, definition), {
            type: dataType_1.getJSONTypes(definition.type),
            schemaType: dataType_1.getJSONTypes(definition.schemaType)
          })
        };
        if (definition.before)
          addBeforeRule.call(this, ruleGroup, rule, definition.before);
        else
          ruleGroup.rules.push(rule);
        RULES.all[keyword] = rule;
        (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
      }
      function addBeforeRule(ruleGroup, rule, before) {
        const i3 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
        if (i3 >= 0) {
          ruleGroup.rules.splice(i3, 0, rule);
        } else {
          ruleGroup.rules.push(rule);
          this.logger.warn(`rule ${before} is not defined`);
        }
      }
      function keywordMetaschema(def) {
        let { metaSchema } = def;
        if (metaSchema === void 0)
          return;
        if (def.$data && this.opts.$data)
          metaSchema = schemaOrData(metaSchema);
        def.validateSchema = this.compile(metaSchema, true);
      }
      var $dataRef = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      };
      function schemaOrData(schema) {
        return { anyOf: [schema, $dataRef] };
      }
    }
  });

  // ../node_modules/ajv/dist/vocabularies/core/id.js
  var require_id = __commonJS({
    "../node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var def = {
        keyword: "id",
        code() {
          throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/core/ref.js
  var require_ref = __commonJS({
    "../node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.callRef = exports.getValidate = void 0;
      var ref_error_1 = require_ref_error();
      var code_1 = require_code2();
      var codegen_1 = require_codegen();
      var names_1 = require_names();
      var compile_1 = require_compile();
      var util_1 = require_util();
      var def = {
        keyword: "$ref",
        schemaType: "string",
        code(cxt) {
          const { gen, schema: $ref, it } = cxt;
          const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
          const { root } = env;
          if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
          const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
          if (schOrEnv === void 0)
            throw new ref_error_1.default(baseId, $ref);
          if (schOrEnv instanceof compile_1.SchemaEnv)
            return callValidate(schOrEnv);
          return inlineRefSchema(schOrEnv);
          function callRootRef() {
            if (env === root)
              return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, codegen_1._`${rootName}.validate`, root, root.$async);
          }
          function callValidate(sch) {
            const v3 = getValidate(cxt, sch);
            callRef(cxt, v3, sch, sch.$async);
          }
          function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: codegen_1.stringify(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
              schema: sch,
              dataTypes: [],
              schemaPath: codegen_1.nil,
              topSchemaRef: schName,
              errSchemaPath: $ref
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
          }
        }
      };
      function getValidate(cxt, sch) {
        const { gen } = cxt;
        return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : codegen_1._`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
      }
      exports.getValidate = getValidate;
      function callRef(cxt, v3, sch, $async) {
        const { gen, it } = cxt;
        const { allErrors, schemaEnv: env, opts } = it;
        const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
        if ($async)
          callAsyncRef();
        else
          callSyncRef();
        function callAsyncRef() {
          if (!env.$async)
            throw new Error("async schema referenced by sync schema");
          const valid = gen.let("valid");
          gen.try(() => {
            gen.code(codegen_1._`await ${code_1.callValidateCode(cxt, v3, passCxt)}`);
            addEvaluatedFrom(v3);
            if (!allErrors)
              gen.assign(valid, true);
          }, (e2) => {
            gen.if(codegen_1._`!(${e2} instanceof ${it.ValidationError})`, () => gen.throw(e2));
            addErrorsFrom(e2);
            if (!allErrors)
              gen.assign(valid, false);
          });
          cxt.ok(valid);
        }
        function callSyncRef() {
          cxt.result(code_1.callValidateCode(cxt, v3, passCxt), () => addEvaluatedFrom(v3), () => addErrorsFrom(v3));
        }
        function addErrorsFrom(source) {
          const errs = codegen_1._`${source}.errors`;
          gen.assign(names_1.default.vErrors, codegen_1._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
          gen.assign(names_1.default.errors, codegen_1._`${names_1.default.vErrors}.length`);
        }
        function addEvaluatedFrom(source) {
          var _a;
          if (!it.opts.unevaluated)
            return;
          const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
          if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
              if (schEvaluated.props !== void 0) {
                it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
              }
            } else {
              const props = gen.var("props", codegen_1._`${source}.evaluated.props`);
              it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
            }
          }
          if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
              if (schEvaluated.items !== void 0) {
                it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
              }
            } else {
              const items = gen.var("items", codegen_1._`${source}.evaluated.items`);
              it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
            }
          }
        }
      }
      exports.callRef = callRef;
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/core/index.js
  var require_core2 = __commonJS({
    "../node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var id_1 = require_id();
      var ref_1 = require_ref();
      var core = [
        "$schema",
        "$id",
        "$defs",
        "$vocabulary",
        { keyword: "$comment" },
        "definitions",
        id_1.default,
        ref_1.default
      ];
      exports.default = core;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/limitNumber.js
  var require_limitNumber = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var ops = codegen_1.operators;
      var KWDs = {
        maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
      };
      var error = {
        message: ({ keyword, schemaCode }) => codegen_1.str`must be ${KWDs[keyword].okStr} ${schemaCode}`,
        params: ({ keyword, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
      };
      var def = {
        keyword: Object.keys(KWDs),
        type: "number",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt;
          cxt.fail$data(codegen_1._`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/multipleOf.js
  var require_multipleOf = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var error = {
        message: ({ schemaCode }) => codegen_1.str`must be multiple of ${schemaCode}`,
        params: ({ schemaCode }) => codegen_1._`{multipleOf: ${schemaCode}}`
      };
      var def = {
        keyword: "multipleOf",
        type: "number",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, it } = cxt;
          const prec = it.opts.multipleOfPrecision;
          const res = gen.let("res");
          const invalid = prec ? codegen_1._`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : codegen_1._`${res} !== parseInt(${res})`;
          cxt.fail$data(codegen_1._`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/runtime/ucs2length.js
  var require_ucs2length = __commonJS({
    "../node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function ucs2length(str2) {
        const len = str2.length;
        let length = 0;
        let pos = 0;
        let value;
        while (pos < len) {
          length++;
          value = str2.charCodeAt(pos++);
          if (value >= 55296 && value <= 56319 && pos < len) {
            value = str2.charCodeAt(pos);
            if ((value & 64512) === 56320)
              pos++;
          }
        }
        return length;
      }
      exports.default = ucs2length;
      ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/limitLength.js
  var require_limitLength = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var ucs2length_1 = require_ucs2length();
      var error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === "maxLength" ? "more" : "fewer";
          return codegen_1.str`must NOT have ${comp} than ${schemaCode} characters`;
        },
        params: ({ schemaCode }) => codegen_1._`{limit: ${schemaCode}}`
      };
      var def = {
        keyword: ["maxLength", "minLength"],
        type: "string",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode, it } = cxt;
          const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
          const len = it.opts.unicode === false ? codegen_1._`${data}.length` : codegen_1._`${util_1.useFunc(cxt.gen, ucs2length_1.default)}(${data})`;
          cxt.fail$data(codegen_1._`${len} ${op} ${schemaCode}`);
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/pattern.js
  var require_pattern = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code_1 = require_code2();
      var codegen_1 = require_codegen();
      var error = {
        message: ({ schemaCode }) => codegen_1.str`must match pattern "${schemaCode}"`,
        params: ({ schemaCode }) => codegen_1._`{pattern: ${schemaCode}}`
      };
      var def = {
        keyword: "pattern",
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code(cxt) {
          const { data, $data, schema, schemaCode, it } = cxt;
          const u3 = it.opts.unicodeRegExp ? "u" : "";
          const regExp = $data ? codegen_1._`(new RegExp(${schemaCode}, ${u3}))` : code_1.usePattern(cxt, schema);
          cxt.fail$data(codegen_1._`!${regExp}.test(${data})`);
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/limitProperties.js
  var require_limitProperties = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === "maxProperties" ? "more" : "fewer";
          return codegen_1.str`must NOT have ${comp} than ${schemaCode} items`;
        },
        params: ({ schemaCode }) => codegen_1._`{limit: ${schemaCode}}`
      };
      var def = {
        keyword: ["maxProperties", "minProperties"],
        type: "object",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt;
          const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
          cxt.fail$data(codegen_1._`Object.keys(${data}).length ${op} ${schemaCode}`);
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/required.js
  var require_required = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code_1 = require_code2();
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: ({ params: { missingProperty } }) => codegen_1.str`must have required property '${missingProperty}'`,
        params: ({ params: { missingProperty } }) => codegen_1._`{missingProperty: ${missingProperty}}`
      };
      var def = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: true,
        error,
        code(cxt) {
          const { gen, schema, schemaCode, data, $data, it } = cxt;
          const { opts } = it;
          if (!$data && schema.length === 0)
            return;
          const useLoop = schema.length >= opts.loopRequired;
          if (it.allErrors)
            allErrorsMode();
          else
            exitOnErrorMode();
          if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
              if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
                const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                util_1.checkStrictMode(it, msg, it.opts.strictRequired);
              }
            }
          }
          function allErrorsMode() {
            if (useLoop || $data) {
              cxt.block$data(codegen_1.nil, loopAllRequired);
            } else {
              for (const prop of schema) {
                code_1.checkReportMissingProp(cxt, prop);
              }
            }
          }
          function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
              const valid = gen.let("valid", true);
              cxt.block$data(valid, () => loopUntilMissing(missing, valid));
              cxt.ok(valid);
            } else {
              gen.if(code_1.checkMissingProp(cxt, schema, missing));
              code_1.reportMissingProp(cxt, missing);
              gen.else();
            }
          }
          function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
              cxt.setParams({ missingProperty: prop });
              gen.if(code_1.noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
          }
          function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
              gen.assign(valid, code_1.propertyInData(gen, data, missing, opts.ownProperties));
              gen.if(codegen_1.not(valid), () => {
                cxt.error();
                gen.break();
              });
            }, codegen_1.nil);
          }
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/limitItems.js
  var require_limitItems = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === "maxItems" ? "more" : "fewer";
          return codegen_1.str`must NOT have ${comp} than ${schemaCode} items`;
        },
        params: ({ schemaCode }) => codegen_1._`{limit: ${schemaCode}}`
      };
      var def = {
        keyword: ["maxItems", "minItems"],
        type: "array",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt;
          const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
          cxt.fail$data(codegen_1._`${data}.length ${op} ${schemaCode}`);
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/runtime/equal.js
  var require_equal = __commonJS({
    "../node_modules/ajv/dist/runtime/equal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var equal = require_fast_deep_equal();
      equal.code = 'require("ajv/dist/runtime/equal").default';
      exports.default = equal;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
  var require_uniqueItems = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var dataType_1 = require_dataType();
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var equal_1 = require_equal();
      var error = {
        message: ({ params: { i: i3, j: j3 } }) => codegen_1.str`must NOT have duplicate items (items ## ${j3} and ${i3} are identical)`,
        params: ({ params: { i: i3, j: j3 } }) => codegen_1._`{i: ${i3}, j: ${j3}}`
      };
      var def = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
          if (!$data && !schema)
            return;
          const valid = gen.let("valid");
          const itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];
          cxt.block$data(valid, validateUniqueItems, codegen_1._`${schemaCode} === false`);
          cxt.ok(valid);
          function validateUniqueItems() {
            const i3 = gen.let("i", codegen_1._`${data}.length`);
            const j3 = gen.let("j");
            cxt.setParams({ i: i3, j: j3 });
            gen.assign(valid, true);
            gen.if(codegen_1._`${i3} > 1`, () => (canOptimize() ? loopN : loopN2)(i3, j3));
          }
          function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t3) => t3 === "object" || t3 === "array");
          }
          function loopN(i3, j3) {
            const item = gen.name("item");
            const wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", codegen_1._`{}`);
            gen.for(codegen_1._`;${i3}--;`, () => {
              gen.let(item, codegen_1._`${data}[${i3}]`);
              gen.if(wrongType, codegen_1._`continue`);
              if (itemTypes.length > 1)
                gen.if(codegen_1._`typeof ${item} == "string"`, codegen_1._`${item} += "_"`);
              gen.if(codegen_1._`typeof ${indices}[${item}] == "number"`, () => {
                gen.assign(j3, codegen_1._`${indices}[${item}]`);
                cxt.error();
                gen.assign(valid, false).break();
              }).code(codegen_1._`${indices}[${item}] = ${i3}`);
            });
          }
          function loopN2(i3, j3) {
            const eql = util_1.useFunc(gen, equal_1.default);
            const outer = gen.name("outer");
            gen.label(outer).for(codegen_1._`;${i3}--;`, () => gen.for(codegen_1._`${j3} = ${i3}; ${j3}--;`, () => gen.if(codegen_1._`${eql}(${data}[${i3}], ${data}[${j3}])`, () => {
              cxt.error();
              gen.assign(valid, false).break(outer);
            })));
          }
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/const.js
  var require_const = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var equal_1 = require_equal();
      var error = {
        message: "must be equal to constant",
        params: ({ schemaCode }) => codegen_1._`{allowedValue: ${schemaCode}}`
      };
      var def = {
        keyword: "const",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode } = cxt;
          cxt.fail$data(codegen_1._`!${util_1.useFunc(gen, equal_1.default)}(${data}, ${schemaCode})`);
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/enum.js
  var require_enum = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var equal_1 = require_equal();
      var error = {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode }) => codegen_1._`{allowedValues: ${schemaCode}}`
      };
      var def = {
        keyword: "enum",
        schemaType: "array",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, schemaCode, it } = cxt;
          if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
          const useLoop = schema.length >= it.opts.loopEnum;
          const eql = util_1.useFunc(gen, equal_1.default);
          let valid;
          if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
          } else {
            if (!Array.isArray(schema))
              throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = codegen_1.or(...schema.map((_x, i3) => equalCode(vSchema, i3)));
          }
          cxt.pass(valid);
          function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v3) => gen.if(codegen_1._`${eql}(${data}, ${v3})`, () => gen.assign(valid, true).break()));
          }
          function equalCode(vSchema, i3) {
            const sch = schema[i3];
            return sch && typeof sch === "object" ? codegen_1._`${eql}(${data}, ${vSchema}[${i3}])` : codegen_1._`${data} === ${sch}`;
          }
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/validation/index.js
  var require_validation = __commonJS({
    "../node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var limitNumber_1 = require_limitNumber();
      var multipleOf_1 = require_multipleOf();
      var limitLength_1 = require_limitLength();
      var pattern_1 = require_pattern();
      var limitProperties_1 = require_limitProperties();
      var required_1 = require_required();
      var limitItems_1 = require_limitItems();
      var uniqueItems_1 = require_uniqueItems();
      var const_1 = require_const();
      var enum_1 = require_enum();
      var validation = [
        // number
        limitNumber_1.default,
        multipleOf_1.default,
        // string
        limitLength_1.default,
        pattern_1.default,
        // object
        limitProperties_1.default,
        required_1.default,
        // array
        limitItems_1.default,
        uniqueItems_1.default,
        // any
        { keyword: "type", schemaType: ["string", "array"] },
        { keyword: "nullable", schemaType: "boolean" },
        const_1.default,
        enum_1.default
      ];
      exports.default = validation;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
  var require_additionalItems = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateAdditionalItems = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: ({ params: { len } }) => codegen_1.str`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => codegen_1._`{limit: ${len}}`
      };
      var def = {
        keyword: "additionalItems",
        type: "array",
        schemaType: ["boolean", "object"],
        before: "uniqueItems",
        error,
        code(cxt) {
          const { parentSchema, it } = cxt;
          const { items } = parentSchema;
          if (!Array.isArray(items)) {
            util_1.checkStrictMode(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
          }
          validateAdditionalItems(cxt, items);
        }
      };
      function validateAdditionalItems(cxt, items) {
        const { gen, schema, data, keyword, it } = cxt;
        it.items = true;
        const len = gen.const("len", codegen_1._`${data}.length`);
        if (schema === false) {
          cxt.setParams({ len: items.length });
          cxt.pass(codegen_1._`${len} <= ${items.length}`);
        } else if (typeof schema == "object" && !util_1.alwaysValidSchema(it, schema)) {
          const valid = gen.var("valid", codegen_1._`${len} <= ${items.length}`);
          gen.if(codegen_1.not(valid), () => validateItems(valid));
          cxt.ok(valid);
        }
        function validateItems(valid) {
          gen.forRange("i", items.length, len, (i3) => {
            cxt.subschema({ keyword, dataProp: i3, dataPropType: util_1.Type.Num }, valid);
            if (!it.allErrors)
              gen.if(codegen_1.not(valid), () => gen.break());
          });
        }
      }
      exports.validateAdditionalItems = validateAdditionalItems;
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/items.js
  var require_items = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateTuple = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var code_1 = require_code2();
      var def = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "array", "boolean"],
        before: "uniqueItems",
        code(cxt) {
          const { schema, it } = cxt;
          if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
          it.items = true;
          if (util_1.alwaysValidSchema(it, schema))
            return;
          cxt.ok(code_1.validateArray(cxt));
        }
      };
      function validateTuple(cxt, extraItems, schArr = cxt.schema) {
        const { gen, parentSchema, data, keyword, it } = cxt;
        checkStrictTuple(parentSchema);
        if (it.opts.unevaluated && schArr.length && it.items !== true) {
          it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
        }
        const valid = gen.name("valid");
        const len = gen.const("len", codegen_1._`${data}.length`);
        schArr.forEach((sch, i3) => {
          if (util_1.alwaysValidSchema(it, sch))
            return;
          gen.if(codegen_1._`${len} > ${i3}`, () => cxt.subschema({
            keyword,
            schemaProp: i3,
            dataProp: i3
          }, valid));
          cxt.ok(valid);
        });
        function checkStrictTuple(sch) {
          const { opts, errSchemaPath } = it;
          const l3 = schArr.length;
          const fullTuple = l3 === sch.minItems && (l3 === sch.maxItems || sch[extraItems] === false);
          if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword}" is ${l3}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
            util_1.checkStrictMode(it, msg, opts.strictTuples);
          }
        }
      }
      exports.validateTuple = validateTuple;
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
  var require_prefixItems = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var items_1 = require_items();
      var def = {
        keyword: "prefixItems",
        type: "array",
        schemaType: ["array"],
        before: "uniqueItems",
        code: (cxt) => items_1.validateTuple(cxt, "items")
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/items2020.js
  var require_items2020 = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var code_1 = require_code2();
      var additionalItems_1 = require_additionalItems();
      var error = {
        message: ({ params: { len } }) => codegen_1.str`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => codegen_1._`{limit: ${len}}`
      };
      var def = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        error,
        code(cxt) {
          const { schema, parentSchema, it } = cxt;
          const { prefixItems } = parentSchema;
          it.items = true;
          if (util_1.alwaysValidSchema(it, schema))
            return;
          if (prefixItems)
            additionalItems_1.validateAdditionalItems(cxt, prefixItems);
          else
            cxt.ok(code_1.validateArray(cxt));
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/contains.js
  var require_contains = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: ({ params: { min, max } }) => max === void 0 ? codegen_1.str`must contain at least ${min} valid item(s)` : codegen_1.str`must contain at least ${min} and no more than ${max} valid item(s)`,
        params: ({ params: { min, max } }) => max === void 0 ? codegen_1._`{minContains: ${min}}` : codegen_1._`{minContains: ${min}, maxContains: ${max}}`
      };
      var def = {
        keyword: "contains",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt;
          let min;
          let max;
          const { minContains, maxContains } = parentSchema;
          if (it.opts.next) {
            min = minContains === void 0 ? 1 : minContains;
            max = maxContains;
          } else {
            min = 1;
          }
          const len = gen.const("len", codegen_1._`${data}.length`);
          cxt.setParams({ min, max });
          if (max === void 0 && min === 0) {
            util_1.checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
          }
          if (max !== void 0 && min > max) {
            util_1.checkStrictMode(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
          }
          if (util_1.alwaysValidSchema(it, schema)) {
            let cond = codegen_1._`${len} >= ${min}`;
            if (max !== void 0)
              cond = codegen_1._`${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
          }
          it.items = true;
          const valid = gen.name("valid");
          if (max === void 0 && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
          } else {
            gen.let(valid, false);
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
          }
          cxt.result(valid, () => cxt.reset());
          function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i3) => {
              cxt.subschema({
                keyword: "contains",
                dataProp: i3,
                dataPropType: util_1.Type.Num,
                compositeRule: true
              }, _valid);
              block();
            });
          }
          function checkLimits(count) {
            gen.code(codegen_1._`${count}++`);
            if (max === void 0) {
              gen.if(codegen_1._`${count} >= ${min}`, () => gen.assign(valid, true).break());
            } else {
              gen.if(codegen_1._`${count} > ${max}`, () => gen.assign(valid, false).break());
              if (min === 1)
                gen.assign(valid, true);
              else
                gen.if(codegen_1._`${count} >= ${min}`, () => gen.assign(valid, true));
            }
          }
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/dependencies.js
  var require_dependencies = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var code_1 = require_code2();
      exports.error = {
        message: ({ params: { property, depsCount, deps } }) => {
          const property_ies = depsCount === 1 ? "property" : "properties";
          return codegen_1.str`must have ${property_ies} ${deps} when property ${property} is present`;
        },
        params: ({ params: { property, depsCount, deps, missingProperty } }) => codegen_1._`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
        // TODO change to reference
      };
      var def = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: exports.error,
        code(cxt) {
          const [propDeps, schDeps] = splitDependencies(cxt);
          validatePropertyDeps(cxt, propDeps);
          validateSchemaDeps(cxt, schDeps);
        }
      };
      function splitDependencies({ schema }) {
        const propertyDeps = {};
        const schemaDeps = {};
        for (const key in schema) {
          if (key === "__proto__")
            continue;
          const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
          deps[key] = schema[key];
        }
        return [propertyDeps, schemaDeps];
      }
      function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen, data, it } = cxt;
        if (Object.keys(propertyDeps).length === 0)
          return;
        const missing = gen.let("missing");
        for (const prop in propertyDeps) {
          const deps = propertyDeps[prop];
          if (deps.length === 0)
            continue;
          const hasProperty = code_1.propertyInData(gen, data, prop, it.opts.ownProperties);
          cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(", ")
          });
          if (it.allErrors) {
            gen.if(hasProperty, () => {
              for (const depProp of deps) {
                code_1.checkReportMissingProp(cxt, depProp);
              }
            });
          } else {
            gen.if(codegen_1._`${hasProperty} && (${code_1.checkMissingProp(cxt, deps, missing)})`);
            code_1.reportMissingProp(cxt, missing);
            gen.else();
          }
        }
      }
      exports.validatePropertyDeps = validatePropertyDeps;
      function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen, data, keyword, it } = cxt;
        const valid = gen.name("valid");
        for (const prop in schemaDeps) {
          if (util_1.alwaysValidSchema(it, schemaDeps[prop]))
            continue;
          gen.if(
            code_1.propertyInData(gen, data, prop, it.opts.ownProperties),
            () => {
              const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
              cxt.mergeValidEvaluated(schCxt, valid);
            },
            () => gen.var(valid, true)
            // TODO var
          );
          cxt.ok(valid);
        }
      }
      exports.validateSchemaDeps = validateSchemaDeps;
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
  var require_propertyNames = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: "property name must be valid",
        params: ({ params }) => codegen_1._`{propertyName: ${params.propertyName}}`
      };
      var def = {
        keyword: "propertyNames",
        type: "object",
        schemaType: ["object", "boolean"],
        error,
        code(cxt) {
          const { gen, schema, data, it } = cxt;
          if (util_1.alwaysValidSchema(it, schema))
            return;
          const valid = gen.name("valid");
          gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
              keyword: "propertyNames",
              data: key,
              dataTypes: ["string"],
              propertyName: key,
              compositeRule: true
            }, valid);
            gen.if(codegen_1.not(valid), () => {
              cxt.error(true);
              if (!it.allErrors)
                gen.break();
            });
          });
          cxt.ok(valid);
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
  var require_additionalProperties = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code_1 = require_code2();
      var codegen_1 = require_codegen();
      var names_1 = require_names();
      var util_1 = require_util();
      var error = {
        message: "must NOT have additional properties",
        params: ({ params }) => codegen_1._`{additionalProperty: ${params.additionalProperty}}`
      };
      var def = {
        keyword: "additionalProperties",
        type: ["object"],
        schemaType: ["boolean", "object"],
        allowUndefined: true,
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, errsCount, it } = cxt;
          if (!errsCount)
            throw new Error("ajv implementation error");
          const { allErrors, opts } = it;
          it.props = true;
          if (opts.removeAdditional !== "all" && util_1.alwaysValidSchema(it, schema))
            return;
          const props = code_1.allSchemaProperties(parentSchema.properties);
          const patProps = code_1.allSchemaProperties(parentSchema.patternProperties);
          checkAdditionalProperties();
          cxt.ok(codegen_1._`${errsCount} === ${names_1.default.errors}`);
          function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
              if (!props.length && !patProps.length)
                additionalPropertyCode(key);
              else
                gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
          }
          function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
              const propsSchema = util_1.schemaRefOrVal(it, parentSchema.properties, "properties");
              definedProp = code_1.isOwnProperty(gen, propsSchema, key);
            } else if (props.length) {
              definedProp = codegen_1.or(...props.map((p3) => codegen_1._`${key} === ${p3}`));
            } else {
              definedProp = codegen_1.nil;
            }
            if (patProps.length) {
              definedProp = codegen_1.or(definedProp, ...patProps.map((p3) => codegen_1._`${code_1.usePattern(cxt, p3)}.test(${key})`));
            }
            return codegen_1.not(definedProp);
          }
          function deleteAdditional(key) {
            gen.code(codegen_1._`delete ${data}[${key}]`);
          }
          function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
              deleteAdditional(key);
              return;
            }
            if (schema === false) {
              cxt.setParams({ additionalProperty: key });
              cxt.error();
              if (!allErrors)
                gen.break();
              return;
            }
            if (typeof schema == "object" && !util_1.alwaysValidSchema(it, schema)) {
              const valid = gen.name("valid");
              if (opts.removeAdditional === "failing") {
                applyAdditionalSchema(key, valid, false);
                gen.if(codegen_1.not(valid), () => {
                  cxt.reset();
                  deleteAdditional(key);
                });
              } else {
                applyAdditionalSchema(key, valid);
                if (!allErrors)
                  gen.if(codegen_1.not(valid), () => gen.break());
              }
            }
          }
          function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
              keyword: "additionalProperties",
              dataProp: key,
              dataPropType: util_1.Type.Str
            };
            if (errors === false) {
              Object.assign(subschema, {
                compositeRule: true,
                createErrors: false,
                allErrors: false
              });
            }
            cxt.subschema(subschema, valid);
          }
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/properties.js
  var require_properties = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var validate_1 = require_validate();
      var code_1 = require_code2();
      var util_1 = require_util();
      var additionalProperties_1 = require_additionalProperties();
      var def = {
        keyword: "properties",
        type: "object",
        schemaType: "object",
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt;
          if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
          }
          const allProps = code_1.allSchemaProperties(schema);
          for (const prop of allProps) {
            it.definedProperties.add(prop);
          }
          if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1.mergeEvaluated.props(gen, util_1.toHash(allProps), it.props);
          }
          const properties = allProps.filter((p3) => !util_1.alwaysValidSchema(it, schema[p3]));
          if (properties.length === 0)
            return;
          const valid = gen.name("valid");
          for (const prop of properties) {
            if (hasDefault(prop)) {
              applyPropertySchema(prop);
            } else {
              gen.if(code_1.propertyInData(gen, data, prop, it.opts.ownProperties));
              applyPropertySchema(prop);
              if (!it.allErrors)
                gen.else().var(valid, true);
              gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
          }
          function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
          }
          function applyPropertySchema(prop) {
            cxt.subschema({
              keyword: "properties",
              schemaProp: prop,
              dataProp: prop
            }, valid);
          }
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
  var require_patternProperties = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code_1 = require_code2();
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var util_2 = require_util();
      var def = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code(cxt) {
          const { gen, schema, data, parentSchema, it } = cxt;
          const { opts } = it;
          const patterns = code_1.schemaProperties(it, schema);
          if (patterns.length === 0)
            return;
          const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
          const valid = gen.name("valid");
          if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
            it.props = util_2.evaluatedPropsToName(gen, it.props);
          }
          const { props } = it;
          validatePatternProperties();
          function validatePatternProperties() {
            for (const pat of patterns) {
              if (checkProperties)
                checkMatchingProperties(pat);
              if (it.allErrors) {
                validateProperties(pat);
              } else {
                gen.var(valid, true);
                validateProperties(pat);
                gen.if(valid);
              }
            }
          }
          function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
              if (new RegExp(pat).test(prop)) {
                util_1.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
              }
            }
          }
          function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
              gen.if(codegen_1._`${code_1.usePattern(cxt, pat)}.test(${key})`, () => {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
                if (it.opts.unevaluated && props !== true) {
                  gen.assign(codegen_1._`${props}[${key}]`, true);
                } else if (!it.allErrors) {
                  gen.if(codegen_1.not(valid), () => gen.break());
                }
              });
            });
          }
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/not.js
  var require_not = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var util_1 = require_util();
      var def = {
        keyword: "not",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        code(cxt) {
          const { gen, schema, it } = cxt;
          if (util_1.alwaysValidSchema(it, schema)) {
            cxt.fail();
            return;
          }
          const valid = gen.name("valid");
          cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, valid);
          cxt.result(valid, () => cxt.error(), () => cxt.reset());
        },
        error: { message: "must NOT be valid" }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/anyOf.js
  var require_anyOf = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code_1 = require_code2();
      var def = {
        keyword: "anyOf",
        schemaType: "array",
        trackErrors: true,
        code: code_1.validateUnion,
        error: { message: "must match a schema in anyOf" }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/oneOf.js
  var require_oneOf = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: "must match exactly one schema in oneOf",
        params: ({ params }) => codegen_1._`{passingSchemas: ${params.passing}}`
      };
      var def = {
        keyword: "oneOf",
        schemaType: "array",
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, it } = cxt;
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          if (it.opts.discriminator && parentSchema.discriminator)
            return;
          const schArr = schema;
          const valid = gen.let("valid", false);
          const passing = gen.let("passing", null);
          const schValid = gen.name("_valid");
          cxt.setParams({ passing });
          gen.block(validateOneOf);
          cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
          function validateOneOf() {
            schArr.forEach((sch, i3) => {
              let schCxt;
              if (util_1.alwaysValidSchema(it, sch)) {
                gen.var(schValid, true);
              } else {
                schCxt = cxt.subschema({
                  keyword: "oneOf",
                  schemaProp: i3,
                  compositeRule: true
                }, schValid);
              }
              if (i3 > 0) {
                gen.if(codegen_1._`${schValid} && ${valid}`).assign(valid, false).assign(passing, codegen_1._`[${passing}, ${i3}]`).else();
              }
              gen.if(schValid, () => {
                gen.assign(valid, true);
                gen.assign(passing, i3);
                if (schCxt)
                  cxt.mergeEvaluated(schCxt, codegen_1.Name);
              });
            });
          }
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/allOf.js
  var require_allOf = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var util_1 = require_util();
      var def = {
        keyword: "allOf",
        schemaType: "array",
        code(cxt) {
          const { gen, schema, it } = cxt;
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const valid = gen.name("valid");
          schema.forEach((sch, i3) => {
            if (util_1.alwaysValidSchema(it, sch))
              return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i3 }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
          });
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/if.js
  var require_if = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: ({ params }) => codegen_1.str`must match "${params.ifClause}" schema`,
        params: ({ params }) => codegen_1._`{failingKeyword: ${params.ifClause}}`
      };
      var def = {
        keyword: "if",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, parentSchema, it } = cxt;
          if (parentSchema.then === void 0 && parentSchema.else === void 0) {
            util_1.checkStrictMode(it, '"if" without "then" and "else" is ignored');
          }
          const hasThen = hasSchema(it, "then");
          const hasElse = hasSchema(it, "else");
          if (!hasThen && !hasElse)
            return;
          const valid = gen.let("valid", true);
          const schValid = gen.name("_valid");
          validateIf();
          cxt.reset();
          if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
          } else if (hasThen) {
            gen.if(schValid, validateClause("then"));
          } else {
            gen.if(codegen_1.not(schValid), validateClause("else"));
          }
          cxt.pass(valid, () => cxt.error(true));
          function validateIf() {
            const schCxt = cxt.subschema({
              keyword: "if",
              compositeRule: true,
              createErrors: false,
              allErrors: false
            }, schValid);
            cxt.mergeEvaluated(schCxt);
          }
          function validateClause(keyword, ifClause) {
            return () => {
              const schCxt = cxt.subschema({ keyword }, schValid);
              gen.assign(valid, schValid);
              cxt.mergeValidEvaluated(schCxt, valid);
              if (ifClause)
                gen.assign(ifClause, codegen_1._`${keyword}`);
              else
                cxt.setParams({ ifClause: keyword });
            };
          }
        }
      };
      function hasSchema(it, keyword) {
        const schema = it.schema[keyword];
        return schema !== void 0 && !util_1.alwaysValidSchema(it, schema);
      }
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/thenElse.js
  var require_thenElse = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var util_1 = require_util();
      var def = {
        keyword: ["then", "else"],
        schemaType: ["object", "boolean"],
        code({ keyword, parentSchema, it }) {
          if (parentSchema.if === void 0)
            util_1.checkStrictMode(it, `"${keyword}" without "if" is ignored`);
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/applicator/index.js
  var require_applicator = __commonJS({
    "../node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var additionalItems_1 = require_additionalItems();
      var prefixItems_1 = require_prefixItems();
      var items_1 = require_items();
      var items2020_1 = require_items2020();
      var contains_1 = require_contains();
      var dependencies_1 = require_dependencies();
      var propertyNames_1 = require_propertyNames();
      var additionalProperties_1 = require_additionalProperties();
      var properties_1 = require_properties();
      var patternProperties_1 = require_patternProperties();
      var not_1 = require_not();
      var anyOf_1 = require_anyOf();
      var oneOf_1 = require_oneOf();
      var allOf_1 = require_allOf();
      var if_1 = require_if();
      var thenElse_1 = require_thenElse();
      function getApplicator(draft2020 = false) {
        const applicator = [
          // any
          not_1.default,
          anyOf_1.default,
          oneOf_1.default,
          allOf_1.default,
          if_1.default,
          thenElse_1.default,
          // object
          propertyNames_1.default,
          additionalProperties_1.default,
          dependencies_1.default,
          properties_1.default,
          patternProperties_1.default
        ];
        if (draft2020)
          applicator.push(prefixItems_1.default, items2020_1.default);
        else
          applicator.push(additionalItems_1.default, items_1.default);
        applicator.push(contains_1.default);
        return applicator;
      }
      exports.default = getApplicator;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/format/format.js
  var require_format = __commonJS({
    "../node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var error = {
        message: ({ schemaCode }) => codegen_1.str`must match format "${schemaCode}"`,
        params: ({ schemaCode }) => codegen_1._`{format: ${schemaCode}}`
      };
      var def = {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: true,
        error,
        code(cxt, ruleType) {
          const { gen, data, $data, schema, schemaCode, it } = cxt;
          const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
          if (!opts.validateFormats)
            return;
          if ($data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fDef = gen.const("fDef", codegen_1._`${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format = gen.let("format");
            gen.if(codegen_1._`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1._`${fDef}.type || "string"`).assign(format, codegen_1._`${fDef}.validate`), () => gen.assign(fType, codegen_1._`"string"`).assign(format, fDef));
            cxt.fail$data(codegen_1.or(unknownFmt(), invalidFmt()));
            function unknownFmt() {
              if (opts.strictSchema === false)
                return codegen_1.nil;
              return codegen_1._`${schemaCode} && !${format}`;
            }
            function invalidFmt() {
              const callFormat = schemaEnv.$async ? codegen_1._`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : codegen_1._`${format}(${data})`;
              const validData = codegen_1._`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
              return codegen_1._`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
          }
          function validateFormat() {
            const formatDef = self2.formats[schema];
            if (!formatDef) {
              unknownFormat();
              return;
            }
            if (formatDef === true)
              return;
            const [fmtType, format, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
              cxt.pass(validCondition());
            function unknownFormat() {
              if (opts.strictSchema === false) {
                self2.logger.warn(unknownMsg());
                return;
              }
              throw new Error(unknownMsg());
              function unknownMsg() {
                return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
              }
            }
            function getFormat(fmtDef) {
              const code = fmtDef instanceof RegExp ? codegen_1.regexpCode(fmtDef) : opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(schema)}` : void 0;
              const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
              if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                return [fmtDef.type || "string", fmtDef.validate, codegen_1._`${fmt}.validate`];
              }
              return ["string", fmtDef, fmt];
            }
            function validCondition() {
              if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                if (!schemaEnv.$async)
                  throw new Error("async format in sync schema");
                return codegen_1._`await ${fmtRef}(${data})`;
              }
              return typeof format == "function" ? codegen_1._`${fmtRef}(${data})` : codegen_1._`${fmtRef}.test(${data})`;
            }
          }
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/format/index.js
  var require_format2 = __commonJS({
    "../node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var format_1 = require_format();
      var format = [format_1.default];
      exports.default = format;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/metadata.js
  var require_metadata = __commonJS({
    "../node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.contentVocabulary = exports.metadataVocabulary = void 0;
      exports.metadataVocabulary = [
        "title",
        "description",
        "default",
        "deprecated",
        "readOnly",
        "writeOnly",
        "examples"
      ];
      exports.contentVocabulary = [
        "contentMediaType",
        "contentEncoding",
        "contentSchema"
      ];
    }
  });

  // ../node_modules/ajv/dist/vocabularies/draft7.js
  var require_draft7 = __commonJS({
    "../node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var core_1 = require_core2();
      var validation_1 = require_validation();
      var applicator_1 = require_applicator();
      var format_1 = require_format2();
      var metadata_1 = require_metadata();
      var draft7Vocabularies = [
        core_1.default,
        validation_1.default,
        applicator_1.default(),
        format_1.default,
        metadata_1.metadataVocabulary,
        metadata_1.contentVocabulary
      ];
      exports.default = draft7Vocabularies;
    }
  });

  // ../node_modules/ajv/dist/vocabularies/discriminator/types.js
  var require_types = __commonJS({
    "../node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiscrError = void 0;
      var DiscrError;
      (function(DiscrError2) {
        DiscrError2["Tag"] = "tag";
        DiscrError2["Mapping"] = "mapping";
      })(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
    }
  });

  // ../node_modules/ajv/dist/vocabularies/discriminator/index.js
  var require_discriminator = __commonJS({
    "../node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var types_1 = require_types();
      var error = {
        message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
        params: ({ params: { discrError, tag, tagName } }) => codegen_1._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
      };
      var def = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error,
        code(cxt) {
          const { gen, data, schema, parentSchema, it } = cxt;
          const { oneOf } = parentSchema;
          if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
          }
          const tagName = schema.propertyName;
          if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
          if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
          if (!oneOf)
            throw new Error("discriminator: requires oneOf keyword");
          const valid = gen.let("valid", false);
          const tag = gen.const("tag", codegen_1._`${data}${codegen_1.getProperty(tagName)}`);
          gen.if(codegen_1._`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
          cxt.ok(valid);
          function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
              gen.elseIf(codegen_1._`${tag} === ${tagValue}`);
              gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
            gen.endIf();
          }
          function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
          }
          function getMapping() {
            var _a;
            const oneOfMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i3 = 0; i3 < oneOf.length; i3++) {
              const sch = oneOf[i3];
              const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
              if (typeof propSch != "object") {
                throw new Error(`discriminator: oneOf schemas must have "properties/${tagName}"`);
              }
              tagRequired = tagRequired && (topRequired || hasRequired(sch));
              addMappings(propSch, i3);
            }
            if (!tagRequired)
              throw new Error(`discriminator: "${tagName}" must be required`);
            return oneOfMapping;
            function hasRequired({ required }) {
              return Array.isArray(required) && required.includes(tagName);
            }
            function addMappings(sch, i3) {
              if (sch.const) {
                addMapping(sch.const, i3);
              } else if (sch.enum) {
                for (const tagValue of sch.enum) {
                  addMapping(tagValue, i3);
                }
              } else {
                throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
              }
            }
            function addMapping(tagValue, i3) {
              if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                throw new Error(`discriminator: "${tagName}" values must be unique strings`);
              }
              oneOfMapping[tagValue] = i3;
            }
          }
        }
      };
      exports.default = def;
    }
  });

  // ../node_modules/ajv/dist/refs/json-schema-draft-07.json
  var require_json_schema_draft_07 = __commonJS({
    "../node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
      module.exports = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "http://json-schema.org/draft-07/schema#",
        title: "Core schema meta-schema",
        definitions: {
          schemaArray: {
            type: "array",
            minItems: 1,
            items: { $ref: "#" }
          },
          nonNegativeInteger: {
            type: "integer",
            minimum: 0
          },
          nonNegativeIntegerDefault0: {
            allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
          },
          simpleTypes: {
            enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
          },
          stringArray: {
            type: "array",
            items: { type: "string" },
            uniqueItems: true,
            default: []
          }
        },
        type: ["object", "boolean"],
        properties: {
          $id: {
            type: "string",
            format: "uri-reference"
          },
          $schema: {
            type: "string",
            format: "uri"
          },
          $ref: {
            type: "string",
            format: "uri-reference"
          },
          $comment: {
            type: "string"
          },
          title: {
            type: "string"
          },
          description: {
            type: "string"
          },
          default: true,
          readOnly: {
            type: "boolean",
            default: false
          },
          examples: {
            type: "array",
            items: true
          },
          multipleOf: {
            type: "number",
            exclusiveMinimum: 0
          },
          maximum: {
            type: "number"
          },
          exclusiveMaximum: {
            type: "number"
          },
          minimum: {
            type: "number"
          },
          exclusiveMinimum: {
            type: "number"
          },
          maxLength: { $ref: "#/definitions/nonNegativeInteger" },
          minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          pattern: {
            type: "string",
            format: "regex"
          },
          additionalItems: { $ref: "#" },
          items: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
            default: true
          },
          maxItems: { $ref: "#/definitions/nonNegativeInteger" },
          minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          uniqueItems: {
            type: "boolean",
            default: false
          },
          contains: { $ref: "#" },
          maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
          minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          required: { $ref: "#/definitions/stringArray" },
          additionalProperties: { $ref: "#" },
          definitions: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          properties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          patternProperties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            propertyNames: { format: "regex" },
            default: {}
          },
          dependencies: {
            type: "object",
            additionalProperties: {
              anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
            }
          },
          propertyNames: { $ref: "#" },
          const: true,
          enum: {
            type: "array",
            items: true,
            minItems: 1,
            uniqueItems: true
          },
          type: {
            anyOf: [
              { $ref: "#/definitions/simpleTypes" },
              {
                type: "array",
                items: { $ref: "#/definitions/simpleTypes" },
                minItems: 1,
                uniqueItems: true
              }
            ]
          },
          format: { type: "string" },
          contentMediaType: { type: "string" },
          contentEncoding: { type: "string" },
          if: { $ref: "#" },
          then: { $ref: "#" },
          else: { $ref: "#" },
          allOf: { $ref: "#/definitions/schemaArray" },
          anyOf: { $ref: "#/definitions/schemaArray" },
          oneOf: { $ref: "#/definitions/schemaArray" },
          not: { $ref: "#" }
        },
        default: true
      };
    }
  });

  // ../node_modules/ajv/dist/ajv.js
  var require_ajv = __commonJS({
    "../node_modules/ajv/dist/ajv.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
      var core_1 = require_core();
      var draft7_1 = require_draft7();
      var discriminator_1 = require_discriminator();
      var draft7MetaSchema = require_json_schema_draft_07();
      var META_SUPPORT_DATA = ["/properties"];
      var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
      var Ajv2 = class extends core_1.default {
        _addVocabularies() {
          super._addVocabularies();
          draft7_1.default.forEach((v3) => this.addVocabulary(v3));
          if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema();
          if (!this.opts.meta)
            return;
          const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
          this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
          this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
        }
      };
      module.exports = exports = Ajv2;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = Ajv2;
      var validate_1 = require_validate();
      Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
        return validate_1.KeywordCxt;
      } });
      var codegen_1 = require_codegen();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return codegen_1._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return codegen_1.str;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return codegen_1.stringify;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return codegen_1.nil;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return codegen_1.Name;
      } });
      Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
        return codegen_1.CodeGen;
      } });
    }
  });

  // ../node_modules/ajv-formats/dist/formats.js
  var require_formats = __commonJS({
    "../node_modules/ajv-formats/dist/formats.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
      function fmtDef(validate, compare) {
        return { validate, compare };
      }
      exports.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: fmtDef(date, compareDate),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: fmtDef(time, compareTime),
        "date-time": fmtDef(date_time, compareDateTime),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte: /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm,
        // signed 32 bit integer
        int32: { type: "number", validate: validateInt32 },
        // signed 64 bit integer
        int64: { type: "number", validate: validateInt64 },
        // C-type float
        float: { type: "number", validate: validateNumber },
        // C-type double
        double: { type: "number", validate: validateNumber },
        // hint to the UI to hide input strings
        password: true,
        // unchecked string payload
        binary: true
      };
      exports.fastFormats = __spreadProps(__spreadValues({}, exports.fullFormats), {
        date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
        time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
        "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      });
      exports.formatNames = Object.keys(exports.fullFormats);
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function date(str2) {
        const matches = DATE.exec(str2);
        if (!matches)
          return false;
        const year = +matches[1];
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function compareDate(d1, d22) {
        if (!(d1 && d22))
          return void 0;
        if (d1 > d22)
          return 1;
        if (d1 < d22)
          return -1;
        return 0;
      }
      var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
      function time(str2, withTimeZone) {
        const matches = TIME.exec(str2);
        if (!matches)
          return false;
        const hour = +matches[1];
        const minute = +matches[2];
        const second = +matches[3];
        const timeZone = matches[5];
        return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
      }
      function compareTime(t1, t22) {
        if (!(t1 && t22))
          return void 0;
        const a1 = TIME.exec(t1);
        const a22 = TIME.exec(t22);
        if (!(a1 && a22))
          return void 0;
        t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
        t22 = a22[1] + a22[2] + a22[3] + (a22[4] || "");
        if (t1 > t22)
          return 1;
        if (t1 < t22)
          return -1;
        return 0;
      }
      var DATE_TIME_SEPARATOR = /t|\s/i;
      function date_time(str2) {
        const dateTime = str2.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
      }
      function compareDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
        const [d22, t22] = dt2.split(DATE_TIME_SEPARATOR);
        const res = compareDate(d1, d22);
        if (res === void 0)
          return void 0;
        return res || compareTime(t1, t22);
      }
      var NOT_URI_FRAGMENT = /\/|:/;
      var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function uri(str2) {
        return NOT_URI_FRAGMENT.test(str2) && URI.test(str2);
      }
      var MIN_INT32 = -(2 ** 31);
      var MAX_INT32 = 2 ** 31 - 1;
      function validateInt32(value) {
        return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
      }
      function validateInt64(value) {
        return Number.isInteger(value);
      }
      function validateNumber() {
        return true;
      }
      var Z_ANCHOR = /[^\\]\\Z/;
      function regex(str2) {
        if (Z_ANCHOR.test(str2))
          return false;
        try {
          new RegExp(str2);
          return true;
        } catch (e2) {
          return false;
        }
      }
    }
  });

  // ../node_modules/ajv-formats/dist/limit.js
  var require_limit = __commonJS({
    "../node_modules/ajv-formats/dist/limit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatLimitDefinition = void 0;
      var ajv_1 = require_ajv();
      var codegen_1 = require_codegen();
      var ops = codegen_1.operators;
      var KWDs = {
        formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
      };
      var error = {
        message: ({ keyword, schemaCode }) => codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
        params: ({ keyword, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
      };
      exports.formatLimitDefinition = {
        keyword: Object.keys(KWDs),
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, keyword, it } = cxt;
          const { opts, self: self2 } = it;
          if (!opts.validateFormats)
            return;
          const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
          if (fCxt.$data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fmt = gen.const("fmt", codegen_1._`${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != "object"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
          }
          function validateFormat() {
            const format = fCxt.schema;
            const fmtDef = self2.formats[format];
            if (!fmtDef || fmtDef === true)
              return;
            if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
              throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
              key: format,
              ref: fmtDef,
              code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format)}` : void 0
            });
            cxt.fail$data(compareCode(fmt));
          }
          function compareCode(fmt) {
            return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      var formatLimitPlugin = (ajv) => {
        ajv.addKeyword(exports.formatLimitDefinition);
        return ajv;
      };
      exports.default = formatLimitPlugin;
    }
  });

  // ../node_modules/ajv-formats/dist/index.js
  var require_dist = __commonJS({
    "../node_modules/ajv-formats/dist/index.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var formats_1 = require_formats();
      var limit_1 = require_limit();
      var codegen_1 = require_codegen();
      var fullName = new codegen_1.Name("fullFormats");
      var fastName = new codegen_1.Name("fastFormats");
      var formatsPlugin = (ajv, opts = { keywords: true }) => {
        if (Array.isArray(opts)) {
          addFormats2(ajv, opts, formats_1.fullFormats, fullName);
          return ajv;
        }
        const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
        const list = opts.formats || formats_1.formatNames;
        addFormats2(ajv, list, formats, exportName);
        if (opts.keywords)
          limit_1.default(ajv);
        return ajv;
      };
      formatsPlugin.get = (name, mode = "full") => {
        const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
        const f3 = formats[name];
        if (!f3)
          throw new Error(`Unknown format "${name}"`);
        return f3;
      };
      function addFormats2(ajv, list, fs, exportName) {
        var _a;
        var _b;
        (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`;
        for (const f3 of list)
          ajv.addFormat(f3, fs[f3]);
      }
      module.exports = exports = formatsPlugin;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = formatsPlugin;
    }
  });

  // ../node_modules/ajv/dist/standalone/index.js
  var require_standalone = __commonJS({
    "../node_modules/ajv/dist/standalone/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var scope_1 = require_scope();
      var code_1 = require_code();
      function standaloneCode2(ajv, refsOrFunc) {
        if (!ajv.opts.code.source) {
          throw new Error("moduleCode: ajv instance must have code.source option");
        }
        const { _n } = ajv.scope.opts;
        return typeof refsOrFunc == "function" ? funcExportCode(refsOrFunc.source) : refsOrFunc !== void 0 ? multiExportsCode(refsOrFunc, getValidate) : multiExportsCode(ajv.schemas, (sch) => sch.meta ? void 0 : ajv.compile(sch.schema));
        function getValidate(id) {
          const v3 = ajv.getSchema(id);
          if (!v3)
            throw new Error(`moduleCode: no schema with id ${id}`);
          return v3;
        }
        function funcExportCode(source) {
          const usedValues = {};
          const n3 = source === null || source === void 0 ? void 0 : source.validateName;
          const vCode = validateCode(usedValues, source);
          return `"use strict";${_n}module.exports = ${n3};${_n}module.exports.default = ${n3};${_n}${vCode}`;
        }
        function multiExportsCode(schemas2, getValidateFunc) {
          var _a;
          const usedValues = {};
          let code = code_1._`"use strict";`;
          for (const name in schemas2) {
            const v3 = getValidateFunc(schemas2[name]);
            if (v3) {
              const vCode = validateCode(usedValues, v3.source);
              code = code_1._`${code}${_n}exports${code_1.getProperty(name)} = ${(_a = v3.source) === null || _a === void 0 ? void 0 : _a.validateName};${_n}${vCode}`;
            }
          }
          return `${code}`;
        }
        function validateCode(usedValues, s3) {
          if (!s3)
            throw new Error('moduleCode: function does not have "source" property');
          if (usedState(s3.validateName) === scope_1.UsedValueState.Completed)
            return code_1.nil;
          setUsedState(s3.validateName, scope_1.UsedValueState.Started);
          const scopeCode = ajv.scope.scopeCode(s3.scopeValues, usedValues, refValidateCode);
          const code = new code_1._Code(`${scopeCode}${_n}${s3.validateCode}`);
          return s3.evaluated ? code_1._`${code}${s3.validateName}.evaluated = ${s3.evaluated};${_n}` : code;
          function refValidateCode(n3) {
            var _a;
            const vRef = (_a = n3.value) === null || _a === void 0 ? void 0 : _a.ref;
            if (n3.prefix === "validate" && typeof vRef == "function") {
              const v3 = vRef;
              return validateCode(usedValues, v3.source);
            } else if ((n3.prefix === "root" || n3.prefix === "wrapper") && typeof vRef == "object") {
              const { validate, validateName } = vRef;
              if (!validateName)
                throw new Error("ajv internal error");
              const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
              const wrapper = code_1._`${def} ${n3} = {validate: ${validateName}};`;
              if (usedState(validateName) === scope_1.UsedValueState.Started)
                return wrapper;
              const vCode = validateCode(usedValues, validate === null || validate === void 0 ? void 0 : validate.source);
              return code_1._`${wrapper}${_n}${vCode}`;
            }
            return void 0;
          }
          function usedState(name) {
            var _a;
            return (_a = usedValues[name.prefix]) === null || _a === void 0 ? void 0 : _a.get(name);
          }
          function setUsedState(name, state) {
            const { prefix } = name;
            const names = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
            names.set(name, state);
          }
        }
      }
      exports.default = standaloneCode2;
    }
  });

  // ../node_modules/lodash/mapValues.js
  var require_mapValues = __commonJS({
    "../node_modules/lodash/mapValues.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      function mapValues3(object, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result, key, iteratee(value, key, object2));
        });
        return result;
      }
      module.exports = mapValues3;
    }
  });

  // ../node_modules/lodash/_baseSet.js
  var require_baseSet = __commonJS({
    "../node_modules/lodash/_baseSet.js"(exports, module) {
      var assignValue = require_assignValue();
      var castPath = require_castPath();
      var isIndex = require_isIndex();
      var isObject3 = require_isObject();
      var toKey = require_toKey();
      function baseSet(object, path, value, customizer) {
        if (!isObject3(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject3(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      module.exports = baseSet;
    }
  });

  // ../node_modules/lodash/_basePickBy.js
  var require_basePickBy = __commonJS({
    "../node_modules/lodash/_basePickBy.js"(exports, module) {
      var baseGet = require_baseGet();
      var baseSet = require_baseSet();
      var castPath = require_castPath();
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }
      module.exports = basePickBy;
    }
  });

  // ../node_modules/lodash/_basePick.js
  var require_basePick = __commonJS({
    "../node_modules/lodash/_basePick.js"(exports, module) {
      var basePickBy = require_basePickBy();
      var hasIn = require_hasIn();
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      module.exports = basePick;
    }
  });

  // ../node_modules/lodash/_isFlattenable.js
  var require_isFlattenable = __commonJS({
    "../node_modules/lodash/_isFlattenable.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var isArguments = require_isArguments();
      var isArray3 = require_isArray();
      var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray3(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      module.exports = isFlattenable;
    }
  });

  // ../node_modules/lodash/_baseFlatten.js
  var require_baseFlatten = __commonJS({
    "../node_modules/lodash/_baseFlatten.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var isFlattenable = require_isFlattenable();
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      module.exports = baseFlatten;
    }
  });

  // ../node_modules/lodash/flatten.js
  var require_flatten = __commonJS({
    "../node_modules/lodash/flatten.js"(exports, module) {
      var baseFlatten = require_baseFlatten();
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      module.exports = flatten;
    }
  });

  // ../node_modules/lodash/_flatRest.js
  var require_flatRest = __commonJS({
    "../node_modules/lodash/_flatRest.js"(exports, module) {
      var flatten = require_flatten();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten), func + "");
      }
      module.exports = flatRest;
    }
  });

  // ../node_modules/lodash/pick.js
  var require_pick = __commonJS({
    "../node_modules/lodash/pick.js"(exports, module) {
      var basePick = require_basePick();
      var flatRest = require_flatRest();
      var pick3 = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      module.exports = pick3;
    }
  });

  // ../node_modules/lodash/set.js
  var require_set = __commonJS({
    "../node_modules/lodash/set.js"(exports, module) {
      var baseSet = require_baseSet();
      function set2(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      module.exports = set2;
    }
  });

  // ../node_modules/lodash/_baseValues.js
  var require_baseValues = __commonJS({
    "../node_modules/lodash/_baseValues.js"(exports, module) {
      var arrayMap = require_arrayMap();
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      module.exports = baseValues;
    }
  });

  // ../node_modules/lodash/values.js
  var require_values = __commonJS({
    "../node_modules/lodash/values.js"(exports, module) {
      var baseValues = require_baseValues();
      var keys4 = require_keys();
      function values2(object) {
        return object == null ? [] : baseValues(object, keys4(object));
      }
      module.exports = values2;
    }
  });

  // ../howdju-common/lib/zodError.ts
  function errorFormatToString(errorFormat) {
    switch (errorFormat.code) {
      case "invalid_type": {
        const { received, message } = errorFormat;
        if (received === "undefined" && message === "Required") {
          const rawName = errorFormat.path[errorFormat.path.length - 1];
          if (!(0, import_lodash9.isString)(rawName)) {
            logger.warn(
              `errorFormatToString got a type that doesn't format nicely (${rawName}: ${typeof rawName})`
            );
          }
          const name = (0, import_lodash9.toString)(rawName);
          const casedName = (0, import_lodash9.startCase)(name);
          return `${casedName} is required`;
        }
        return errorFormat.message;
      }
      case "invalid_union_discriminator": {
        const { options } = errorFormat;
        const joinedOptions = (0, import_lodash9.join)((0, import_lodash9.map)(options, import_lodash9.startCase), ", ");
        return `Invalid option. Must be one of: ${joinedOptions}`;
      }
      default:
        return errorFormat.message;
    }
  }
  function formatZodError(error) {
    return removeZodErrorDupes(error.format(zodIssueFormatter));
  }
  function makeZodCustomIssuesError(issueDescriptors) {
    const issues = issueDescriptors.map(
      (d3) => d3(makeCallableProxy())
    );
    return new mod.ZodError(issues);
  }
  function makeModelErrors(...issueDescriptors) {
    return formatZodError(makeZodCustomIssuesError(issueDescriptors));
  }
  function makeCallableProxy() {
    const names = [];
    return new Proxy(
      callableProxyTarget,
      {
        get(_target, name, receiver) {
          names.push(name);
          return receiver;
        },
        apply(_target, _thisArg, argumentsList) {
          if (argumentsList.length !== 1) {
            throw new Error("Must be a single argument.");
          }
          let props;
          const arg = argumentsList[0];
          if ((0, import_lodash9.isString)(arg)) {
            props = { message: arg };
          } else if ("message" in arg) {
            props = arg;
          } else {
            throw new Error(
              "Argument must be a string or an object with at least a .message property."
            );
          }
          return __spreadValues({
            code: mod.ZodIssueCode.custom,
            path: names
          }, props);
        }
      }
    );
  }
  function removeZodErrorDupes(error) {
    return mapValuesDeep(
      error,
      (val, key) => {
        if (key === "_errors") {
          assert((0, import_lodash9.isArray)(val));
          return (0, import_lodash9.uniqWith)(val, import_lodash9.isEqual);
        }
        return val;
      },
      { mapArrays: false }
    );
  }
  var import_lodash9, zodIssueFormatter, callableProxyTarget;
  var init_zodError = __esm({
    "../howdju-common/lib/zodError.ts"() {
      "use strict";
      import_lodash9 = __toESM(require_lodash());
      init_lib();
      init_general();
      init_logger();
      zodIssueFormatter = (issue) => issue;
      callableProxyTarget = function() {
      };
    }
  });

  // ../howdju-common/lib/schemaValidation.ts
  var schemaValidation_exports = {};
  __export(schemaValidation_exports, {
    emptyValidationResult: () => emptyValidationResult,
    jsonPointerToObjectPath: () => jsonPointerToObjectPath,
    makeAjv: () => makeAjv,
    makeStandaloneCode: () => makeStandaloneCode,
    makeStandaloneValidate: () => makeStandaloneValidate,
    makeValidate: () => makeValidate,
    makeValidateRawErrors: () => makeValidateRawErrors,
    schemaIds: () => schemaIds,
    translateAjvToZodFormattedError: () => translateAjvToZodFormattedError
  });
  function makeStandaloneCode() {
    const ajv = makeAjv({ code: { source: true } });
    return (0, import_standalone.default)(ajv);
  }
  function makeAjv(extraOpts) {
    const opts = (0, import_assign2.default)(
      {},
      {
        // https://github.com/epoberezkin/ajv#options
        // allow $data references
        $data: true,
        // report all errors with data, not just the first error
        allErrors: true,
        verbose: true
      },
      extraOpts
    );
    const ajv = new import_ajv.default(opts).addSchema((0, import_values.default)(schemas)).addSchema(definitionsSchema);
    (0, import_ajv_formats.default)(ajv);
    return ajv;
  }
  function makeStandaloneValidate(validateFunctions) {
    return function validate(schemaOrRef, data) {
      const validationFunction = validateFunctions[schemaOrRef];
      const jsonVal = toJsonVal(data);
      const isValid2 = validationFunction(jsonVal);
      const errors = isValid2 ? {} : transformErrors(validationFunction.errors);
      return { isValid: isValid2, errors };
    };
  }
  function makeValidateRawErrors(ajv) {
    return function validateRawErrors(schemaOrRef, data) {
      const jsonVal = toJsonVal(data);
      const isValid2 = ajv.validate(schemaOrRef, jsonVal);
      return { isValid: isValid2, errors: ajv.errors };
    };
  }
  function makeValidate(ajv) {
    const rawValidate = makeValidateRawErrors(ajv);
    return function validate(schemaOrRef, data) {
      if (!data) {
        return emptyValidationResult();
      }
      const result = rawValidate(schemaOrRef, data);
      const isValid2 = result.isValid;
      const errors = isValid2 ? {} : (
        // @ts-ignore: avoid `Type instantiation is excessively deep and possibly infinite.`
        transformErrors(result.errors)
      );
      return { isValid: isValid2, errors };
    };
  }
  function transformErrors(errors) {
    return (0, import_reduce2.default)(
      errors,
      (transformed, error) => {
        let name;
        if (error.instancePath === "") {
          if (error.keyword === "required") {
            name = error.params.missingProperty;
          } else {
            throw new Error(`unsupported Ajv error ${JSON.stringify(error)}`);
          }
        } else {
          name = error.instancePath.substr(1);
        }
        (0, import_set.default)(transformed, name, (0, import_pick.default)(error, ["keyword", "message", "params"]));
        return transformed;
      },
      {}
    );
  }
  function toJsonVal(val) {
    return fromJson(toJson(val));
  }
  function emptyValidationResult(_schemaOrRef) {
    return { isValid: true, errors: {} };
  }
  function translateAjvToZodFormattedError(errors) {
    const issues = errors ? errors.map((error) => {
      let name;
      if (error.instancePath === "") {
        if (error.keyword === "required") {
          name = error.params.missingProperty;
        } else {
          throw new Error(`unsupported Ajv error ${JSON.stringify(error)}`);
        }
      } else {
        name = error.instancePath.substr(1);
      }
      return {
        path: jsonPointerToObjectPath(name),
        code: mod.ZodIssueCode.custom,
        message: error.message || "Unknown error"
      };
    }) : [];
    return new mod.ZodError(issues).format(zodIssueFormatter);
  }
  function jsonPointerToObjectPath(jsonPointer) {
    return jsonPointer.split("/").map((val) => {
      const parsed = (0, import_lodash10.parseInt)(val);
      return (0, import_lodash10.isNaN)(parsed) ? val : parsed;
    });
  }
  var import_ajv, import_ajv_formats, import_standalone, import_mapValues, import_assign2, import_pick, import_set, import_reduce2, import_values, import_lodash10, schemaIds;
  var init_schemaValidation = __esm({
    "../howdju-common/lib/schemaValidation.ts"() {
      "use strict";
      import_ajv = __toESM(require_ajv());
      import_ajv_formats = __toESM(require_dist());
      import_standalone = __toESM(require_standalone());
      import_mapValues = __toESM(require_mapValues());
      import_assign2 = __toESM(require_assign());
      import_pick = __toESM(require_pick());
      import_set = __toESM(require_set());
      import_reduce2 = __toESM(require_reduce());
      import_values = __toESM(require_values());
      import_lodash10 = __toESM(require_lodash());
      init_lib();
      init_general();
      init_schemas();
      init_zodError();
      schemaIds = (0, import_mapValues.default)(schemas, (schema) => schema["$id"]);
    }
  });

  // ../howdju-common/lib/standaloneAjv.js
  var require_standaloneAjv = __commonJS({
    "../howdju-common/lib/standaloneAjv.js"(exports) {
      "use strict";
      exports["https://howdju.com/schemas/content-report.schema.json"] = validate10;
      var schema27 = { "$id": "https://howdju.com/schemas/content-report.schema.json", "$schema": "http://json-schema.org/draft-07/schema#", "title": "Content Report", "description": "A user-submitted report of content that may violate our policies.", "type": "object", "required": ["url", "types"], "properties": { "entityType": { "description": "The type of entity being reported, if the report can pertain to a particular entity.", "enum": ["APPEARANCE", "JUSTIFICATION", "JUSTIFICATION_VOTE", "MEDIA_EXCERPT", "PASSWORD_HASH", "PASSWORD_RESET_REQUEST", "PERSORG", "PROPOSITION", "PROPOSITION_TAG_VOTE", "REGISTRATION_REQUEST", "SOURCE", "STATEMENT", "TAG_VOTE", "URL", "URL_LOCATOR", "USER", "WRIT", "WRIT_QUOTE"] }, "entityId": { "$ref": "definitions.json#/definitions/entityId" }, "url": { "description": "The URL upon which the user made the report, and so likely an URL where the content appears.", "type": "string", "format": "uri" }, "types": { "type": "array", "uniqueItems": true, "items": { "enum": ["HARASSMENT", "THREATENING_VIOLENCE", "HATEFUL", "OBSCENE", "SEXUALIZATION_OF_MINORS", "SHARING_PRIVATE_PERSONAL_INFORMATION", "PORNOGRAPHY", "ILLEGAL_ACTIVITY", "IMPERSONATION", "COPYRIGHT_VIOLATION", "TRADEMARK_VIOLATION", "SPAM", "OTHER"] }, "minItems": 1 }, "description": { "description": "The user's description of the report.", "type": "string", "maxLength": 4096 } } };
      var schema29 = { "type": "string", "format": "int32", "description": "An identifier for an entity. Usually used in the database to identify the entity. A positive integer formatted as a string.", "examples": ["1", "2", "42"] };
      var func0 = require_equal().default;
      var func7 = require_ucs2length().default;
      var formats0 = require_formats().fullFormats.int32;
      var formats2 = require_formats().fullFormats.uri;
      function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
        ;
        let vErrors = null;
        let errors = 0;
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.url === void 0) {
            const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "url" }, message: "must have required property 'url'", schema: schema27.required, parentSchema: schema27, data };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
          if (data.types === void 0) {
            const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "types" }, message: "must have required property 'types'", schema: schema27.required, parentSchema: schema27, data };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
          if (data.entityType !== void 0) {
            let data0 = data.entityType;
            if (!(data0 === "APPEARANCE" || data0 === "JUSTIFICATION" || data0 === "JUSTIFICATION_VOTE" || data0 === "MEDIA_EXCERPT" || data0 === "PASSWORD_HASH" || data0 === "PASSWORD_RESET_REQUEST" || data0 === "PERSORG" || data0 === "PROPOSITION" || data0 === "PROPOSITION_TAG_VOTE" || data0 === "REGISTRATION_REQUEST" || data0 === "SOURCE" || data0 === "STATEMENT" || data0 === "TAG_VOTE" || data0 === "URL" || data0 === "URL_LOCATOR" || data0 === "USER" || data0 === "WRIT" || data0 === "WRIT_QUOTE")) {
              const err2 = { instancePath: instancePath + "/entityType", schemaPath: "#/properties/entityType/enum", keyword: "enum", params: { allowedValues: schema27.properties.entityType.enum }, message: "must be equal to one of the allowed values", schema: schema27.properties.entityType.enum, parentSchema: schema27.properties.entityType, data: data0 };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors++;
            }
          }
          if (data.entityId !== void 0) {
            let data1 = data.entityId;
            if (typeof data1 == "number" && isFinite(data1)) {
              if (!formats0.validate(data1)) {
                const err3 = { instancePath: instancePath + "/entityId", schemaPath: "definitions.json#/definitions/entityId/format", keyword: "format", params: { format: "int32" }, message: 'must match format "int32"', schema: "int32", parentSchema: schema29, data: data1 };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors++;
              }
            }
            if (!(typeof data1 === "string")) {
              const err4 = { instancePath: instancePath + "/entityId", schemaPath: "definitions.json#/definitions/entityId/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema29.type, parentSchema: schema29, data: data1 };
              if (vErrors === null) {
                vErrors = [err4];
              } else {
                vErrors.push(err4);
              }
              errors++;
            }
          }
          if (data.url !== void 0) {
            let data2 = data.url;
            if (typeof data2 === "string") {
              if (!formats2(data2)) {
                const err5 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"', schema: "uri", parentSchema: schema27.properties.url, data: data2 };
                if (vErrors === null) {
                  vErrors = [err5];
                } else {
                  vErrors.push(err5);
                }
                errors++;
              }
            } else {
              const err6 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema27.properties.url.type, parentSchema: schema27.properties.url, data: data2 };
              if (vErrors === null) {
                vErrors = [err6];
              } else {
                vErrors.push(err6);
              }
              errors++;
            }
          }
          if (data.types !== void 0) {
            let data3 = data.types;
            if (Array.isArray(data3)) {
              if (data3.length < 1) {
                const err7 = { instancePath: instancePath + "/types", schemaPath: "#/properties/types/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items", schema: 1, parentSchema: schema27.properties.types, data: data3 };
                if (vErrors === null) {
                  vErrors = [err7];
                } else {
                  vErrors.push(err7);
                }
                errors++;
              }
              const len0 = data3.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data4 = data3[i0];
                if (!(data4 === "HARASSMENT" || data4 === "THREATENING_VIOLENCE" || data4 === "HATEFUL" || data4 === "OBSCENE" || data4 === "SEXUALIZATION_OF_MINORS" || data4 === "SHARING_PRIVATE_PERSONAL_INFORMATION" || data4 === "PORNOGRAPHY" || data4 === "ILLEGAL_ACTIVITY" || data4 === "IMPERSONATION" || data4 === "COPYRIGHT_VIOLATION" || data4 === "TRADEMARK_VIOLATION" || data4 === "SPAM" || data4 === "OTHER")) {
                  const err8 = { instancePath: instancePath + "/types/" + i0, schemaPath: "#/properties/types/items/enum", keyword: "enum", params: { allowedValues: schema27.properties.types.items.enum }, message: "must be equal to one of the allowed values", schema: schema27.properties.types.items.enum, parentSchema: schema27.properties.types.items, data: data4 };
                  if (vErrors === null) {
                    vErrors = [err8];
                  } else {
                    vErrors.push(err8);
                  }
                  errors++;
                }
              }
              let i1 = data3.length;
              let j0;
              if (i1 > 1) {
                outer0:
                  for (; i1--; ) {
                    for (j0 = i1; j0--; ) {
                      if (func0(data3[i1], data3[j0])) {
                        const err9 = { instancePath: instancePath + "/types", schemaPath: "#/properties/types/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)", schema: true, parentSchema: schema27.properties.types, data: data3 };
                        if (vErrors === null) {
                          vErrors = [err9];
                        } else {
                          vErrors.push(err9);
                        }
                        errors++;
                        break outer0;
                      }
                    }
                  }
              }
            } else {
              const err10 = { instancePath: instancePath + "/types", schemaPath: "#/properties/types/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema27.properties.types.type, parentSchema: schema27.properties.types, data: data3 };
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors++;
            }
          }
          if (data.description !== void 0) {
            let data5 = data.description;
            if (typeof data5 === "string") {
              if (func7(data5) > 4096) {
                const err11 = { instancePath: instancePath + "/description", schemaPath: "#/properties/description/maxLength", keyword: "maxLength", params: { limit: 4096 }, message: "must NOT have more than 4096 characters", schema: 4096, parentSchema: schema27.properties.description, data: data5 };
                if (vErrors === null) {
                  vErrors = [err11];
                } else {
                  vErrors.push(err11);
                }
                errors++;
              }
            } else {
              const err12 = { instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema27.properties.description.type, parentSchema: schema27.properties.description, data: data5 };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors++;
            }
          }
        } else {
          const err13 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema27.type, parentSchema: schema27, data };
          if (vErrors === null) {
            vErrors = [err13];
          } else {
            vErrors.push(err13);
          }
          errors++;
        }
        validate10.errors = vErrors;
        return errors === 0;
      }
      exports["https://howdju.com/schemas/password-reset-request.schema.json"] = validate12;
      var schema30 = { "$id": "https://howdju.com/schemas/password-reset-request.schema.json", "$schema": "http://json-schema.org/draft-07/schema#", "title": "PasswordResetRequest", "description": "A request to reset a password", "type": "object", "required": ["email"], "properties": { "email": { "$ref": "definitions.json#/definitions/userEmail" } } };
      var schema31 = { "type": "string", "format": "email", "description": "The user's preferred email for receiving correspondence about the system", "maxLength": 128 };
      var formats4 = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;
      function validate12(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
        ;
        let vErrors = null;
        let errors = 0;
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.email === void 0) {
            const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "email" }, message: "must have required property 'email'", schema: schema30.required, parentSchema: schema30, data };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
          if (data.email !== void 0) {
            let data0 = data.email;
            if (typeof data0 === "string") {
              if (func7(data0) > 128) {
                const err1 = { instancePath: instancePath + "/email", schemaPath: "definitions.json#/definitions/userEmail/maxLength", keyword: "maxLength", params: { limit: 128 }, message: "must NOT have more than 128 characters", schema: 128, parentSchema: schema31, data: data0 };
                if (vErrors === null) {
                  vErrors = [err1];
                } else {
                  vErrors.push(err1);
                }
                errors++;
              }
              if (!formats4.test(data0)) {
                const err2 = { instancePath: instancePath + "/email", schemaPath: "definitions.json#/definitions/userEmail/format", keyword: "format", params: { format: "email" }, message: 'must match format "email"', schema: "email", parentSchema: schema31, data: data0 };
                if (vErrors === null) {
                  vErrors = [err2];
                } else {
                  vErrors.push(err2);
                }
                errors++;
              }
            } else {
              const err3 = { instancePath: instancePath + "/email", schemaPath: "definitions.json#/definitions/userEmail/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema31.type, parentSchema: schema31, data: data0 };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors++;
            }
          }
        } else {
          const err4 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema30.type, parentSchema: schema30, data };
          if (vErrors === null) {
            vErrors = [err4];
          } else {
            vErrors.push(err4);
          }
          errors++;
        }
        validate12.errors = vErrors;
        return errors === 0;
      }
      exports["https://howdju.com/schemas/password-reset-confirmation.schema.json"] = validate13;
      var schema32 = { "$id": "https://howdju.com/schemas/password-reset-confirmation.schema.json", "$schema": "http://json-schema.org/draft-07/schema#", "title": "PasswordResetConfirmation", "description": "A confirmation to reset a password", "type": "object", "required": ["newPassword"], "properties": { "newPassword": { "$ref": "definitions.json#/definitions/password" } } };
      var schema33 = { "type": "string", "description": "The user's selected password", "minLength": 6, "maxLength": 64 };
      function validate13(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
        ;
        let vErrors = null;
        let errors = 0;
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.newPassword === void 0) {
            const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "newPassword" }, message: "must have required property 'newPassword'", schema: schema32.required, parentSchema: schema32, data };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
          if (data.newPassword !== void 0) {
            let data0 = data.newPassword;
            if (typeof data0 === "string") {
              if (func7(data0) > 64) {
                const err1 = { instancePath: instancePath + "/newPassword", schemaPath: "definitions.json#/definitions/password/maxLength", keyword: "maxLength", params: { limit: 64 }, message: "must NOT have more than 64 characters", schema: 64, parentSchema: schema33, data: data0 };
                if (vErrors === null) {
                  vErrors = [err1];
                } else {
                  vErrors.push(err1);
                }
                errors++;
              }
              if (func7(data0) < 6) {
                const err2 = { instancePath: instancePath + "/newPassword", schemaPath: "definitions.json#/definitions/password/minLength", keyword: "minLength", params: { limit: 6 }, message: "must NOT have fewer than 6 characters", schema: 6, parentSchema: schema33, data: data0 };
                if (vErrors === null) {
                  vErrors = [err2];
                } else {
                  vErrors.push(err2);
                }
                errors++;
              }
            } else {
              const err3 = { instancePath: instancePath + "/newPassword", schemaPath: "definitions.json#/definitions/password/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema33.type, parentSchema: schema33, data: data0 };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors++;
            }
          }
        } else {
          const err4 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema32.type, parentSchema: schema32, data };
          if (vErrors === null) {
            vErrors = [err4];
          } else {
            vErrors.push(err4);
          }
          errors++;
        }
        validate13.errors = vErrors;
        return errors === 0;
      }
      exports["https://howdju.com/schemas/persorg.schema.json"] = validate14;
      var schema34 = { "$id": "https://howdju.com/schemas/persorg.schema.json", "$schema": "http://json-schema.org/draft-07/schema#", "title": "Persorg", "description": "A person or organization. Something that can be a speaker.", "type": "object", "required": ["name", "isOrganization", "knownFor"], "properties": { "name": { "type": "string", "maxLength": 2048, "description": "The name of the persorg." }, "isOrganization": { "type": "boolean", "description": "Whether the persorg is an organization (or a person.)" }, "knownFor": { "type": "string", "maxLength": 4096, "description": "A short desription of what the persorg is known for, to help distinguish the persorg from other persorgs, to provide context about the persorg's significance, or to provide context about the significance or motivationi for the persorg's speech." }, "websiteUrl": { "type": "string", "format": "uri", "maxLength": 8096, "description": "The URL of the website the persorg represents as its primary website. If there is none, then then the generally accepted primary website representing the persorg." }, "twitterUrl": { "type": "string", "format": "uri", "maxLength": 8096, "description": "The URL of the Twitter profile that the persorg represents as belonging to it. If the persorg does not publicly represent that it has a Twitter account, then no unofficial Twitter account should be substituted here." }, "wikipediaUrl": { "type": "string", "format": "uri", "maxLength": 8096, "description": "The URL of the Wikipedia page representing the persorg. The persorg need not endorse this page." } } };
      function validate14(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
        ;
        let vErrors = null;
        let errors = 0;
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.name === void 0) {
            const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'", schema: schema34.required, parentSchema: schema34, data };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
          if (data.isOrganization === void 0) {
            const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "isOrganization" }, message: "must have required property 'isOrganization'", schema: schema34.required, parentSchema: schema34, data };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
          if (data.knownFor === void 0) {
            const err2 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "knownFor" }, message: "must have required property 'knownFor'", schema: schema34.required, parentSchema: schema34, data };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
          if (data.name !== void 0) {
            let data0 = data.name;
            if (typeof data0 === "string") {
              if (func7(data0) > 2048) {
                const err3 = { instancePath: instancePath + "/name", schemaPath: "#/properties/name/maxLength", keyword: "maxLength", params: { limit: 2048 }, message: "must NOT have more than 2048 characters", schema: 2048, parentSchema: schema34.properties.name, data: data0 };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors++;
              }
            } else {
              const err4 = { instancePath: instancePath + "/name", schemaPath: "#/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema34.properties.name.type, parentSchema: schema34.properties.name, data: data0 };
              if (vErrors === null) {
                vErrors = [err4];
              } else {
                vErrors.push(err4);
              }
              errors++;
            }
          }
          if (data.isOrganization !== void 0) {
            let data1 = data.isOrganization;
            if (typeof data1 !== "boolean") {
              const err5 = { instancePath: instancePath + "/isOrganization", schemaPath: "#/properties/isOrganization/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean", schema: schema34.properties.isOrganization.type, parentSchema: schema34.properties.isOrganization, data: data1 };
              if (vErrors === null) {
                vErrors = [err5];
              } else {
                vErrors.push(err5);
              }
              errors++;
            }
          }
          if (data.knownFor !== void 0) {
            let data2 = data.knownFor;
            if (typeof data2 === "string") {
              if (func7(data2) > 4096) {
                const err6 = { instancePath: instancePath + "/knownFor", schemaPath: "#/properties/knownFor/maxLength", keyword: "maxLength", params: { limit: 4096 }, message: "must NOT have more than 4096 characters", schema: 4096, parentSchema: schema34.properties.knownFor, data: data2 };
                if (vErrors === null) {
                  vErrors = [err6];
                } else {
                  vErrors.push(err6);
                }
                errors++;
              }
            } else {
              const err7 = { instancePath: instancePath + "/knownFor", schemaPath: "#/properties/knownFor/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema34.properties.knownFor.type, parentSchema: schema34.properties.knownFor, data: data2 };
              if (vErrors === null) {
                vErrors = [err7];
              } else {
                vErrors.push(err7);
              }
              errors++;
            }
          }
          if (data.websiteUrl !== void 0) {
            let data3 = data.websiteUrl;
            if (typeof data3 === "string") {
              if (func7(data3) > 8096) {
                const err8 = { instancePath: instancePath + "/websiteUrl", schemaPath: "#/properties/websiteUrl/maxLength", keyword: "maxLength", params: { limit: 8096 }, message: "must NOT have more than 8096 characters", schema: 8096, parentSchema: schema34.properties.websiteUrl, data: data3 };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
              if (!formats2(data3)) {
                const err9 = { instancePath: instancePath + "/websiteUrl", schemaPath: "#/properties/websiteUrl/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"', schema: "uri", parentSchema: schema34.properties.websiteUrl, data: data3 };
                if (vErrors === null) {
                  vErrors = [err9];
                } else {
                  vErrors.push(err9);
                }
                errors++;
              }
            } else {
              const err10 = { instancePath: instancePath + "/websiteUrl", schemaPath: "#/properties/websiteUrl/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema34.properties.websiteUrl.type, parentSchema: schema34.properties.websiteUrl, data: data3 };
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors++;
            }
          }
          if (data.twitterUrl !== void 0) {
            let data4 = data.twitterUrl;
            if (typeof data4 === "string") {
              if (func7(data4) > 8096) {
                const err11 = { instancePath: instancePath + "/twitterUrl", schemaPath: "#/properties/twitterUrl/maxLength", keyword: "maxLength", params: { limit: 8096 }, message: "must NOT have more than 8096 characters", schema: 8096, parentSchema: schema34.properties.twitterUrl, data: data4 };
                if (vErrors === null) {
                  vErrors = [err11];
                } else {
                  vErrors.push(err11);
                }
                errors++;
              }
              if (!formats2(data4)) {
                const err12 = { instancePath: instancePath + "/twitterUrl", schemaPath: "#/properties/twitterUrl/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"', schema: "uri", parentSchema: schema34.properties.twitterUrl, data: data4 };
                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }
                errors++;
              }
            } else {
              const err13 = { instancePath: instancePath + "/twitterUrl", schemaPath: "#/properties/twitterUrl/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema34.properties.twitterUrl.type, parentSchema: schema34.properties.twitterUrl, data: data4 };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors++;
            }
          }
          if (data.wikipediaUrl !== void 0) {
            let data5 = data.wikipediaUrl;
            if (typeof data5 === "string") {
              if (func7(data5) > 8096) {
                const err14 = { instancePath: instancePath + "/wikipediaUrl", schemaPath: "#/properties/wikipediaUrl/maxLength", keyword: "maxLength", params: { limit: 8096 }, message: "must NOT have more than 8096 characters", schema: 8096, parentSchema: schema34.properties.wikipediaUrl, data: data5 };
                if (vErrors === null) {
                  vErrors = [err14];
                } else {
                  vErrors.push(err14);
                }
                errors++;
              }
              if (!formats2(data5)) {
                const err15 = { instancePath: instancePath + "/wikipediaUrl", schemaPath: "#/properties/wikipediaUrl/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"', schema: "uri", parentSchema: schema34.properties.wikipediaUrl, data: data5 };
                if (vErrors === null) {
                  vErrors = [err15];
                } else {
                  vErrors.push(err15);
                }
                errors++;
              }
            } else {
              const err16 = { instancePath: instancePath + "/wikipediaUrl", schemaPath: "#/properties/wikipediaUrl/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema34.properties.wikipediaUrl.type, parentSchema: schema34.properties.wikipediaUrl, data: data5 };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors++;
            }
          }
        } else {
          const err17 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema34.type, parentSchema: schema34, data };
          if (vErrors === null) {
            vErrors = [err17];
          } else {
            vErrors.push(err17);
          }
          errors++;
        }
        validate14.errors = vErrors;
        return errors === 0;
      }
      exports["https://howdju.com/schemas/user.schema.json"] = validate15;
      var schema35 = { "$id": "https://howdju.com/schemas/user.schema.json", "$schema": "http://json-schema.org/draft-07/schema#", "title": "User", "description": "A user of the system", "type": "object", "required": ["email", "username", "longName", "acceptedTerms", "affirmedMajorityConsent", "affirmed13YearsOrOlder", "affirmedNotGdpr"], "properties": { "username": { "$ref": "definitions.json#/definitions/username" }, "email": { "$ref": "definitions.json#/definitions/userEmail" }, "shortName": { "$ref": "definitions.json#/definitions/shortName" }, "longName": { "$ref": "definitions.json#/definitions/longName" }, "acceptedTerms": { "description": "The time when the user accepted the terms.", "type": "string", "format": "date-time" }, "affirmedMajorityConsent": { "description": "The time when the user affirmed that they had majority consent to accept the terms.", "type": "string", "format": "date-time" }, "affirmed13YearsOrOlder": { "description": "The time when the user affirmed that they are older than 13 years.", "type": "string", "format": "date-time" }, "affirmedNotGdpr": { "description": "The time when the user affirmed that GDPR does not apply to them.", "type": "string", "format": "date-time" } } };
      var schema36 = { "type": "string", "pattern": "^[A-Za-z0-9_]+$", "description": "The user-selected identifier by which the user is publicly known in the system.  Letters, numbers, and underscore.", "minLength": 2, "maxLength": 64 };
      var schema38 = { "type": "string", "description": "The user's preferred first name or common name", "examples": ["Carl", "Rich", "Anu"], "maxLength": 32 };
      var schema39 = { "type": "string", "description": "The user's actual full legal name", "examples": ["Carl Gieringer", "Anuradha Sathya"], "minLength": 1, "maxLength": 64 };
      var pattern0 = new RegExp("^[A-Za-z0-9_]+$", "u");
      var formats14 = require_formats().fullFormats["date-time"];
      function validate15(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
        ;
        let vErrors = null;
        let errors = 0;
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.email === void 0) {
            const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "email" }, message: "must have required property 'email'", schema: schema35.required, parentSchema: schema35, data };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
          if (data.username === void 0) {
            const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "username" }, message: "must have required property 'username'", schema: schema35.required, parentSchema: schema35, data };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
          if (data.longName === void 0) {
            const err2 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "longName" }, message: "must have required property 'longName'", schema: schema35.required, parentSchema: schema35, data };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
          if (data.acceptedTerms === void 0) {
            const err3 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "acceptedTerms" }, message: "must have required property 'acceptedTerms'", schema: schema35.required, parentSchema: schema35, data };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
          if (data.affirmedMajorityConsent === void 0) {
            const err4 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "affirmedMajorityConsent" }, message: "must have required property 'affirmedMajorityConsent'", schema: schema35.required, parentSchema: schema35, data };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors++;
          }
          if (data.affirmed13YearsOrOlder === void 0) {
            const err5 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "affirmed13YearsOrOlder" }, message: "must have required property 'affirmed13YearsOrOlder'", schema: schema35.required, parentSchema: schema35, data };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
          if (data.affirmedNotGdpr === void 0) {
            const err6 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "affirmedNotGdpr" }, message: "must have required property 'affirmedNotGdpr'", schema: schema35.required, parentSchema: schema35, data };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors++;
          }
          if (data.username !== void 0) {
            let data0 = data.username;
            if (typeof data0 === "string") {
              if (func7(data0) > 64) {
                const err7 = { instancePath: instancePath + "/username", schemaPath: "definitions.json#/definitions/username/maxLength", keyword: "maxLength", params: { limit: 64 }, message: "must NOT have more than 64 characters", schema: 64, parentSchema: schema36, data: data0 };
                if (vErrors === null) {
                  vErrors = [err7];
                } else {
                  vErrors.push(err7);
                }
                errors++;
              }
              if (func7(data0) < 2) {
                const err8 = { instancePath: instancePath + "/username", schemaPath: "definitions.json#/definitions/username/minLength", keyword: "minLength", params: { limit: 2 }, message: "must NOT have fewer than 2 characters", schema: 2, parentSchema: schema36, data: data0 };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
              if (!pattern0.test(data0)) {
                const err9 = { instancePath: instancePath + "/username", schemaPath: "definitions.json#/definitions/username/pattern", keyword: "pattern", params: { pattern: "^[A-Za-z0-9_]+$" }, message: 'must match pattern "^[A-Za-z0-9_]+$"', schema: "^[A-Za-z0-9_]+$", parentSchema: schema36, data: data0 };
                if (vErrors === null) {
                  vErrors = [err9];
                } else {
                  vErrors.push(err9);
                }
                errors++;
              }
            } else {
              const err10 = { instancePath: instancePath + "/username", schemaPath: "definitions.json#/definitions/username/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema36.type, parentSchema: schema36, data: data0 };
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors++;
            }
          }
          if (data.email !== void 0) {
            let data1 = data.email;
            if (typeof data1 === "string") {
              if (func7(data1) > 128) {
                const err11 = { instancePath: instancePath + "/email", schemaPath: "definitions.json#/definitions/userEmail/maxLength", keyword: "maxLength", params: { limit: 128 }, message: "must NOT have more than 128 characters", schema: 128, parentSchema: schema31, data: data1 };
                if (vErrors === null) {
                  vErrors = [err11];
                } else {
                  vErrors.push(err11);
                }
                errors++;
              }
              if (!formats4.test(data1)) {
                const err12 = { instancePath: instancePath + "/email", schemaPath: "definitions.json#/definitions/userEmail/format", keyword: "format", params: { format: "email" }, message: 'must match format "email"', schema: "email", parentSchema: schema31, data: data1 };
                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }
                errors++;
              }
            } else {
              const err13 = { instancePath: instancePath + "/email", schemaPath: "definitions.json#/definitions/userEmail/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema31.type, parentSchema: schema31, data: data1 };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors++;
            }
          }
          if (data.shortName !== void 0) {
            let data2 = data.shortName;
            if (typeof data2 === "string") {
              if (func7(data2) > 32) {
                const err14 = { instancePath: instancePath + "/shortName", schemaPath: "definitions.json#/definitions/shortName/maxLength", keyword: "maxLength", params: { limit: 32 }, message: "must NOT have more than 32 characters", schema: 32, parentSchema: schema38, data: data2 };
                if (vErrors === null) {
                  vErrors = [err14];
                } else {
                  vErrors.push(err14);
                }
                errors++;
              }
            } else {
              const err15 = { instancePath: instancePath + "/shortName", schemaPath: "definitions.json#/definitions/shortName/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema38.type, parentSchema: schema38, data: data2 };
              if (vErrors === null) {
                vErrors = [err15];
              } else {
                vErrors.push(err15);
              }
              errors++;
            }
          }
          if (data.longName !== void 0) {
            let data3 = data.longName;
            if (typeof data3 === "string") {
              if (func7(data3) > 64) {
                const err16 = { instancePath: instancePath + "/longName", schemaPath: "definitions.json#/definitions/longName/maxLength", keyword: "maxLength", params: { limit: 64 }, message: "must NOT have more than 64 characters", schema: 64, parentSchema: schema39, data: data3 };
                if (vErrors === null) {
                  vErrors = [err16];
                } else {
                  vErrors.push(err16);
                }
                errors++;
              }
              if (func7(data3) < 1) {
                const err17 = { instancePath: instancePath + "/longName", schemaPath: "definitions.json#/definitions/longName/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters", schema: 1, parentSchema: schema39, data: data3 };
                if (vErrors === null) {
                  vErrors = [err17];
                } else {
                  vErrors.push(err17);
                }
                errors++;
              }
            } else {
              const err18 = { instancePath: instancePath + "/longName", schemaPath: "definitions.json#/definitions/longName/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema39.type, parentSchema: schema39, data: data3 };
              if (vErrors === null) {
                vErrors = [err18];
              } else {
                vErrors.push(err18);
              }
              errors++;
            }
          }
          if (data.acceptedTerms !== void 0) {
            let data4 = data.acceptedTerms;
            if (typeof data4 === "string") {
              if (!formats14.validate(data4)) {
                const err19 = { instancePath: instancePath + "/acceptedTerms", schemaPath: "#/properties/acceptedTerms/format", keyword: "format", params: { format: "date-time" }, message: 'must match format "date-time"', schema: "date-time", parentSchema: schema35.properties.acceptedTerms, data: data4 };
                if (vErrors === null) {
                  vErrors = [err19];
                } else {
                  vErrors.push(err19);
                }
                errors++;
              }
            } else {
              const err20 = { instancePath: instancePath + "/acceptedTerms", schemaPath: "#/properties/acceptedTerms/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema35.properties.acceptedTerms.type, parentSchema: schema35.properties.acceptedTerms, data: data4 };
              if (vErrors === null) {
                vErrors = [err20];
              } else {
                vErrors.push(err20);
              }
              errors++;
            }
          }
          if (data.affirmedMajorityConsent !== void 0) {
            let data5 = data.affirmedMajorityConsent;
            if (typeof data5 === "string") {
              if (!formats14.validate(data5)) {
                const err21 = { instancePath: instancePath + "/affirmedMajorityConsent", schemaPath: "#/properties/affirmedMajorityConsent/format", keyword: "format", params: { format: "date-time" }, message: 'must match format "date-time"', schema: "date-time", parentSchema: schema35.properties.affirmedMajorityConsent, data: data5 };
                if (vErrors === null) {
                  vErrors = [err21];
                } else {
                  vErrors.push(err21);
                }
                errors++;
              }
            } else {
              const err22 = { instancePath: instancePath + "/affirmedMajorityConsent", schemaPath: "#/properties/affirmedMajorityConsent/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema35.properties.affirmedMajorityConsent.type, parentSchema: schema35.properties.affirmedMajorityConsent, data: data5 };
              if (vErrors === null) {
                vErrors = [err22];
              } else {
                vErrors.push(err22);
              }
              errors++;
            }
          }
          if (data.affirmed13YearsOrOlder !== void 0) {
            let data6 = data.affirmed13YearsOrOlder;
            if (typeof data6 === "string") {
              if (!formats14.validate(data6)) {
                const err23 = { instancePath: instancePath + "/affirmed13YearsOrOlder", schemaPath: "#/properties/affirmed13YearsOrOlder/format", keyword: "format", params: { format: "date-time" }, message: 'must match format "date-time"', schema: "date-time", parentSchema: schema35.properties.affirmed13YearsOrOlder, data: data6 };
                if (vErrors === null) {
                  vErrors = [err23];
                } else {
                  vErrors.push(err23);
                }
                errors++;
              }
            } else {
              const err24 = { instancePath: instancePath + "/affirmed13YearsOrOlder", schemaPath: "#/properties/affirmed13YearsOrOlder/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema35.properties.affirmed13YearsOrOlder.type, parentSchema: schema35.properties.affirmed13YearsOrOlder, data: data6 };
              if (vErrors === null) {
                vErrors = [err24];
              } else {
                vErrors.push(err24);
              }
              errors++;
            }
          }
          if (data.affirmedNotGdpr !== void 0) {
            let data7 = data.affirmedNotGdpr;
            if (typeof data7 === "string") {
              if (!formats14.validate(data7)) {
                const err25 = { instancePath: instancePath + "/affirmedNotGdpr", schemaPath: "#/properties/affirmedNotGdpr/format", keyword: "format", params: { format: "date-time" }, message: 'must match format "date-time"', schema: "date-time", parentSchema: schema35.properties.affirmedNotGdpr, data: data7 };
                if (vErrors === null) {
                  vErrors = [err25];
                } else {
                  vErrors.push(err25);
                }
                errors++;
              }
            } else {
              const err26 = { instancePath: instancePath + "/affirmedNotGdpr", schemaPath: "#/properties/affirmedNotGdpr/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema35.properties.affirmedNotGdpr.type, parentSchema: schema35.properties.affirmedNotGdpr, data: data7 };
              if (vErrors === null) {
                vErrors = [err26];
              } else {
                vErrors.push(err26);
              }
              errors++;
            }
          }
        } else {
          const err27 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema35.type, parentSchema: schema35, data };
          if (vErrors === null) {
            vErrors = [err27];
          } else {
            vErrors.push(err27);
          }
          errors++;
        }
        validate15.errors = vErrors;
        return errors === 0;
      }
      exports["https://howdju.com/schemas/writ.schema.json"] = validate16;
      var schema40 = { "$id": "https://howdju.com/schemas/writ.schema.json", "$schema": "http://json-schema.org/draft-07/schema#", "title": "Writ", "description": "A textual media source. Ex a book or news article.", "type": "object", "required": ["textQuote", "writ"], "properties": { "title": { "type": "string", "maxLength": 512, "description": "The title of the Writ. Ex: the title of a book." } } };
      function validate16(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
        ;
        let vErrors = null;
        let errors = 0;
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.textQuote === void 0) {
            const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "textQuote" }, message: "must have required property 'textQuote'", schema: schema40.required, parentSchema: schema40, data };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
          if (data.writ === void 0) {
            const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "writ" }, message: "must have required property 'writ'", schema: schema40.required, parentSchema: schema40, data };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
          if (data.title !== void 0) {
            let data0 = data.title;
            if (typeof data0 === "string") {
              if (func7(data0) > 512) {
                const err2 = { instancePath: instancePath + "/title", schemaPath: "#/properties/title/maxLength", keyword: "maxLength", params: { limit: 512 }, message: "must NOT have more than 512 characters", schema: 512, parentSchema: schema40.properties.title, data: data0 };
                if (vErrors === null) {
                  vErrors = [err2];
                } else {
                  vErrors.push(err2);
                }
                errors++;
              }
            } else {
              const err3 = { instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema40.properties.title.type, parentSchema: schema40.properties.title, data: data0 };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors++;
            }
          }
        } else {
          const err4 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema40.type, parentSchema: schema40, data };
          if (vErrors === null) {
            vErrors = [err4];
          } else {
            vErrors.push(err4);
          }
          errors++;
        }
        validate16.errors = vErrors;
        return errors === 0;
      }
      exports["https://howdju.com/schemas/writ-quote.schema.json"] = validate17;
      var schema41 = { "$id": "https://howdju.com/schemas/writ-quote.schema.json", "$schema": "http://json-schema.org/draft-07/schema#", "title": "WritQuote", "description": "A quoted excerpt from textual media.", "type": "object", "required": ["textQuote", "writ"], "properties": { "textQuote": { "type": "string", "maxLength": 4096, "description": "The text quoted from the media." }, "writ": { "$ref": "https://howdju.com/schemas/writ.schema.json" }, "urls": { "description": "URLs where users can find the quote.", "type": "array", "items": { "type": "string", "format": "uri" } } } };
      function validate17(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
        ;
        let vErrors = null;
        let errors = 0;
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.textQuote === void 0) {
            const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "textQuote" }, message: "must have required property 'textQuote'", schema: schema41.required, parentSchema: schema41, data };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
          if (data.writ === void 0) {
            const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "writ" }, message: "must have required property 'writ'", schema: schema41.required, parentSchema: schema41, data };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
          if (data.textQuote !== void 0) {
            let data0 = data.textQuote;
            if (typeof data0 === "string") {
              if (func7(data0) > 4096) {
                const err2 = { instancePath: instancePath + "/textQuote", schemaPath: "#/properties/textQuote/maxLength", keyword: "maxLength", params: { limit: 4096 }, message: "must NOT have more than 4096 characters", schema: 4096, parentSchema: schema41.properties.textQuote, data: data0 };
                if (vErrors === null) {
                  vErrors = [err2];
                } else {
                  vErrors.push(err2);
                }
                errors++;
              }
            } else {
              const err3 = { instancePath: instancePath + "/textQuote", schemaPath: "#/properties/textQuote/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema41.properties.textQuote.type, parentSchema: schema41.properties.textQuote, data: data0 };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors++;
            }
          }
          if (data.writ !== void 0) {
            let data1 = data.writ;
            if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
              if (data1.textQuote === void 0) {
                const err4 = { instancePath: instancePath + "/writ", schemaPath: "https://howdju.com/schemas/writ.schema.json/required", keyword: "required", params: { missingProperty: "textQuote" }, message: "must have required property 'textQuote'", schema: schema40.required, parentSchema: schema40, data: data1 };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors++;
              }
              if (data1.writ === void 0) {
                const err5 = { instancePath: instancePath + "/writ", schemaPath: "https://howdju.com/schemas/writ.schema.json/required", keyword: "required", params: { missingProperty: "writ" }, message: "must have required property 'writ'", schema: schema40.required, parentSchema: schema40, data: data1 };
                if (vErrors === null) {
                  vErrors = [err5];
                } else {
                  vErrors.push(err5);
                }
                errors++;
              }
              if (data1.title !== void 0) {
                let data2 = data1.title;
                if (typeof data2 === "string") {
                  if (func7(data2) > 512) {
                    const err6 = { instancePath: instancePath + "/writ/title", schemaPath: "https://howdju.com/schemas/writ.schema.json/properties/title/maxLength", keyword: "maxLength", params: { limit: 512 }, message: "must NOT have more than 512 characters", schema: 512, parentSchema: schema40.properties.title, data: data2 };
                    if (vErrors === null) {
                      vErrors = [err6];
                    } else {
                      vErrors.push(err6);
                    }
                    errors++;
                  }
                } else {
                  const err7 = { instancePath: instancePath + "/writ/title", schemaPath: "https://howdju.com/schemas/writ.schema.json/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema40.properties.title.type, parentSchema: schema40.properties.title, data: data2 };
                  if (vErrors === null) {
                    vErrors = [err7];
                  } else {
                    vErrors.push(err7);
                  }
                  errors++;
                }
              }
            } else {
              const err8 = { instancePath: instancePath + "/writ", schemaPath: "https://howdju.com/schemas/writ.schema.json/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema40.type, parentSchema: schema40, data: data1 };
              if (vErrors === null) {
                vErrors = [err8];
              } else {
                vErrors.push(err8);
              }
              errors++;
            }
          }
          if (data.urls !== void 0) {
            let data3 = data.urls;
            if (Array.isArray(data3)) {
              const len0 = data3.length;
              for (let i0 = 0; i0 < len0; i0++) {
                let data4 = data3[i0];
                if (typeof data4 === "string") {
                  if (!formats2(data4)) {
                    const err9 = { instancePath: instancePath + "/urls/" + i0, schemaPath: "#/properties/urls/items/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"', schema: "uri", parentSchema: schema41.properties.urls.items, data: data4 };
                    if (vErrors === null) {
                      vErrors = [err9];
                    } else {
                      vErrors.push(err9);
                    }
                    errors++;
                  }
                } else {
                  const err10 = { instancePath: instancePath + "/urls/" + i0, schemaPath: "#/properties/urls/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema41.properties.urls.items.type, parentSchema: schema41.properties.urls.items, data: data4 };
                  if (vErrors === null) {
                    vErrors = [err10];
                  } else {
                    vErrors.push(err10);
                  }
                  errors++;
                }
              }
            } else {
              const err11 = { instancePath: instancePath + "/urls", schemaPath: "#/properties/urls/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema41.properties.urls.type, parentSchema: schema41.properties.urls, data: data3 };
              if (vErrors === null) {
                vErrors = [err11];
              } else {
                vErrors.push(err11);
              }
              errors++;
            }
          }
        } else {
          const err12 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema41.type, parentSchema: schema41, data };
          if (vErrors === null) {
            vErrors = [err12];
          } else {
            vErrors.push(err12);
          }
          errors++;
        }
        validate17.errors = vErrors;
        return errors === 0;
      }
      exports["https://howdju.com/schemas/definitions.json"] = validate11;
      function validate11(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
        ;
        validate11.errors = null;
        return true;
      }
    }
  });

  // ../howdju-common/lib/standaloneValidation.js
  var require_standaloneValidation = __commonJS({
    "../howdju-common/lib/standaloneValidation.js"(exports, module) {
      "use strict";
      var { makeStandaloneValidate: makeStandaloneValidate2 } = (init_schemaValidation(), __toCommonJS(schemaValidation_exports));
      module.exports.validate = makeStandaloneValidate2(require_standaloneAjv());
    }
  });

  // ../node_modules/lodash/cloneDeep.js
  var require_cloneDeep = __commonJS({
    "../node_modules/lodash/cloneDeep.js"(exports, module) {
      var baseClone = require_baseClone();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_SYMBOLS_FLAG = 4;
      function cloneDeep5(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      module.exports = cloneDeep5;
    }
  });

  // ../node_modules/text-fragments-polyfill/dist/fragment-generation-utils.js
  var e = ["ADDRESS", "ARTICLE", "ASIDE", "BLOCKQUOTE", "BR", "DETAILS", "DIALOG", "DD", "DIV", "DL", "DT", "FIELDSET", "FIGCAPTION", "FIGURE", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "HEADER", "HGROUP", "HR", "LI", "MAIN", "NAV", "OL", "P", "PRE", "SECTION", "TABLE", "UL", "TR", "TH", "TD", "COLGROUP", "COL", "CAPTION", "THEAD", "TBODY", "TFOOT"];
  var t = /[\t-\r -#%-\*,-\/:;\?@\[-\]_\{\}\x85\xA0\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/u;
  var s = { NO_SUFFIX_MATCH: 0, SUFFIX_MATCH: 1, MISPLACED_SUFFIX: 2 };
  var n = (e2, t3, n3, r3) => {
    const a3 = r3.createRange();
    a3.setStart(t3.endContainer, t3.endOffset), a3.setEnd(n3.endContainer, n3.endOffset), u(a3);
    const i3 = d(e2, a3);
    return null == i3 ? s.NO_SUFFIX_MATCH : 0 !== i3.compareBoundaryPoints(Range.START_TO_START, a3) ? s.MISPLACED_SUFFIX : s.SUFFIX_MATCH;
  };
  var r = (e2, t3, s3) => {
    try {
      e2.setStart(t3, s3 + 1);
    } catch (s4) {
      e2.setStartAfter(t3);
    }
  };
  var u = (e2) => {
    const t3 = a(e2);
    let s3 = t3.nextNode();
    for (; !e2.collapsed && null != s3; ) {
      if (s3 !== e2.startContainer && e2.setStart(s3, 0), s3.textContent.length > e2.startOffset) {
        if (!s3.textContent[e2.startOffset].match(/\s/))
          return;
      }
      try {
        e2.setStart(s3, e2.startOffset + 1);
      } catch (n3) {
        s3 = t3.nextNode(), null == s3 ? e2.collapse() : e2.setStart(s3, 0);
      }
    }
  };
  var a = (e2) => document.createTreeWalker(e2.commonAncestorContainer, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, (t3) => o(t3, e2));
  var i = (e2) => {
    let t3 = e2;
    for (; null != t3 && !(t3 instanceof HTMLElement); )
      t3 = t3.parentNode;
    if (null != t3) {
      const e3 = window.getComputedStyle(t3);
      if ("hidden" === e3.visibility || "none" === e3.display || 0 === e3.height || 0 === e3.width || 0 === e3.opacity)
        return false;
    }
    return true;
  };
  var f = (e2, t3) => (null == t3 || t3.intersectsNode(e2)) && i(e2) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
  var o = (e2, t3) => (null == t3 || t3.intersectsNode(e2)) && i(e2) ? e2.nodeType === Node.TEXT_NODE ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;
  var c = (t3, s3) => {
    const n3 = [];
    let r3 = [];
    const u3 = Array.from(function* (e2, t4) {
      const s4 = document.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, { acceptNode: t4 }), n4 = /* @__PURE__ */ new Set();
      for (; null !== E(s4, n4); )
        yield s4.currentNode;
    }(t3, (e2) => f(e2, s3)));
    for (const t4 of u3)
      t4.nodeType === Node.TEXT_NODE ? r3.push(t4) : t4 instanceof HTMLElement && e.includes(t4.tagName) && r3.length > 0 && (n3.push(r3), r3 = []);
    return r3.length > 0 && n3.push(r3), n3;
  };
  var d = (e2, t3) => {
    const s3 = c(t3.commonAncestorContainer, t3), n3 = F();
    for (const r3 of s3) {
      const s4 = h(e2, t3, r3, n3);
      if (void 0 !== s4)
        return s4;
    }
  };
  var h = (e2, t3, s3, n3) => {
    if (!e2 || !t3 || !(s3 || []).length)
      return;
    const r3 = S(((e3, t4, s4) => {
      let n4 = "";
      return n4 = 1 === e3.length ? e3[0].textContent.substring(t4, s4) : e3[0].textContent.substring(t4) + e3.slice(1, -1).reduce((e4, t5) => e4 + t5.textContent, "") + e3.slice(-1)[0].textContent.substring(0, s4), n4.replace(/[\t\n\r ]+/g, " ");
    })(s3, 0, void 0)), u3 = S(e2);
    let a3, i3, f3 = s3[0] === t3.startNode ? t3.startOffset : 0;
    for (; f3 < r3.length; ) {
      const e3 = r3.indexOf(u3, f3);
      if (-1 === e3)
        return;
      if (D(r3, e3, u3.length, n3) && (a3 = l(e3, s3, false), i3 = l(e3 + u3.length, s3, true)), null != a3 && null != i3) {
        const e4 = new Range();
        if (e4.setStart(a3.node, a3.offset), e4.setEnd(i3.node, i3.offset), t3.compareBoundaryPoints(Range.START_TO_START, e4) <= 0 && t3.compareBoundaryPoints(Range.END_TO_END, e4) >= 0)
          return e4;
      }
      f3 = e3 + 1;
    }
  };
  var l = (e2, t3, s3) => {
    let n3, r3 = 0;
    for (let u3 = 0; u3 < t3.length; u3++) {
      const a3 = t3[u3];
      n3 || (n3 = S(a3.data));
      let i3 = r3 + n3.length;
      if (s3 && (i3 += 1), i3 > e2) {
        const t4 = e2 - r3;
        let u4 = Math.min(e2 - r3, a3.data.length);
        const i4 = s3 ? n3.substring(0, t4) : n3.substring(t4);
        let f3 = S(s3 ? a3.data.substring(0, u4) : a3.data.substring(u4));
        const o3 = (s3 ? -1 : 1) * (i4.length > f3.length ? -1 : 1);
        for (; u4 >= 0 && u4 <= a3.data.length; ) {
          if (f3.length === i4.length)
            return { node: a3, offset: u4 };
          u4 += o3, f3 = S(s3 ? a3.data.substring(0, u4) : a3.data.substring(u4));
        }
      }
      if (r3 += n3.length, u3 + 1 < t3.length) {
        const e3 = S(t3[u3 + 1].data);
        " " === n3.slice(-1) && " " === e3.slice(0, 1) && (r3 -= 1), n3 = e3;
      }
    }
  };
  var D = (e2, s3, n3, r3) => {
    if (s3 < 0 || s3 >= e2.length || n3 <= 0 || s3 + n3 > e2.length)
      return false;
    if (r3) {
      const t3 = r3.segment(e2), u3 = t3.containing(s3);
      if (!u3)
        return false;
      if (u3.isWordLike && u3.index != s3)
        return false;
      const a3 = s3 + n3, i3 = t3.containing(a3);
      if (i3 && i3.isWordLike && i3.index != a3)
        return false;
    } else {
      if (e2[s3].match(t) && (++s3, !--n3))
        return false;
      if (e2[s3 + n3 - 1].match(t) && !--n3)
        return false;
      if (0 !== s3 && !e2[s3 - 1].match(t))
        return false;
      if (s3 + n3 !== e2.length && !e2[s3 + n3].match(t))
        return false;
    }
    return true;
  };
  var S = (e2) => (e2 || "").normalize("NFKD").replace(/\s+/g, " ").replace(/[\u0300-\u036f]/g, "").toLowerCase();
  var F = () => {
    if (Intl.Segmenter) {
      let e2 = document.documentElement.lang;
      return e2 || (e2 = navigator.languages), new Intl.Segmenter(e2, { granularity: "word" });
    }
  };
  var E = (e2, t3) => {
    if (!t3.has(e2.currentNode)) {
      const t4 = e2.firstChild();
      if (null !== t4)
        return t4;
    }
    const s3 = e2.nextSibling();
    if (null !== s3)
      return s3;
    const n3 = e2.parentNode();
    return null !== n3 && t3.add(n3), n3;
  };
  var g = { BLOCK_ELEMENTS: e, BOUNDARY_CHARS: t, NON_BOUNDARY_CHARS: /[^\t-\r -#%-\*,-\/:;\?@\[-\]_\{\}\x85\xA0\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/u, acceptNodeIfVisibleInRange: f, normalizeString: S, makeNewSegmenter: F, forwardTraverse: E, backwardTraverse: (e2, t3) => {
    if (!t3.has(e2.currentNode)) {
      const t4 = e2.lastChild();
      if (null !== t4)
        return t4;
    }
    const s3 = e2.previousSibling();
    if (null !== s3)
      return s3;
    const n3 = e2.parentNode();
    return null !== n3 && t3.add(n3), n3;
  }, makeTextNodeWalker: a, isNodeVisible: i };
  "undefined" != typeof goog && goog.declareModuleId("googleChromeLabs.textFragmentPolyfill.textFragmentUtils");
  var A;
  var C = 500;
  var O = (e2) => {
    C = e2;
  };
  var N = { SUCCESS: 0, INVALID_SELECTION: 1, AMBIGUOUS: 2, TIMEOUT: 3, EXECUTION_FAILED: 4 };
  var x = (e2, t3 = Date.now()) => {
    try {
      return p(e2, t3);
    } catch (e3) {
      return e3.isTimeout ? { status: N.TIMEOUT } : { status: N.EXECUTION_FAILED };
    }
  };
  var p = (e2, t3) => {
    let s3;
    B(t3);
    try {
      s3 = e2.getRangeAt(0);
    } catch (e3) {
      return { status: N.INVALID_SELECTION };
    }
    Y(s3), z(s3);
    const n3 = s3.cloneRange();
    if (V(s3), s3.collapsed)
      return { status: N.INVALID_SELECTION };
    let r3;
    if (L(s3)) {
      const e3 = g.normalizeString(s3.toString()), t4 = { textStart: e3 };
      if (e3.length >= 20 && b(t4))
        return { status: N.SUCCESS, fragment: t4 };
      r3 = new w().setExactTextMatch(e3);
    } else {
      const e3 = _(s3), t4 = R(s3);
      r3 = e3 && t4 ? new w().setStartAndEndSearchSpace(e3, t4) : new w().setSharedSearchSpace(s3.toString().trim());
    }
    const u3 = document.createRange();
    u3.selectNodeContents(document.body);
    const a3 = u3.cloneRange();
    u3.setEnd(n3.startContainer, n3.startOffset), a3.setStart(n3.endContainer, n3.endOffset);
    const i3 = R(u3), f3 = _(a3);
    (i3 || f3) && r3.setPrefixAndSuffixSearchSpace(i3, f3), r3.useSegmenter(g.makeNewSegmenter());
    let o3 = false;
    do {
      m(), o3 = r3.embiggen();
      const e3 = r3.tryToMakeUniqueFragment();
      if (null != e3)
        return { status: N.SUCCESS, fragment: e3 };
    } while (o3);
    return { status: N.AMBIGUOUS };
  };
  var m = () => {
    if (null === C)
      return;
    const e2 = Date.now() - A;
    if (e2 > C) {
      const t3 = new Error(`Fragment generation timed out after ${e2} ms.`);
      throw t3.isTimeout = true, t3;
    }
  };
  var B = (e2) => {
    A = e2;
  };
  var _ = (e2) => {
    let t3 = M(e2);
    const s3 = W(t3, e2.endContainer);
    if (!s3)
      return;
    const n3 = /* @__PURE__ */ new Set();
    e2.startContainer.nodeType === Node.ELEMENT_NODE && e2.startOffset === e2.startContainer.childNodes.length && n3.add(e2.startContainer);
    const r3 = t3, u3 = new k(e2, true), a3 = e2.cloneRange();
    for (; !a3.collapsed && null != t3; ) {
      if (m(), t3.contains(r3) ? a3.setStartAfter(t3) : a3.setStartBefore(t3), u3.appendNode(t3), null !== u3.textInBlock)
        return u3.textInBlock;
      t3 = g.forwardTraverse(s3, n3);
    }
  };
  var R = (e2) => {
    let t3 = P(e2);
    const s3 = W(t3, e2.startContainer);
    if (!s3)
      return;
    const n3 = /* @__PURE__ */ new Set();
    e2.endContainer.nodeType === Node.ELEMENT_NODE && 0 === e2.endOffset && n3.add(e2.endContainer);
    const r3 = t3, u3 = new k(e2, false), a3 = e2.cloneRange();
    for (; !a3.collapsed && null != t3; ) {
      if (m(), t3.contains(r3) ? a3.setEnd(t3, 0) : a3.setEndAfter(t3), u3.appendNode(t3), null !== u3.textInBlock)
        return u3.textInBlock;
      t3 = g.backwardTraverse(s3, n3);
    }
  };
  var w = class {
    constructor() {
      this.Mode = { ALL_PARTS: 1, SHARED_START_AND_END: 2, CONTEXT_ONLY: 3 }, this.startOffset = null, this.endOffset = null, this.prefixOffset = null, this.suffixOffset = null, this.prefixSearchSpace = "", this.backwardsPrefixSearchSpace = "", this.suffixSearchSpace = "", this.numIterations = 0;
    }
    tryToMakeUniqueFragment() {
      let e2;
      if (e2 = this.mode === this.Mode.CONTEXT_ONLY ? { textStart: this.exactTextMatch } : { textStart: this.getStartSearchSpace().substring(0, this.startOffset).trim(), textEnd: this.getEndSearchSpace().substring(this.endOffset).trim() }, null != this.prefixOffset) {
        const t3 = this.getPrefixSearchSpace().substring(this.prefixOffset).trim();
        t3 && (e2.prefix = t3);
      }
      if (null != this.suffixOffset) {
        const t3 = this.getSuffixSearchSpace().substring(0, this.suffixOffset).trim();
        t3 && (e2.suffix = t3);
      }
      return b(e2) ? e2 : void 0;
    }
    embiggen() {
      let e2 = true;
      if (this.mode === this.Mode.SHARED_START_AND_END ? this.startOffset >= this.endOffset && (e2 = false) : this.mode === this.Mode.ALL_PARTS ? this.startOffset === this.getStartSearchSpace().length && this.backwardsEndOffset() === this.getEndSearchSpace().length && (e2 = false) : this.mode === this.Mode.CONTEXT_ONLY && (e2 = false), e2) {
        const e3 = this.getNumberOfRangeWordsToAdd();
        if (this.startOffset < this.getStartSearchSpace().length) {
          let t4 = 0;
          if (null != this.getStartSegments())
            for (; t4 < e3 && this.startOffset < this.getStartSearchSpace().length; )
              this.startOffset = this.getNextOffsetForwards(this.getStartSegments(), this.startOffset, this.getStartSearchSpace()), t4++;
          else {
            let s3 = this.startOffset;
            do {
              m();
              const e4 = this.getStartSearchSpace().substring(this.startOffset + 1).search(g.BOUNDARY_CHARS);
              this.startOffset = -1 === e4 ? this.getStartSearchSpace().length : this.startOffset + 1 + e4, -1 !== this.getStartSearchSpace().substring(s3, this.startOffset).search(g.NON_BOUNDARY_CHARS) && (s3 = this.startOffset, t4++);
            } while (this.startOffset < this.getStartSearchSpace().length && t4 < e3);
          }
          this.mode === this.Mode.SHARED_START_AND_END && (this.startOffset = Math.min(this.startOffset, this.endOffset));
        }
        if (this.backwardsEndOffset() < this.getEndSearchSpace().length) {
          let t4 = 0;
          if (null != this.getEndSegments())
            for (; t4 < e3 && this.endOffset > 0; )
              this.endOffset = this.getNextOffsetBackwards(this.getEndSegments(), this.endOffset), t4++;
          else {
            let s3 = this.backwardsEndOffset();
            do {
              m();
              const e4 = this.getBackwardsEndSearchSpace().substring(this.backwardsEndOffset() + 1).search(g.BOUNDARY_CHARS);
              -1 === e4 ? this.setBackwardsEndOffset(this.getEndSearchSpace().length) : this.setBackwardsEndOffset(this.backwardsEndOffset() + 1 + e4), -1 !== this.getBackwardsEndSearchSpace().substring(s3, this.backwardsEndOffset()).search(g.NON_BOUNDARY_CHARS) && (s3 = this.backwardsEndOffset(), t4++);
            } while (this.backwardsEndOffset() < this.getEndSearchSpace().length && t4 < e3);
          }
          this.mode === this.Mode.SHARED_START_AND_END && (this.endOffset = Math.max(this.startOffset, this.endOffset));
        }
      }
      let t3 = false;
      if ((!e2 || this.startOffset + this.backwardsEndOffset() < 20 || this.numIterations >= 1) && (null != this.backwardsPrefixOffset() && this.backwardsPrefixOffset() !== this.getPrefixSearchSpace().length || null != this.suffixOffset && this.suffixOffset !== this.getSuffixSearchSpace().length) && (t3 = true), t3) {
        const e3 = this.getNumberOfContextWordsToAdd();
        if (this.backwardsPrefixOffset() < this.getPrefixSearchSpace().length) {
          let t4 = 0;
          if (null != this.getPrefixSegments())
            for (; t4 < e3 && this.prefixOffset > 0; )
              this.prefixOffset = this.getNextOffsetBackwards(this.getPrefixSegments(), this.prefixOffset), t4++;
          else {
            let s3 = this.backwardsPrefixOffset();
            do {
              m();
              const e4 = this.getBackwardsPrefixSearchSpace().substring(this.backwardsPrefixOffset() + 1).search(g.BOUNDARY_CHARS);
              -1 === e4 ? this.setBackwardsPrefixOffset(this.getBackwardsPrefixSearchSpace().length) : this.setBackwardsPrefixOffset(this.backwardsPrefixOffset() + 1 + e4), -1 !== this.getBackwardsPrefixSearchSpace().substring(s3, this.backwardsPrefixOffset()).search(g.NON_BOUNDARY_CHARS) && (s3 = this.backwardsPrefixOffset(), t4++);
            } while (this.backwardsPrefixOffset() < this.getPrefixSearchSpace().length && t4 < e3);
          }
        }
        if (this.suffixOffset < this.getSuffixSearchSpace().length) {
          let t4 = 0;
          if (null != this.getSuffixSegments())
            for (; t4 < e3 && this.suffixOffset < this.getSuffixSearchSpace().length; )
              this.suffixOffset = this.getNextOffsetForwards(this.getSuffixSegments(), this.suffixOffset, this.suffixOffset), t4++;
          else {
            let s3 = this.suffixOffset;
            do {
              m();
              const e4 = this.getSuffixSearchSpace().substring(this.suffixOffset + 1).search(g.BOUNDARY_CHARS);
              this.suffixOffset = -1 === e4 ? this.getSuffixSearchSpace().length : this.suffixOffset + 1 + e4, -1 !== this.getSuffixSearchSpace().substring(s3, this.suffixOffset).search(g.NON_BOUNDARY_CHARS) && (s3 = this.suffixOffset, t4++);
            } while (this.suffixOffset < this.getSuffixSearchSpace().length && t4 < e3);
          }
        }
      }
      return this.numIterations++, e2 || t3;
    }
    setStartAndEndSearchSpace(e2, t3) {
      return this.startSearchSpace = e2, this.endSearchSpace = t3, this.backwardsEndSearchSpace = I(t3), this.startOffset = 0, this.endOffset = t3.length, this.mode = this.Mode.ALL_PARTS, this;
    }
    setSharedSearchSpace(e2) {
      return this.sharedSearchSpace = e2, this.backwardsSharedSearchSpace = I(e2), this.startOffset = 0, this.endOffset = e2.length, this.mode = this.Mode.SHARED_START_AND_END, this;
    }
    setExactTextMatch(e2) {
      return this.exactTextMatch = e2, this.mode = this.Mode.CONTEXT_ONLY, this;
    }
    setPrefixAndSuffixSearchSpace(e2, t3) {
      return e2 && (this.prefixSearchSpace = e2, this.backwardsPrefixSearchSpace = I(e2), this.prefixOffset = e2.length), t3 && (this.suffixSearchSpace = t3, this.suffixOffset = 0), this;
    }
    useSegmenter(e2) {
      return null == e2 || (this.mode === this.Mode.ALL_PARTS ? (this.startSegments = e2.segment(this.startSearchSpace), this.endSegments = e2.segment(this.endSearchSpace)) : this.mode === this.Mode.SHARED_START_AND_END && (this.sharedSegments = e2.segment(this.sharedSearchSpace)), this.prefixSearchSpace && (this.prefixSegments = e2.segment(this.prefixSearchSpace)), this.suffixSearchSpace && (this.suffixSegments = e2.segment(this.suffixSearchSpace))), this;
    }
    getNumberOfContextWordsToAdd() {
      return 0 === this.backwardsPrefixOffset() && 0 === this.suffixOffset ? 3 : 1;
    }
    getNumberOfRangeWordsToAdd() {
      return 0 === this.startOffset && 0 === this.backwardsEndOffset() ? 3 : 1;
    }
    getNextOffsetForwards(e2, t3, s3) {
      let n3 = e2.containing(t3);
      for (; null != n3; ) {
        m();
        const t4 = n3.index + n3.segment.length;
        if (n3.isWordLike)
          return t4;
        n3 = e2.containing(t4);
      }
      return s3.length;
    }
    getNextOffsetBackwards(e2, t3) {
      let s3 = e2.containing(t3);
      for (s3 && t3 != s3.index || (s3 = e2.containing(t3 - 1)); null != s3; ) {
        if (m(), s3.isWordLike)
          return s3.index;
        s3 = e2.containing(s3.index - 1);
      }
      return 0;
    }
    getStartSearchSpace() {
      return this.mode === this.Mode.SHARED_START_AND_END ? this.sharedSearchSpace : this.startSearchSpace;
    }
    getStartSegments() {
      return this.mode === this.Mode.SHARED_START_AND_END ? this.sharedSegments : this.startSegments;
    }
    getEndSearchSpace() {
      return this.mode === this.Mode.SHARED_START_AND_END ? this.sharedSearchSpace : this.endSearchSpace;
    }
    getEndSegments() {
      return this.mode === this.Mode.SHARED_START_AND_END ? this.sharedSegments : this.endSegments;
    }
    getBackwardsEndSearchSpace() {
      return this.mode === this.Mode.SHARED_START_AND_END ? this.backwardsSharedSearchSpace : this.backwardsEndSearchSpace;
    }
    getPrefixSearchSpace() {
      return this.prefixSearchSpace;
    }
    getPrefixSegments() {
      return this.prefixSegments;
    }
    getBackwardsPrefixSearchSpace() {
      return this.backwardsPrefixSearchSpace;
    }
    getSuffixSearchSpace() {
      return this.suffixSearchSpace;
    }
    getSuffixSegments() {
      return this.suffixSegments;
    }
    backwardsEndOffset() {
      return this.getEndSearchSpace().length - this.endOffset;
    }
    setBackwardsEndOffset(e2) {
      this.endOffset = this.getEndSearchSpace().length - e2;
    }
    backwardsPrefixOffset() {
      return null == this.prefixOffset ? null : this.getPrefixSearchSpace().length - this.prefixOffset;
    }
    setBackwardsPrefixOffset(e2) {
      null != this.prefixOffset && (this.prefixOffset = this.getPrefixSearchSpace().length - e2);
    }
  };
  var k = class {
    constructor(e2, t3) {
      this.searchRange = e2, this.isForwardTraversal = t3, this.textFound = false, this.textNodes = [], this.textInBlock = null;
    }
    appendNode(e2) {
      if (null !== this.textInBlock)
        return;
      if (j(e2))
        return void (this.textFound ? (this.isForwardTraversal || this.textNodes.reverse(), this.textInBlock = this.textNodes.map((e3) => e3.textContent).join("").trim()) : this.textNodes = []);
      if (!q(e2))
        return;
      const t3 = this.getNodeIntersectionWithRange(e2);
      this.textFound = this.textFound || "" !== t3.textContent.trim(), this.textNodes.push(t3);
    }
    getNodeIntersectionWithRange(e2) {
      let t3 = null, s3 = null;
      return e2 === this.searchRange.startContainer && 0 !== this.searchRange.startOffset && (t3 = this.searchRange.startOffset), e2 === this.searchRange.endContainer && this.searchRange.endOffset !== e2.textContent.length && (s3 = this.searchRange.endOffset), null !== t3 || null !== s3 ? { textContent: e2.textContent.substring(t3 != null ? t3 : 0, s3 != null ? s3 : e2.textContent.length) } : e2;
    }
  };
  var b = (e2) => 1 === ((e3, t3 = document) => {
    const a3 = [], i3 = t3.createRange();
    for (i3.selectNodeContents(t3.body); !i3.collapsed && a3.length < 2; ) {
      let f3;
      if (e3.prefix) {
        const s3 = d(e3.prefix, i3);
        if (null == s3)
          break;
        r(i3, s3.startContainer, s3.startOffset);
        const n3 = t3.createRange();
        if (n3.setStart(s3.endContainer, s3.endOffset), n3.setEnd(i3.endContainer, i3.endOffset), u(n3), n3.collapsed)
          break;
        if (f3 = d(e3.textStart, n3), null == f3)
          break;
        if (0 !== f3.compareBoundaryPoints(Range.START_TO_START, n3))
          continue;
      } else {
        if (f3 = d(e3.textStart, i3), null == f3)
          break;
        r(i3, f3.startContainer, f3.startOffset);
      }
      if (e3.textEnd) {
        const u3 = t3.createRange();
        u3.setStart(f3.endContainer, f3.endOffset), u3.setEnd(i3.endContainer, i3.endOffset);
        let o3 = false;
        for (; !u3.collapsed && a3.length < 2; ) {
          const c3 = d(e3.textEnd, u3);
          if (null == c3)
            break;
          if (r(u3, c3.startContainer, c3.startOffset), f3.setEnd(c3.endContainer, c3.endOffset), e3.suffix) {
            const r3 = n(e3.suffix, f3, i3, t3);
            if (r3 === s.NO_SUFFIX_MATCH)
              break;
            if (r3 === s.SUFFIX_MATCH) {
              o3 = true, a3.push(f3.cloneRange());
              continue;
            }
            if (r3 === s.MISPLACED_SUFFIX)
              continue;
          } else
            o3 = true, a3.push(f3.cloneRange());
        }
        if (!o3)
          break;
      } else if (e3.suffix) {
        const u3 = n(e3.suffix, f3, i3, t3);
        if (u3 === s.NO_SUFFIX_MATCH)
          break;
        if (u3 === s.SUFFIX_MATCH) {
          a3.push(f3.cloneRange()), r(i3, i3.startContainer, i3.startOffset);
          continue;
        }
        if (u3 === s.MISPLACED_SUFFIX)
          continue;
      } else
        a3.push(f3.cloneRange());
    }
    return a3;
  })(e2).length;
  var I = (e2) => [...e2 || ""].reverse().join("");
  var L = (e2) => !(e2.toString().length > 300) && !y(e2);
  var M = (e2) => {
    let t3 = e2.startContainer;
    return t3.nodeType == Node.ELEMENT_NODE && e2.startOffset < t3.childNodes.length && (t3 = t3.childNodes[e2.startOffset]), t3;
  };
  var P = (e2) => {
    let t3 = e2.endContainer;
    return t3.nodeType == Node.ELEMENT_NODE && e2.endOffset > 0 && (t3 = t3.childNodes[e2.endOffset - 1]), t3;
  };
  var H = (e2) => {
    const t3 = M(e2);
    if (q(t3) && g.isNodeVisible(t3))
      return t3;
    const s3 = g.makeTextNodeWalker(e2);
    return s3.currentNode = t3, s3.nextNode();
  };
  var U = (e2) => {
    const t3 = P(e2);
    if (q(t3) && g.isNodeVisible(t3))
      return t3;
    const s3 = g.makeTextNodeWalker(e2);
    return s3.currentNode = t3, g.backwardTraverse(s3, /* @__PURE__ */ new Set());
  };
  var y = (e2) => {
    const t3 = e2.cloneRange();
    let s3 = M(t3);
    const n3 = W(s3);
    if (!n3)
      return false;
    const r3 = /* @__PURE__ */ new Set();
    for (; !t3.collapsed && null != s3; ) {
      if (j(s3))
        return true;
      null != s3 && t3.setStartAfter(s3), s3 = g.forwardTraverse(n3, r3), m();
    }
    return false;
  };
  var v = (e2, t3) => {
    if (e2.nodeType !== Node.TEXT_NODE)
      return -1;
    const s3 = null != t3 ? t3 : e2.data.length;
    if (s3 < e2.data.length && g.BOUNDARY_CHARS.test(e2.data[s3]))
      return s3;
    const n3 = e2.data.substring(0, s3), r3 = I(n3).search(g.BOUNDARY_CHARS);
    return -1 !== r3 ? s3 - r3 : -1;
  };
  var X = (e2, t3) => {
    if (e2.nodeType !== Node.TEXT_NODE)
      return -1;
    const s3 = null != t3 ? t3 : 0;
    if (s3 < e2.data.length && s3 > 0 && g.BOUNDARY_CHARS.test(e2.data[s3 - 1]))
      return s3;
    const n3 = e2.data.substring(s3).search(g.BOUNDARY_CHARS);
    return -1 !== n3 ? s3 + n3 : -1;
  };
  var W = (e2, t3) => {
    if (!e2)
      return;
    let s3 = e2;
    const n3 = null != t3 ? t3 : e2;
    for (; !s3.contains(n3) || !j(s3); )
      s3.parentNode && (s3 = s3.parentNode);
    const r3 = document.createTreeWalker(s3, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, (e3) => g.acceptNodeIfVisibleInRange(e3));
    return r3.currentNode = e2, r3;
  };
  var Y = (e2) => {
    const t3 = g.makeNewSegmenter();
    if (t3) {
      const s3 = M(e2);
      s3 !== e2.startContainer && e2.setStartBefore(s3), G(t3, false, e2);
    } else {
      const t4 = v(e2.startContainer, e2.startOffset);
      if (-1 !== t4)
        return void e2.setStart(e2.startContainer, t4);
      if (j(e2.startContainer) && 0 === e2.startOffset)
        return;
      const s3 = W(e2.startContainer);
      if (!s3)
        return;
      const n3 = /* @__PURE__ */ new Set();
      let r3 = g.backwardTraverse(s3, n3);
      for (; null != r3; ) {
        const t5 = v(r3);
        if (-1 !== t5)
          return void e2.setStart(r3, t5);
        if (j(r3))
          return void (r3.contains(e2.startContainer) ? e2.setStart(r3, 0) : e2.setStartAfter(r3));
        r3 = g.backwardTraverse(s3, n3), e2.collapse();
      }
    }
  };
  var V = (e2) => {
    const t3 = H(e2);
    if (null == t3)
      return void e2.collapse();
    M(e2) !== t3 && e2.setStart(t3, 0);
    const s3 = P(e2), n3 = U(e2);
    s3 !== n3 && e2.setEnd(n3, n3.textContent.length);
  };
  var G = (e2, t3, s3) => {
    const n3 = t3 ? { node: s3.endContainer, offset: s3.endOffset } : { node: s3.startContainer, offset: s3.startOffset }, r3 = K(n3.node), u3 = r3.preNodes.reduce((e3, t4) => e3.concat(t4.textContent), ""), a3 = r3.innerNodes.reduce((e3, t4) => e3.concat(t4.textContent), "");
    let i3 = u3.length;
    n3.node.nodeType === Node.TEXT_NODE ? i3 += n3.offset : t3 && (i3 += a3.length);
    const f3 = r3.postNodes.reduce((e3, t4) => e3.concat(t4.textContent), ""), o3 = [...r3.preNodes, ...r3.innerNodes, ...r3.postNodes];
    if (0 == o3.length)
      return;
    const c3 = u3.concat(a3, f3), d3 = e2.segment(c3).containing(i3);
    if (!d3)
      return void (t3 ? s3.setEndAfter(o3[o3.length - 1]) : s3.setEndBefore(o3[0]));
    if (!d3.isWordLike)
      return;
    if (i3 === d3.index || i3 === d3.index + d3.segment.length)
      return;
    const h3 = t3 ? d3.index + d3.segment.length : d3.index;
    let l3 = 0;
    for (const e3 of o3) {
      if (l3 <= h3 && h3 < l3 + e3.textContent.length) {
        const n4 = h3 - l3;
        return void (t3 ? n4 >= e3.textContent.length ? s3.setEndAfter(e3) : s3.setEnd(e3, n4) : n4 >= e3.textContent.length ? s3.setStartAfter(e3) : s3.setStart(e3, n4));
      }
      l3 += e3.textContent.length;
    }
    t3 ? s3.setEndAfter(o3[o3.length - 1]) : s3.setStartBefore(o3[0]);
  };
  var K = (e2) => {
    const t3 = [], s3 = W(e2);
    if (!s3)
      return;
    const n3 = /* @__PURE__ */ new Set();
    let r3 = g.backwardTraverse(s3, n3);
    for (; null != r3 && !j(r3); )
      m(), r3.nodeType === Node.TEXT_NODE && t3.push(r3), r3 = g.backwardTraverse(s3, n3);
    t3.reverse();
    const u3 = [];
    if (e2.nodeType === Node.TEXT_NODE)
      u3.push(e2);
    else {
      const t4 = document.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, (e3) => g.acceptNodeIfVisibleInRange(e3));
      t4.currentNode = e2;
      let s4 = t4.nextNode();
      for (; null != s4; )
        m(), s4.nodeType === Node.TEXT_NODE && u3.push(s4), s4 = t4.nextNode();
    }
    const a3 = [], i3 = W(e2);
    if (!i3)
      return;
    const f3 = /* @__PURE__ */ new Set([e2]);
    let o3 = g.forwardTraverse(i3, f3);
    for (; null != o3 && !j(o3); )
      m(), o3.nodeType === Node.TEXT_NODE && a3.push(o3), o3 = g.forwardTraverse(i3, f3);
    return { preNodes: t3, innerNodes: u3, postNodes: a3 };
  };
  var z = (e2) => {
    const t3 = g.makeNewSegmenter();
    if (t3) {
      const s3 = P(e2);
      s3 !== e2.endContainer && e2.setEndAfter(s3), G(t3, true, e2);
    } else {
      let t4 = e2.endOffset, s3 = e2.endContainer;
      s3.nodeType === Node.ELEMENT_NODE && e2.endOffset < s3.childNodes.length && (s3 = s3.childNodes[e2.endOffset]);
      const n3 = W(s3);
      if (!n3)
        return;
      const r3 = /* @__PURE__ */ new Set([s3]);
      for (; null != s3; ) {
        m();
        const u3 = X(s3, t4);
        if (t4 = null, -1 !== u3)
          return void e2.setEnd(s3, u3);
        if (j(s3))
          return void (s3.contains(e2.endContainer) ? e2.setEnd(s3, s3.childNodes.length) : e2.setEndBefore(s3));
        s3 = g.forwardTraverse(n3, r3);
      }
      e2.collapse();
    }
  };
  var j = (e2) => e2.nodeType === Node.ELEMENT_NODE && (g.BLOCK_ELEMENTS.includes(e2.tagName) || "HTML" === e2.tagName || "BODY" === e2.tagName);
  var q = (e2) => e2.nodeType === Node.TEXT_NODE;
  "undefined" != typeof goog && goog.declareModuleId("googleChromeLabs.textFragmentPolyfill.fragmentGenerationUtils");

  // ../howdju-client-common/lib/actions.ts
  var actions_exports = {};
  __export(actions_exports, {
    extension: () => extension,
    extensionFrame: () => extensionFrame,
    str: () => str
  });

  // ../node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.esm.mjs
  function n2(n3) {
    for (var r3 = arguments.length, t3 = Array(r3 > 1 ? r3 - 1 : 0), e2 = 1; e2 < r3; e2++)
      t3[e2 - 1] = arguments[e2];
    if (true) {
      var i3 = Y2[n3], o3 = i3 ? "function" == typeof i3 ? i3.apply(null, t3) : i3 : "unknown error nr: " + n3;
      throw Error("[Immer] " + o3);
    }
    throw Error("[Immer] minified error nr: " + n3 + (t3.length ? " " + t3.map(function(n4) {
      return "'" + n4 + "'";
    }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
  }
  function r2(n3) {
    return !!n3 && !!n3[Q];
  }
  function t2(n3) {
    var r3;
    return !!n3 && (function(n4) {
      if (!n4 || "object" != typeof n4)
        return false;
      var r4 = Object.getPrototypeOf(n4);
      if (null === r4)
        return true;
      var t3 = Object.hasOwnProperty.call(r4, "constructor") && r4.constructor;
      return t3 === Object || "function" == typeof t3 && Function.toString.call(t3) === Z;
    }(n3) || Array.isArray(n3) || !!n3[L2] || !!(null === (r3 = n3.constructor) || void 0 === r3 ? void 0 : r3[L2]) || s2(n3) || v2(n3));
  }
  function i2(n3, r3, t3) {
    void 0 === t3 && (t3 = false), 0 === o2(n3) ? (t3 ? Object.keys : nn)(n3).forEach(function(e2) {
      t3 && "symbol" == typeof e2 || r3(e2, n3[e2], n3);
    }) : n3.forEach(function(t4, e2) {
      return r3(e2, t4, n3);
    });
  }
  function o2(n3) {
    var r3 = n3[Q];
    return r3 ? r3.i > 3 ? r3.i - 4 : r3.i : Array.isArray(n3) ? 1 : s2(n3) ? 2 : v2(n3) ? 3 : 0;
  }
  function u2(n3, r3) {
    return 2 === o2(n3) ? n3.has(r3) : Object.prototype.hasOwnProperty.call(n3, r3);
  }
  function a2(n3, r3) {
    return 2 === o2(n3) ? n3.get(r3) : n3[r3];
  }
  function f2(n3, r3, t3) {
    var e2 = o2(n3);
    2 === e2 ? n3.set(r3, t3) : 3 === e2 ? n3.add(t3) : n3[r3] = t3;
  }
  function c2(n3, r3) {
    return n3 === r3 ? 0 !== n3 || 1 / n3 == 1 / r3 : n3 != n3 && r3 != r3;
  }
  function s2(n3) {
    return X2 && n3 instanceof Map;
  }
  function v2(n3) {
    return q2 && n3 instanceof Set;
  }
  function p2(n3) {
    return n3.o || n3.t;
  }
  function l2(n3) {
    if (Array.isArray(n3))
      return Array.prototype.slice.call(n3);
    var r3 = rn(n3);
    delete r3[Q];
    for (var t3 = nn(r3), e2 = 0; e2 < t3.length; e2++) {
      var i3 = t3[e2], o3 = r3[i3];
      false === o3.writable && (o3.writable = true, o3.configurable = true), (o3.get || o3.set) && (r3[i3] = { configurable: true, writable: true, enumerable: o3.enumerable, value: n3[i3] });
    }
    return Object.create(Object.getPrototypeOf(n3), r3);
  }
  function d2(n3, e2) {
    return void 0 === e2 && (e2 = false), y2(n3) || r2(n3) || !t2(n3) || (o2(n3) > 1 && (n3.set = n3.add = n3.clear = n3.delete = h2), Object.freeze(n3), e2 && i2(n3, function(n4, r3) {
      return d2(r3, true);
    }, true)), n3;
  }
  function h2() {
    n2(2);
  }
  function y2(n3) {
    return null == n3 || "object" != typeof n3 || Object.isFrozen(n3);
  }
  function b2(r3) {
    var t3 = tn[r3];
    return t3 || n2(18, r3), t3;
  }
  function m2(n3, r3) {
    tn[n3] || (tn[n3] = r3);
  }
  function _2() {
    return U2 || n2(0), U2;
  }
  function j2(n3, r3) {
    r3 && (b2("Patches"), n3.u = [], n3.s = [], n3.v = r3);
  }
  function g2(n3) {
    O2(n3), n3.p.forEach(S2), n3.p = null;
  }
  function O2(n3) {
    n3 === U2 && (U2 = n3.l);
  }
  function w2(n3) {
    return U2 = { p: [], l: U2, h: n3, m: true, _: 0 };
  }
  function S2(n3) {
    var r3 = n3[Q];
    0 === r3.i || 1 === r3.i ? r3.j() : r3.g = true;
  }
  function P2(r3, e2) {
    e2._ = e2.p.length;
    var i3 = e2.p[0], o3 = void 0 !== r3 && r3 !== i3;
    return e2.h.O || b2("ES5").S(e2, r3, o3), o3 ? (i3[Q].P && (g2(e2), n2(4)), t2(r3) && (r3 = M2(e2, r3), e2.l || x2(e2, r3)), e2.u && b2("Patches").M(i3[Q].t, r3, e2.u, e2.s)) : r3 = M2(e2, i3, []), g2(e2), e2.u && e2.v(e2.u, e2.s), r3 !== H2 ? r3 : void 0;
  }
  function M2(n3, r3, t3) {
    if (y2(r3))
      return r3;
    var e2 = r3[Q];
    if (!e2)
      return i2(r3, function(i3, o4) {
        return A2(n3, e2, r3, i3, o4, t3);
      }, true), r3;
    if (e2.A !== n3)
      return r3;
    if (!e2.P)
      return x2(n3, e2.t, true), e2.t;
    if (!e2.I) {
      e2.I = true, e2.A._--;
      var o3 = 4 === e2.i || 5 === e2.i ? e2.o = l2(e2.k) : e2.o, u3 = o3, a3 = false;
      3 === e2.i && (u3 = new Set(o3), o3.clear(), a3 = true), i2(u3, function(r4, i3) {
        return A2(n3, e2, o3, r4, i3, t3, a3);
      }), x2(n3, o3, false), t3 && n3.u && b2("Patches").N(e2, t3, n3.u, n3.s);
    }
    return e2.o;
  }
  function A2(e2, i3, o3, a3, c3, s3, v3) {
    if (c3 === o3 && n2(5), r2(c3)) {
      var p3 = M2(e2, c3, s3 && i3 && 3 !== i3.i && !u2(i3.R, a3) ? s3.concat(a3) : void 0);
      if (f2(o3, a3, p3), !r2(p3))
        return;
      e2.m = false;
    } else
      v3 && o3.add(c3);
    if (t2(c3) && !y2(c3)) {
      if (!e2.h.D && e2._ < 1)
        return;
      M2(e2, c3), i3 && i3.A.l || x2(e2, c3);
    }
  }
  function x2(n3, r3, t3) {
    void 0 === t3 && (t3 = false), !n3.l && n3.h.D && n3.m && d2(r3, t3);
  }
  function z2(n3, r3) {
    var t3 = n3[Q];
    return (t3 ? p2(t3) : n3)[r3];
  }
  function I2(n3, r3) {
    if (r3 in n3)
      for (var t3 = Object.getPrototypeOf(n3); t3; ) {
        var e2 = Object.getOwnPropertyDescriptor(t3, r3);
        if (e2)
          return e2;
        t3 = Object.getPrototypeOf(t3);
      }
  }
  function k2(n3) {
    n3.P || (n3.P = true, n3.l && k2(n3.l));
  }
  function E2(n3) {
    n3.o || (n3.o = l2(n3.t));
  }
  function N2(n3, r3, t3) {
    var e2 = s2(r3) ? b2("MapSet").F(r3, t3) : v2(r3) ? b2("MapSet").T(r3, t3) : n3.O ? function(n4, r4) {
      var t4 = Array.isArray(n4), e3 = { i: t4 ? 1 : 0, A: r4 ? r4.A : _2(), P: false, I: false, R: {}, l: r4, t: n4, k: null, o: null, j: null, C: false }, i3 = e3, o3 = en;
      t4 && (i3 = [e3], o3 = on);
      var u3 = Proxy.revocable(i3, o3), a3 = u3.revoke, f3 = u3.proxy;
      return e3.k = f3, e3.j = a3, f3;
    }(r3, t3) : b2("ES5").J(r3, t3);
    return (t3 ? t3.A : _2()).p.push(e2), e2;
  }
  function R2(e2) {
    return r2(e2) || n2(22, e2), function n3(r3) {
      if (!t2(r3))
        return r3;
      var e3, u3 = r3[Q], c3 = o2(r3);
      if (u3) {
        if (!u3.P && (u3.i < 4 || !b2("ES5").K(u3)))
          return u3.t;
        u3.I = true, e3 = D2(r3, c3), u3.I = false;
      } else
        e3 = D2(r3, c3);
      return i2(e3, function(r4, t3) {
        u3 && a2(u3.t, r4) === t3 || f2(e3, r4, n3(t3));
      }), 3 === c3 ? new Set(e3) : e3;
    }(e2);
  }
  function D2(n3, r3) {
    switch (r3) {
      case 2:
        return new Map(n3);
      case 3:
        return Array.from(n3);
    }
    return l2(n3);
  }
  function F2() {
    function t3(n3, r3) {
      var t4 = s3[n3];
      return t4 ? t4.enumerable = r3 : s3[n3] = t4 = { configurable: true, enumerable: r3, get: function() {
        var r4 = this[Q];
        return f3(r4), en.get(r4, n3);
      }, set: function(r4) {
        var t5 = this[Q];
        f3(t5), en.set(t5, n3, r4);
      } }, t4;
    }
    function e2(n3) {
      for (var r3 = n3.length - 1; r3 >= 0; r3--) {
        var t4 = n3[r3][Q];
        if (!t4.P)
          switch (t4.i) {
            case 5:
              a3(t4) && k2(t4);
              break;
            case 4:
              o3(t4) && k2(t4);
          }
      }
    }
    function o3(n3) {
      for (var r3 = n3.t, t4 = n3.k, e3 = nn(t4), i3 = e3.length - 1; i3 >= 0; i3--) {
        var o4 = e3[i3];
        if (o4 !== Q) {
          var a4 = r3[o4];
          if (void 0 === a4 && !u2(r3, o4))
            return true;
          var f4 = t4[o4], s4 = f4 && f4[Q];
          if (s4 ? s4.t !== a4 : !c2(f4, a4))
            return true;
        }
      }
      var v3 = !!r3[Q];
      return e3.length !== nn(r3).length + (v3 ? 0 : 1);
    }
    function a3(n3) {
      var r3 = n3.k;
      if (r3.length !== n3.t.length)
        return true;
      var t4 = Object.getOwnPropertyDescriptor(r3, r3.length - 1);
      if (t4 && !t4.get)
        return true;
      for (var e3 = 0; e3 < r3.length; e3++)
        if (!r3.hasOwnProperty(e3))
          return true;
      return false;
    }
    function f3(r3) {
      r3.g && n2(3, JSON.stringify(p2(r3)));
    }
    var s3 = {};
    m2("ES5", { J: function(n3, r3) {
      var e3 = Array.isArray(n3), i3 = function(n4, r4) {
        if (n4) {
          for (var e4 = Array(r4.length), i4 = 0; i4 < r4.length; i4++)
            Object.defineProperty(e4, "" + i4, t3(i4, true));
          return e4;
        }
        var o5 = rn(r4);
        delete o5[Q];
        for (var u3 = nn(o5), a4 = 0; a4 < u3.length; a4++) {
          var f4 = u3[a4];
          o5[f4] = t3(f4, n4 || !!o5[f4].enumerable);
        }
        return Object.create(Object.getPrototypeOf(r4), o5);
      }(e3, n3), o4 = { i: e3 ? 5 : 4, A: r3 ? r3.A : _2(), P: false, I: false, R: {}, l: r3, t: n3, k: i3, o: null, g: false, C: false };
      return Object.defineProperty(i3, Q, { value: o4, writable: true }), i3;
    }, S: function(n3, t4, o4) {
      o4 ? r2(t4) && t4[Q].A === n3 && e2(n3.p) : (n3.u && function n4(r3) {
        if (r3 && "object" == typeof r3) {
          var t5 = r3[Q];
          if (t5) {
            var e3 = t5.t, o5 = t5.k, f4 = t5.R, c3 = t5.i;
            if (4 === c3)
              i2(o5, function(r4) {
                r4 !== Q && (void 0 !== e3[r4] || u2(e3, r4) ? f4[r4] || n4(o5[r4]) : (f4[r4] = true, k2(t5)));
              }), i2(e3, function(n5) {
                void 0 !== o5[n5] || u2(o5, n5) || (f4[n5] = false, k2(t5));
              });
            else if (5 === c3) {
              if (a3(t5) && (k2(t5), f4.length = true), o5.length < e3.length)
                for (var s4 = o5.length; s4 < e3.length; s4++)
                  f4[s4] = false;
              else
                for (var v3 = e3.length; v3 < o5.length; v3++)
                  f4[v3] = true;
              for (var p3 = Math.min(o5.length, e3.length), l3 = 0; l3 < p3; l3++)
                o5.hasOwnProperty(l3) || (f4[l3] = true), void 0 === f4[l3] && n4(o5[l3]);
            }
          }
        }
      }(n3.p[0]), e2(n3.p));
    }, K: function(n3) {
      return 4 === n3.i ? o3(n3) : a3(n3);
    } });
  }
  var G2;
  var U2;
  var W2 = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
  var X2 = "undefined" != typeof Map;
  var q2 = "undefined" != typeof Set;
  var B2 = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
  var H2 = W2 ? Symbol.for("immer-nothing") : ((G2 = {})["immer-nothing"] = true, G2);
  var L2 = W2 ? Symbol.for("immer-draftable") : "__$immer_draftable";
  var Q = W2 ? Symbol.for("immer-state") : "__$immer_state";
  var Y2 = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n3) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n3;
  }, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n3) {
    return "Cannot apply patch, path doesn't resolve: " + n3;
  }, 16: 'Sets cannot have "replace" patches.', 17: function(n3) {
    return "Unsupported patch operation: " + n3;
  }, 18: function(n3) {
    return "The plugin for '" + n3 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n3 + "()` when initializing your application.";
  }, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n3) {
    return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n3 + "'";
  }, 22: function(n3) {
    return "'current' expects a draft, got: " + n3;
  }, 23: function(n3) {
    return "'original' expects a draft, got: " + n3;
  }, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
  var Z = "" + Object.prototype.constructor;
  var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n3) {
    return Object.getOwnPropertyNames(n3).concat(Object.getOwnPropertySymbols(n3));
  } : Object.getOwnPropertyNames;
  var rn = Object.getOwnPropertyDescriptors || function(n3) {
    var r3 = {};
    return nn(n3).forEach(function(t3) {
      r3[t3] = Object.getOwnPropertyDescriptor(n3, t3);
    }), r3;
  };
  var tn = {};
  var en = { get: function(n3, r3) {
    if (r3 === Q)
      return n3;
    var e2 = p2(n3);
    if (!u2(e2, r3))
      return function(n4, r4, t3) {
        var e3, i4 = I2(r4, t3);
        return i4 ? "value" in i4 ? i4.value : null === (e3 = i4.get) || void 0 === e3 ? void 0 : e3.call(n4.k) : void 0;
      }(n3, e2, r3);
    var i3 = e2[r3];
    return n3.I || !t2(i3) ? i3 : i3 === z2(n3.t, r3) ? (E2(n3), n3.o[r3] = N2(n3.A.h, i3, n3)) : i3;
  }, has: function(n3, r3) {
    return r3 in p2(n3);
  }, ownKeys: function(n3) {
    return Reflect.ownKeys(p2(n3));
  }, set: function(n3, r3, t3) {
    var e2 = I2(p2(n3), r3);
    if (null == e2 ? void 0 : e2.set)
      return e2.set.call(n3.k, t3), true;
    if (!n3.P) {
      var i3 = z2(p2(n3), r3), o3 = null == i3 ? void 0 : i3[Q];
      if (o3 && o3.t === t3)
        return n3.o[r3] = t3, n3.R[r3] = false, true;
      if (c2(t3, i3) && (void 0 !== t3 || u2(n3.t, r3)))
        return true;
      E2(n3), k2(n3);
    }
    return n3.o[r3] === t3 && (void 0 !== t3 || r3 in n3.o) || Number.isNaN(t3) && Number.isNaN(n3.o[r3]) || (n3.o[r3] = t3, n3.R[r3] = true), true;
  }, deleteProperty: function(n3, r3) {
    return void 0 !== z2(n3.t, r3) || r3 in n3.t ? (n3.R[r3] = false, E2(n3), k2(n3)) : delete n3.R[r3], n3.o && delete n3.o[r3], true;
  }, getOwnPropertyDescriptor: function(n3, r3) {
    var t3 = p2(n3), e2 = Reflect.getOwnPropertyDescriptor(t3, r3);
    return e2 ? { writable: true, configurable: 1 !== n3.i || "length" !== r3, enumerable: e2.enumerable, value: t3[r3] } : e2;
  }, defineProperty: function() {
    n2(11);
  }, getPrototypeOf: function(n3) {
    return Object.getPrototypeOf(n3.t);
  }, setPrototypeOf: function() {
    n2(12);
  } };
  var on = {};
  i2(en, function(n3, r3) {
    on[n3] = function() {
      return arguments[0] = arguments[0][0], r3.apply(this, arguments);
    };
  }), on.deleteProperty = function(r3, t3) {
    return isNaN(parseInt(t3)) && n2(13), on.set.call(this, r3, t3, void 0);
  }, on.set = function(r3, t3, e2) {
    return "length" !== t3 && isNaN(parseInt(t3)) && n2(14), en.set.call(this, r3[0], t3, e2, r3[0]);
  };
  var un = function() {
    function e2(r3) {
      var e3 = this;
      this.O = B2, this.D = true, this.produce = function(r4, i4, o3) {
        if ("function" == typeof r4 && "function" != typeof i4) {
          var u3 = i4;
          i4 = r4;
          var a3 = e3;
          return function(n3) {
            var r5 = this;
            void 0 === n3 && (n3 = u3);
            for (var t3 = arguments.length, e4 = Array(t3 > 1 ? t3 - 1 : 0), o4 = 1; o4 < t3; o4++)
              e4[o4 - 1] = arguments[o4];
            return a3.produce(n3, function(n4) {
              var t4;
              return (t4 = i4).call.apply(t4, [r5, n4].concat(e4));
            });
          };
        }
        var f3;
        if ("function" != typeof i4 && n2(6), void 0 !== o3 && "function" != typeof o3 && n2(7), t2(r4)) {
          var c3 = w2(e3), s3 = N2(e3, r4, void 0), v3 = true;
          try {
            f3 = i4(s3), v3 = false;
          } finally {
            v3 ? g2(c3) : O2(c3);
          }
          return "undefined" != typeof Promise && f3 instanceof Promise ? f3.then(function(n3) {
            return j2(c3, o3), P2(n3, c3);
          }, function(n3) {
            throw g2(c3), n3;
          }) : (j2(c3, o3), P2(f3, c3));
        }
        if (!r4 || "object" != typeof r4) {
          if (void 0 === (f3 = i4(r4)) && (f3 = r4), f3 === H2 && (f3 = void 0), e3.D && d2(f3, true), o3) {
            var p3 = [], l3 = [];
            b2("Patches").M(r4, f3, p3, l3), o3(p3, l3);
          }
          return f3;
        }
        n2(21, r4);
      }, this.produceWithPatches = function(n3, r4) {
        if ("function" == typeof n3)
          return function(r5) {
            for (var t4 = arguments.length, i5 = Array(t4 > 1 ? t4 - 1 : 0), o4 = 1; o4 < t4; o4++)
              i5[o4 - 1] = arguments[o4];
            return e3.produceWithPatches(r5, function(r6) {
              return n3.apply(void 0, [r6].concat(i5));
            });
          };
        var t3, i4, o3 = e3.produce(n3, r4, function(n4, r5) {
          t3 = n4, i4 = r5;
        });
        return "undefined" != typeof Promise && o3 instanceof Promise ? o3.then(function(n4) {
          return [n4, t3, i4];
        }) : [o3, t3, i4];
      }, "boolean" == typeof (null == r3 ? void 0 : r3.useProxies) && this.setUseProxies(r3.useProxies), "boolean" == typeof (null == r3 ? void 0 : r3.autoFreeze) && this.setAutoFreeze(r3.autoFreeze);
    }
    var i3 = e2.prototype;
    return i3.createDraft = function(e3) {
      t2(e3) || n2(8), r2(e3) && (e3 = R2(e3));
      var i4 = w2(this), o3 = N2(this, e3, void 0);
      return o3[Q].C = true, O2(i4), o3;
    }, i3.finishDraft = function(r3, t3) {
      var e3 = r3 && r3[Q];
      e3 && e3.C || n2(9), e3.I && n2(10);
      var i4 = e3.A;
      return j2(i4, t3), P2(void 0, i4);
    }, i3.setAutoFreeze = function(n3) {
      this.D = n3;
    }, i3.setUseProxies = function(r3) {
      r3 && !B2 && n2(20), this.O = r3;
    }, i3.applyPatches = function(n3, t3) {
      var e3;
      for (e3 = t3.length - 1; e3 >= 0; e3--) {
        var i4 = t3[e3];
        if (0 === i4.path.length && "replace" === i4.op) {
          n3 = i4.value;
          break;
        }
      }
      e3 > -1 && (t3 = t3.slice(e3 + 1));
      var o3 = b2("Patches").$;
      return r2(n3) ? o3(n3, t3) : this.produce(n3, function(n4) {
        return o3(n4, t3);
      });
    }, e2;
  }();
  var an = new un();
  var fn = an.produce;
  var cn = an.produceWithPatches.bind(an);
  var sn = an.setAutoFreeze.bind(an);
  var vn = an.setUseProxies.bind(an);
  var pn = an.applyPatches.bind(an);
  var ln = an.createDraft.bind(an);
  var dn = an.finishDraft.bind(an);

  // ../node_modules/@reduxjs/toolkit/node_modules/redux/es/redux.js
  var $$observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  var randomString = function randomString2() {
    return Math.random().toString(36).substring(7).split("").join(".");
  };
  var ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    }
  };
  function compose() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }
    if (funcs.length === 0) {
      return function(arg) {
        return arg;
      };
    }
    if (funcs.length === 1) {
      return funcs[0];
    }
    return funcs.reduce(function(a3, b3) {
      return function() {
        return a3(b3.apply(void 0, arguments));
      };
    });
  }

  // ../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js
  var __extends = function() {
    var extendStatics = function(d3, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
        d4.__proto__ = b4;
      } || function(d4, b4) {
        for (var p3 in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p3))
            d4[p3] = b4[p3];
      };
      return extendStatics(d3, b3);
    };
    return function(d3, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d3, b3);
      function __() {
        this.constructor = d3;
      }
      d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
    };
  }();
  var __generator = function(thisArg, body) {
    var _3 = { label: 0, sent: function() {
      if (t3[0] & 1)
        throw t3[1];
      return t3[1];
    }, trys: [], ops: [] }, f3, y3, t3, g3;
    return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
      return this;
    }), g3;
    function verb(n3) {
      return function(v3) {
        return step([n3, v3]);
      };
    }
    function step(op) {
      if (f3)
        throw new TypeError("Generator is already executing.");
      while (_3)
        try {
          if (f3 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
            return t3;
          if (y3 = 0, t3)
            op = [op[0] & 2, t3.value];
          switch (op[0]) {
            case 0:
            case 1:
              t3 = op;
              break;
            case 4:
              _3.label++;
              return { value: op[1], done: false };
            case 5:
              _3.label++;
              y3 = op[1];
              op = [0];
              continue;
            case 7:
              op = _3.ops.pop();
              _3.trys.pop();
              continue;
            default:
              if (!(t3 = _3.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _3 = 0;
                continue;
              }
              if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                _3.label = op[1];
                break;
              }
              if (op[0] === 6 && _3.label < t3[1]) {
                _3.label = t3[1];
                t3 = op;
                break;
              }
              if (t3 && _3.label < t3[2]) {
                _3.label = t3[2];
                _3.ops.push(op);
                break;
              }
              if (t3[2])
                _3.ops.pop();
              _3.trys.pop();
              continue;
          }
          op = body.call(thisArg, _3);
        } catch (e2) {
          op = [6, e2];
          y3 = 0;
        } finally {
          f3 = t3 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __spreadArray = function(to, from) {
    for (var i3 = 0, il = from.length, j3 = to.length; i3 < il; i3++, j3++)
      to[j3] = from[i3];
    return to;
  };
  var __defProp2 = Object.defineProperty;
  var __defProps2 = Object.defineProperties;
  var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp2 = function(obj, key, value) {
    return key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  };
  var __spreadValues2 = function(a3, b3) {
    for (var prop in b3 || (b3 = {}))
      if (__hasOwnProp2.call(b3, prop))
        __defNormalProp2(a3, prop, b3[prop]);
    if (__getOwnPropSymbols2)
      for (var _i = 0, _c = __getOwnPropSymbols2(b3); _i < _c.length; _i++) {
        var prop = _c[_i];
        if (__propIsEnum2.call(b3, prop))
          __defNormalProp2(a3, prop, b3[prop]);
      }
    return a3;
  };
  var __spreadProps2 = function(a3, b3) {
    return __defProps2(a3, __getOwnPropDescs2(b3));
  };
  var __async2 = function(__this, __arguments, generator) {
    return new Promise(function(resolve, reject2) {
      var fulfilled = function(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject2(e2);
        }
      };
      var rejected = function(value) {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject2(e2);
        }
      };
      var step = function(x3) {
        return x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
      };
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
    if (arguments.length === 0)
      return void 0;
    if (typeof arguments[0] === "object")
      return compose;
    return compose.apply(null, arguments);
  };
  var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
    return function(noop2) {
      return noop2;
    };
  };
  var MiddlewareArray = (
    /** @class */
    function(_super) {
      __extends(MiddlewareArray2, _super);
      function MiddlewareArray2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, args) || this;
        Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
        return _this;
      }
      Object.defineProperty(MiddlewareArray2, Symbol.species, {
        get: function() {
          return MiddlewareArray2;
        },
        enumerable: false,
        configurable: true
      });
      MiddlewareArray2.prototype.concat = function() {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          arr[_i] = arguments[_i];
        }
        return _super.prototype.concat.apply(this, arr);
      };
      MiddlewareArray2.prototype.prepend = function() {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          arr[_i] = arguments[_i];
        }
        if (arr.length === 1 && Array.isArray(arr[0])) {
          return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr[0].concat(this))))();
        }
        return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr.concat(this))))();
      };
      return MiddlewareArray2;
    }(Array)
  );
  var EnhancerArray = (
    /** @class */
    function(_super) {
      __extends(EnhancerArray2, _super);
      function EnhancerArray2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, args) || this;
        Object.setPrototypeOf(_this, EnhancerArray2.prototype);
        return _this;
      }
      Object.defineProperty(EnhancerArray2, Symbol.species, {
        get: function() {
          return EnhancerArray2;
        },
        enumerable: false,
        configurable: true
      });
      EnhancerArray2.prototype.concat = function() {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          arr[_i] = arguments[_i];
        }
        return _super.prototype.concat.apply(this, arr);
      };
      EnhancerArray2.prototype.prepend = function() {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          arr[_i] = arguments[_i];
        }
        if (arr.length === 1 && Array.isArray(arr[0])) {
          return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray([void 0], arr[0].concat(this))))();
        }
        return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray([void 0], arr.concat(this))))();
      };
      return EnhancerArray2;
    }(Array)
  );
  function createAction(type, prepareAction) {
    function actionCreator() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (prepareAction) {
        var prepared = prepareAction.apply(void 0, args);
        if (!prepared) {
          throw new Error("prepareAction did not return an object");
        }
        return __spreadValues2(__spreadValues2({
          type,
          payload: prepared.payload
        }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
      }
      return { type, payload: args[0] };
    }
    actionCreator.toString = function() {
      return "" + type;
    };
    actionCreator.type = type;
    actionCreator.match = function(action) {
      return action.type === type;
    };
    return actionCreator;
  }
  var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
  var nanoid = function(size) {
    if (size === void 0) {
      size = 21;
    }
    var id = "";
    var i3 = size;
    while (i3--) {
      id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
  };
  var commonProperties = [
    "name",
    "message",
    "stack",
    "code"
  ];
  var RejectWithValue = (
    /** @class */
    function() {
      function RejectWithValue2(payload, meta) {
        this.payload = payload;
        this.meta = meta;
      }
      return RejectWithValue2;
    }()
  );
  var FulfillWithMeta = (
    /** @class */
    function() {
      function FulfillWithMeta2(payload, meta) {
        this.payload = payload;
        this.meta = meta;
      }
      return FulfillWithMeta2;
    }()
  );
  var miniSerializeError = function(value) {
    if (typeof value === "object" && value !== null) {
      var simpleError = {};
      for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
        var property = commonProperties_1[_i];
        if (typeof value[property] === "string") {
          simpleError[property] = value[property];
        }
      }
      return simpleError;
    }
    return { message: String(value) };
  };
  var createAsyncThunk = function() {
    function createAsyncThunk2(typePrefix, payloadCreator, options) {
      var fulfilled = createAction(typePrefix + "/fulfilled", function(payload, requestId, arg, meta) {
        return {
          payload,
          meta: __spreadProps2(__spreadValues2({}, meta || {}), {
            arg,
            requestId,
            requestStatus: "fulfilled"
          })
        };
      });
      var pending = createAction(typePrefix + "/pending", function(requestId, arg, meta) {
        return {
          payload: void 0,
          meta: __spreadProps2(__spreadValues2({}, meta || {}), {
            arg,
            requestId,
            requestStatus: "pending"
          })
        };
      });
      var rejected = createAction(typePrefix + "/rejected", function(error, requestId, arg, payload, meta) {
        return {
          payload,
          error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
          meta: __spreadProps2(__spreadValues2({}, meta || {}), {
            arg,
            requestId,
            rejectedWithValue: !!payload,
            requestStatus: "rejected",
            aborted: (error == null ? void 0 : error.name) === "AbortError",
            condition: (error == null ? void 0 : error.name) === "ConditionError"
          })
        };
      });
      var displayedWarning = false;
      var AC = typeof AbortController !== "undefined" ? AbortController : (
        /** @class */
        function() {
          function class_1() {
            this.signal = {
              aborted: false,
              addEventListener: function() {
              },
              dispatchEvent: function() {
                return false;
              },
              onabort: function() {
              },
              removeEventListener: function() {
              },
              reason: void 0,
              throwIfAborted: function() {
              }
            };
          }
          class_1.prototype.abort = function() {
            if (true) {
              if (!displayedWarning) {
                displayedWarning = true;
                console.info("This platform does not implement AbortController. \nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.");
              }
            }
          };
          return class_1;
        }()
      );
      function actionCreator(arg) {
        return function(dispatch, getState, extra) {
          var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
          var abortController = new AC();
          var abortReason;
          var started = false;
          function abort(reason) {
            abortReason = reason;
            abortController.abort();
          }
          var promise2 = function() {
            return __async2(this, null, function() {
              var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    _c.trys.push([0, 4, , 5]);
                    conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, { getState, extra });
                    if (!isThenable(conditionResult))
                      return [3, 2];
                    return [4, conditionResult];
                  case 1:
                    conditionResult = _c.sent();
                    _c.label = 2;
                  case 2:
                    if (conditionResult === false || abortController.signal.aborted) {
                      throw {
                        name: "ConditionError",
                        message: "Aborted due to condition callback returning false."
                      };
                    }
                    started = true;
                    abortedPromise = new Promise(function(_3, reject2) {
                      return abortController.signal.addEventListener("abort", function() {
                        return reject2({
                          name: "AbortError",
                          message: abortReason || "Aborted"
                        });
                      });
                    });
                    dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, { requestId, arg }, { getState, extra })));
                    return [4, Promise.race([
                      abortedPromise,
                      Promise.resolve(payloadCreator(arg, {
                        dispatch,
                        getState,
                        extra,
                        requestId,
                        signal: abortController.signal,
                        abort,
                        rejectWithValue: function(value, meta) {
                          return new RejectWithValue(value, meta);
                        },
                        fulfillWithValue: function(value, meta) {
                          return new FulfillWithMeta(value, meta);
                        }
                      })).then(function(result) {
                        if (result instanceof RejectWithValue) {
                          throw result;
                        }
                        if (result instanceof FulfillWithMeta) {
                          return fulfilled(result.payload, requestId, arg, result.meta);
                        }
                        return fulfilled(result, requestId, arg);
                      })
                    ])];
                  case 3:
                    finalAction = _c.sent();
                    return [3, 5];
                  case 4:
                    err_1 = _c.sent();
                    finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                    return [3, 5];
                  case 5:
                    skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                    if (!skipDispatch) {
                      dispatch(finalAction);
                    }
                    return [2, finalAction];
                }
              });
            });
          }();
          return Object.assign(promise2, {
            abort,
            requestId,
            arg,
            unwrap: function() {
              return promise2.then(unwrapResult);
            }
          });
        };
      }
      return Object.assign(actionCreator, {
        pending,
        rejected,
        fulfilled,
        typePrefix
      });
    }
    createAsyncThunk2.withTypes = function() {
      return createAsyncThunk2;
    };
    return createAsyncThunk2;
  }();
  function unwrapResult(action) {
    if (action.meta && action.meta.rejectedWithValue) {
      throw action.payload;
    }
    if (action.error) {
      throw action.error;
    }
    return action.payload;
  }
  function isThenable(value) {
    return value !== null && typeof value === "object" && typeof value.then === "function";
  }
  var task = "task";
  var listener = "listener";
  var completed = "completed";
  var cancelled = "cancelled";
  var taskCancelled = "task-" + cancelled;
  var taskCompleted = "task-" + completed;
  var listenerCancelled = listener + "-" + cancelled;
  var listenerCompleted = listener + "-" + completed;
  var TaskAbortError = (
    /** @class */
    function() {
      function TaskAbortError2(code) {
        this.code = code;
        this.name = "TaskAbortError";
        this.message = task + " " + cancelled + " (reason: " + code + ")";
      }
      return TaskAbortError2;
    }()
  );
  var alm = "listenerMiddleware";
  var addListener = createAction(alm + "/add");
  var clearAllListeners = createAction(alm + "/removeAll");
  var removeListener = createAction(alm + "/remove");
  var promise;
  var queueMicrotaskShim = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function(cb) {
    return (promise || (promise = Promise.resolve())).then(cb).catch(function(err) {
      return setTimeout(function() {
        throw err;
      }, 0);
    });
  };
  var createQueueWithTimer = function(timeout) {
    return function(notify) {
      setTimeout(notify, timeout);
    };
  };
  var rAF = typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);
  F2();

  // ../howdju-common/lib/index.ts
  var lib_exports = {};
  __export(lib_exports, {
    AccountSettings: () => AccountSettings,
    AccountSettingsRef: () => AccountSettingsRef,
    ActionSubjectTypes: () => ActionSubjectTypes,
    ActionTargetTypes: () => ActionTargetTypes,
    ActionTypes: () => ActionTypes2,
    Appearance: () => Appearance,
    AudSegment: () => AudSegment,
    ContentReport: () => ContentReport,
    ContentReportRef: () => ContentReportRef,
    ContentReportTypes: () => ContentReportTypes,
    CreateAccountSettings: () => CreateAccountSettings,
    CreateAppearance: () => CreateAppearance,
    CreateAppearanceInput: () => CreateAppearanceInput,
    CreateAudSegment: () => CreateAudSegment,
    CreateAudSegmentInput: () => CreateAudSegmentInput,
    CreateContentReport: () => CreateContentReport,
    CreateContentReportInput: () => CreateContentReportInput,
    CreateCounterJustification: () => CreateCounterJustification,
    CreateCounterJustificationInput: () => CreateCounterJustificationInput,
    CreateDomAnchor: () => CreateDomAnchor,
    CreateJustification: () => CreateJustification,
    CreateJustificationInput: () => CreateJustificationInput,
    CreateJustificationVote: () => CreateJustificationVote,
    CreateJustifiedSentence: () => CreateJustifiedSentence,
    CreateJustifiedSentenceInput: () => CreateJustifiedSentenceInput,
    CreateMediaExcerpt: () => CreateMediaExcerpt,
    CreateMediaExcerptCitation: () => CreateMediaExcerptCitation,
    CreateMediaExcerptCitationInput: () => CreateMediaExcerptCitationInput,
    CreateMediaExcerptInput: () => CreateMediaExcerptInput,
    CreateMediaExcerptSpeaker: () => CreateMediaExcerptSpeaker,
    CreateMediaExcerptSpeakerInput: () => CreateMediaExcerptSpeakerInput,
    CreateModel: () => CreateModel,
    CreatePersorg: () => CreatePersorg,
    CreatePersorgInput: () => CreatePersorgInput,
    CreatePicRegion: () => CreatePicRegion,
    CreatePicRegionInput: () => CreatePicRegionInput,
    CreateProposition: () => CreateProposition,
    CreatePropositionCompound: () => CreatePropositionCompound,
    CreatePropositionCompoundAtom: () => CreatePropositionCompoundAtom,
    CreatePropositionCompoundAtomInput: () => CreatePropositionCompoundAtomInput,
    CreatePropositionCompoundInput: () => CreatePropositionCompoundInput,
    CreatePropositionInput: () => CreatePropositionInput,
    CreatePropositionTagVote: () => CreatePropositionTagVote,
    CreatePropositionTagVoteInput: () => CreatePropositionTagVoteInput,
    CreateRegistrationConfirmation: () => CreateRegistrationConfirmation,
    CreateRegistrationConfirmationInput: () => CreateRegistrationConfirmationInput,
    CreateRegistrationRequest: () => CreateRegistrationRequest,
    CreateRegistrationRequestInput: () => CreateRegistrationRequestInput,
    CreateSource: () => CreateSource,
    CreateSourceExcerpt: () => CreateSourceExcerpt,
    CreateSourceExcerptInput: () => CreateSourceExcerptInput,
    CreateSourceInput: () => CreateSourceInput,
    CreateStatement: () => CreateStatement,
    CreateStatementInput: () => CreateStatementInput,
    CreateTag: () => CreateTag,
    CreateTagInput: () => CreateTagInput,
    CreateTagVote: () => CreateTagVote,
    CreateUrl: () => CreateUrl,
    CreateUrlInput: () => CreateUrlInput,
    CreateUrlLocator: () => CreateUrlLocator,
    CreateUrlLocatorInput: () => CreateUrlLocatorInput,
    CreateUrlLocatorsInput: () => CreateUrlLocatorsInput,
    CreateUser: () => CreateUser,
    CreateVidSegment: () => CreateVidSegment,
    CreateVidSegmentInput: () => CreateVidSegmentInput,
    CreateWrit: () => CreateWrit,
    CreateWritInput: () => CreateWritInput,
    CreateWritQuote: () => CreateWritQuote,
    CreateWritQuoteInput: () => CreateWritQuoteInput,
    Credentials: () => Credentials,
    DeleteJustificationVote: () => DeleteJustificationVote,
    DeleteMediaExcerptCitation: () => DeleteMediaExcerptCitation,
    DomAnchor: () => DomAnchor,
    EmptyBespokeValidationErrors: () => EmptyBespokeValidationErrors,
    Entity: () => Entity,
    EntityErrorCodes: () => EntityErrorCodes,
    EntityTypes: () => EntityTypes,
    ExternalJustificationSearchFilters: () => ExternalJustificationSearchFilters,
    JobHistoryStatuses: () => JobHistoryStatuses,
    Justification: () => Justification,
    JustificationBasisCompoundAtomTypes: () => JustificationBasisCompoundAtomTypes,
    JustificationBasisSourceTypes: () => JustificationBasisSourceTypes,
    JustificationBasisType: () => JustificationBasisType,
    JustificationBasisTypes: () => JustificationBasisTypes,
    JustificationPolarities: () => JustificationPolarities,
    JustificationPolarity: () => JustificationPolarity,
    JustificationRef: () => JustificationRef,
    JustificationRootPolarities: () => JustificationRootPolarities,
    JustificationRootPolarity: () => JustificationRootPolarity,
    JustificationRootTargetType: () => JustificationRootTargetType,
    JustificationRootTargetTypes: () => JustificationRootTargetTypes,
    JustificationScoreTypes: () => JustificationScoreTypes,
    JustificationTargetType: () => JustificationTargetType2,
    JustificationTargetTypes: () => JustificationTargetTypes,
    JustificationVote: () => JustificationVote,
    JustificationVotePolarities: () => JustificationVotePolarities,
    JustificationVoteRef: () => JustificationVoteRef,
    MAX_ACCEPTABLE_ERRORS: () => MAX_ACCEPTABLE_ERRORS,
    MediaExcerpt: () => MediaExcerpt,
    MediaExcerptCitation: () => MediaExcerptCitation,
    MediaExcerptRef: () => MediaExcerptRef,
    MediaExcerptSearchFilterKeys: () => MediaExcerptSearchFilterKeys,
    MediaExcerptSpeaker: () => MediaExcerptSpeaker,
    MomentConstructor: () => MomentConstructor,
    Password: () => Password,
    PasswordResetRequest: () => PasswordResetRequest,
    PasswordResetRequestRef: () => PasswordResetRequestRef,
    Persorg: () => Persorg,
    PersorgRef: () => PersorgRef,
    PicRegion: () => PicRegion,
    Proposition: () => Proposition,
    PropositionCompound: () => PropositionCompound,
    PropositionCompoundAtom: () => PropositionCompoundAtom,
    PropositionCompoundAtomTypes: () => PropositionCompoundAtomTypes,
    PropositionCompoundRef: () => PropositionCompoundRef,
    PropositionRef: () => PropositionRef,
    PropositionTagScoreTypes: () => PropositionTagScoreTypes,
    PropositionTagVote: () => PropositionTagVote,
    PropositionTagVotePolarities: () => PropositionTagVotePolarities,
    PropositionTagVoteRef: () => PropositionTagVoteRef,
    RegistrationConfirmation: () => RegistrationConfirmation,
    RegistrationRequest: () => RegistrationRequest,
    RegistrationRequestRef: () => RegistrationRequestRef,
    RelationPolarity: () => RelationPolarity2,
    SentenceTypes: () => SentenceTypes,
    SortDirections: () => SortDirections,
    Source: () => Source,
    SourceExcerpt: () => SourceExcerpt,
    SourceExcerptRef: () => SourceExcerptRef,
    SourceExcerptTypes: () => SourceExcerptTypes,
    SourceRef: () => SourceRef,
    Statement: () => Statement,
    StatementRef: () => StatementRef,
    Tag: () => Tag,
    TagRef: () => TagRef,
    TagVote: () => TagVote,
    TagVotePolarities: () => TagVotePolarities,
    TagVoteRef: () => TagVoteRef,
    TopicMessage: () => TopicMessage,
    UpdateAccountSettings: () => UpdateAccountSettings,
    UpdateMediaExcerpt: () => UpdateMediaExcerpt,
    UpdateMediaExcerptInput: () => UpdateMediaExcerptInput,
    UpdatePersorg: () => UpdatePersorg,
    UpdatePersorgInput: () => UpdatePersorgInput,
    UpdatePicRegion: () => UpdatePicRegion,
    UpdatePicRegionInput: () => UpdatePicRegionInput,
    UpdateProposition: () => UpdateProposition,
    UpdatePropositionCompound: () => UpdatePropositionCompound,
    UpdatePropositionCompoundAtom: () => UpdatePropositionCompoundAtom,
    UpdatePropositionCompoundAtomInput: () => UpdatePropositionCompoundAtomInput,
    UpdatePropositionCompoundInput: () => UpdatePropositionCompoundInput,
    UpdatePropositionInput: () => UpdatePropositionInput,
    UpdateSource: () => UpdateSource,
    UpdateSourceInput: () => UpdateSourceInput,
    UpdateVidSegment: () => UpdateVidSegment,
    UpdateVidSegmentInput: () => UpdateVidSegmentInput,
    UpdateWrit: () => UpdateWrit,
    UpdateWritInput: () => UpdateWritInput,
    UpdateWritQuote: () => UpdateWritQuote,
    UpdateWritQuoteInput: () => UpdateWritQuoteInput,
    Url: () => Url,
    UrlLocator: () => UrlLocator,
    UrlLocatorRef: () => UrlLocatorRef,
    UrlRef: () => UrlRef,
    UrlTarget: () => UrlTarget,
    User: () => User,
    UserBlurb: () => UserBlurb,
    UserExternalIds: () => UserExternalIds,
    UserRef: () => UserRef,
    VidSegment: () => VidSegment,
    Writ: () => Writ,
    WritQuote: () => WritQuote,
    WritQuoteRef: () => WritQuoteRef,
    WritRef: () => WritRef,
    apiErrorCodes: () => apiErrorCodes,
    approximateMatch: () => approximateMatch,
    areAdjacentConnectingEntities: () => areAdjacentConnectingEntities,
    areValidTargetAndConnectingEntity: () => areValidTargetAndConnectingEntity,
    arrayToObject: () => arrayToObject,
    assert: () => assert,
    authorizationErrorCodes: () => authorizationErrorCodes,
    brandedParse: () => brandedParse,
    camelCaseKeysDeep: () => camelCaseKeysDeep,
    cleanTextFragmentParameter: () => cleanTextFragmentParameter,
    cleanWhitespace: () => cleanWhitespace,
    commonErrorTypes: () => commonErrorTypes,
    contextTrailItemPolarity: () => contextTrailItemPolarity,
    contextTrailPolarityByShortcut: () => contextTrailPolarityByShortcut,
    contextTrailShortcutByPolarity: () => contextTrailShortcutByPolarity,
    contextTrailShortcutByType: () => contextTrailShortcutByType,
    contextTrailTypeByShortcut: () => contextTrailTypeByShortcut,
    decircularizeJustification: () => decircularizeJustification,
    decircularizeProposition: () => decircularizeProposition,
    decircularizeSourceExcerpt: () => decircularizeSourceExcerpt,
    decodeQueryStringObject: () => decodeQueryStringObject,
    decodeSorts: () => decodeSorts,
    definitionsSchema: () => definitionsSchema,
    demuxCreateJustificationInput: () => demuxCreateJustificationInput,
    demuxJustificationBasisSourceExcerptInput: () => demuxJustificationBasisSourceExcerptInput,
    differenceDuration: () => differenceDuration,
    doTargetSameRoot: () => doTargetSameRoot,
    emptyValidationResult: () => emptyValidationResult,
    encodeQueryStringObject: () => encodeQueryStringObject,
    encodeSorts: () => encodeSorts,
    entityConflictCodes: () => entityConflictCodes,
    errorFormatToString: () => errorFormatToString,
    extractDate: () => extractDate,
    extractDomain: () => extractDomain,
    extractQuotationFromTextFragment: () => extractQuotationFromTextFragment,
    filterDefined: () => filterDefined,
    findTextInDoc: () => findTextInDoc,
    formatDuration: () => formatDuration,
    formatZodError: () => formatZodError,
    fromJson: () => fromJson,
    getConnectingEntitySourceInfo: () => getConnectingEntitySourceInfo,
    getRangeOfTextInDoc: () => getRangeOfTextInDoc,
    getTextWithin: () => getTextWithin,
    hasQuote: () => hasQuote,
    httpMethods: () => httpMethods,
    httpStatusCodes: () => httpStatusCodes,
    idEqual: () => idEqual,
    inferAnchoredBibliographicInfo: () => inferAnchoredBibliographicInfo,
    inferBibliographicInfo: () => inferBibliographicInfo,
    insertAllAt: () => insertAllAt,
    insertAt: () => insertAt,
    isBareRef: () => isBareRef,
    isCustomError: () => isCustomError,
    isDefined: () => isDefined,
    isDomain: () => isDomain,
    isFalsey: () => isFalsey,
    isJustificationBasisSourceType: () => isJustificationBasisSourceType,
    isMediaExcerptBased: () => isMediaExcerptBased,
    isNegative: () => isNegative,
    isOnlyRef: () => isOnlyRef,
    isPlainObject: () => isPlainObject,
    isPositive: () => isPositive,
    isPropositionCompoundBased: () => isPropositionCompoundBased,
    isRef: () => isRef,
    isRootJustification: () => isRootJustification,
    isRootNegative: () => isRootNegative,
    isRootPositive: () => isRootPositive,
    isTruthy: () => isTruthy,
    isUrl: () => isUrl,
    isWritQuoteBased: () => isWritQuoteBased,
    jsonPointerToObjectPath: () => jsonPointerToObjectPath,
    keysTo: () => keysTo,
    logger: () => logger,
    makeAccountSettings: () => makeAccountSettings,
    makeAjv: () => makeAjv,
    makeCreateCounterJustificationInput: () => makeCreateCounterJustificationInput,
    makeCreateJustificationBasisCompoundInput: () => makeCreateJustificationBasisCompoundInput,
    makeCreateJustificationInput: () => makeCreateJustificationInput,
    makeCreateJustificationInputTargetingRoot: () => makeCreateJustificationInputTargetingRoot,
    makeCreateJustifiedSentenceInput: () => makeCreateJustifiedSentenceInput,
    makeCreateMediaExcerptInput: () => makeCreateMediaExcerptInput,
    makeCreateMediaExcerptSpeakerInput: () => makeCreateMediaExcerptSpeakerInput,
    makeCreatePersorg: () => makeCreatePersorg,
    makeCreatePicRegionInput: () => makeCreatePicRegionInput,
    makeCreatePropositionCompoundAtomInput: () => makeCreatePropositionCompoundAtomInput,
    makeCreatePropositionCompoundInput: () => makeCreatePropositionCompoundInput,
    makeCreatePropositionCompoundInputFromProposition: () => makeCreatePropositionCompoundInputFromProposition,
    makeCreatePropositionInput: () => makeCreatePropositionInput,
    makeCreateRegistrationConfirmation: () => makeCreateRegistrationConfirmation,
    makeCreateRegistrationConfirmationInput: () => makeCreateRegistrationConfirmationInput,
    makeCreateRegistrationRequest: () => makeCreateRegistrationRequest,
    makeCreateRegistrationRequestInput: () => makeCreateRegistrationRequestInput,
    makeCreateSourceExcerptInput: () => makeCreateSourceExcerptInput,
    makeCreateStatementInput: () => makeCreateStatementInput,
    makeCreateUrl: () => makeCreateUrl,
    makeCreateUrlLocatorInput: () => makeCreateUrlLocatorInput,
    makeCreateVidSegmentInput: () => makeCreateVidSegmentInput,
    makeCreateWritQuoteInput: () => makeCreateWritQuoteInput,
    makeCredentials: () => makeCredentials,
    makeDomAnchor: () => makeDomAnchor,
    makeModelErrors: () => makeModelErrors,
    makeNewAccountSettings: () => makeNewAccountSettings,
    makePicRegion: () => makePicRegion,
    makePropositionTagVote: () => makePropositionTagVote,
    makeStandaloneCode: () => makeStandaloneCode,
    makeStandaloneValidate: () => makeStandaloneValidate,
    makeTag: () => makeTag,
    makeUrl: () => makeUrl,
    makeUrlInput: () => makeUrlInput,
    makeValidate: () => makeValidate,
    makeValidateRawErrors: () => makeValidateRawErrors,
    makeVidSegment: () => makeVidSegment,
    makeWritInput: () => makeWritInput,
    makeZodCustomIssuesError: () => makeZodCustomIssuesError,
    mapKeysDeep: () => mapKeysDeep,
    mapValuesDeep: () => mapValuesDeep,
    mergeCopy: () => mergeCopy,
    minDate: () => minDate,
    modelErrorCodes: () => modelErrorCodes,
    momentAdd: () => momentAdd,
    momentObject: () => momentObject,
    momentSubtract: () => momentSubtract,
    muxCreateJustificationErrors: () => muxCreateJustificationErrors,
    muxSourceExcerpt: () => muxSourceExcerpt,
    negateJustificationVotePolarity: () => negateJustificationVotePolarity,
    negateRootPolarity: () => negateRootPolarity,
    newBespokeValidationErrors: () => newBespokeValidationErrors,
    newCustomError: () => newCustomError,
    newExhaustedEnumError: () => newExhaustedEnumError,
    newImpossibleError: () => newImpossibleError,
    newProgrammingError: () => newProgrammingError,
    newUnimplementedError: () => newUnimplementedError,
    nextContextTrailItem: () => nextContextTrailItem,
    nodeIsAfter: () => nodeIsAfter,
    nodeIsAfterOrSame: () => nodeIsAfterOrSame,
    nodeIsBefore: () => nodeIsBefore,
    nodePositionCompare: () => nodePositionCompare,
    normalizeQuotation: () => normalizeQuotation,
    normalizeText: () => normalizeText,
    normalizeUrl: () => normalizeUrl2,
    omitDeep: () => omitDeep,
    onlyFieldError: () => onlyFieldError,
    parseContextTrail: () => parseContextTrail,
    pushAll: () => pushAll,
    removeAt: () => removeAt,
    removeQueryParamsAndFragment: () => removeQueryParamsAndFragment,
    removeZodErrorDupes: () => removeZodErrorDupes,
    requireArgs: () => requireArgs,
    schemaIds: () => schemaIds,
    schemaSettings: () => schemaSettings,
    schemas: () => schemas,
    schemasById: () => schemasById,
    serializeContextTrail: () => serializeContextTrail,
    sleep: () => sleep,
    tagEqual: () => tagEqual,
    timestampFormatString: () => timestampFormatString,
    toEntries: () => toEntries,
    toJson: () => toJson,
    toPlainTextContent: () => toPlainTextContent,
    toSingleLine: () => toSingleLine,
    toSlug: () => toSlug,
    toUrlWithFragmentFromAnchors: () => toUrlWithFragmentFromAnchors,
    toUrlWithFragmentFromQuotation: () => toUrlWithFragmentFromQuotation,
    translateAjvToZodFormattedError: () => translateAjvToZodFormattedError,
    urlString: () => urlString,
    userActionsConflictCodes: () => userActionsConflictCodes,
    utcNow: () => utcNow,
    utcNowIsAfter: () => utcNowIsAfter,
    utcTimestamp: () => utcTimestamp,
    walkRangeNodes: () => walkRangeNodes,
    zeroDate: () => zeroDate,
    zodIssueFormatter: () => zodIssueFormatter
  });

  // ../howdju-common/lib/anchors.ts
  function makeDomAnchor({ exact, prefix, suffix }, { start, end }) {
    return {
      exactText: exact,
      prefixText: prefix,
      suffixText: suffix,
      startOffset: start,
      endOffset: end
    };
  }

  // ../node_modules/approx-string-match/build/src/index.js
  function reverse(s3) {
    return s3.split("").reverse().join("");
  }
  function findMatchStarts(text, pattern, matches) {
    const patRev = reverse(pattern);
    return matches.map((m3) => {
      const minStart = Math.max(0, m3.end - pattern.length - m3.errors);
      const textRev = reverse(text.slice(minStart, m3.end));
      const start = findMatchEnds(textRev, patRev, m3.errors).reduce((min, rm) => {
        if (m3.end - rm.end < min) {
          return m3.end - rm.end;
        }
        return min;
      }, m3.end);
      return {
        start,
        end: m3.end,
        errors: m3.errors
      };
    });
  }
  function oneIfNotZero(n3) {
    return (n3 | -n3) >> 31 & 1;
  }
  function advanceBlock(ctx, peq, b3, hIn) {
    let pV = ctx.P[b3];
    let mV = ctx.M[b3];
    const hInIsNegative = hIn >>> 31;
    const eq = peq[b3] | hInIsNegative;
    const xV = eq | mV;
    const xH = (eq & pV) + pV ^ pV | eq;
    let pH = mV | ~(xH | pV);
    let mH = pV & xH;
    const hOut = oneIfNotZero(pH & ctx.lastRowMask[b3]) - oneIfNotZero(mH & ctx.lastRowMask[b3]);
    pH <<= 1;
    mH <<= 1;
    mH |= hInIsNegative;
    pH |= oneIfNotZero(hIn) - hInIsNegative;
    pV = mH | ~(xV | pH);
    mV = pH & xV;
    ctx.P[b3] = pV;
    ctx.M[b3] = mV;
    return hOut;
  }
  function findMatchEnds(text, pattern, maxErrors) {
    if (pattern.length === 0) {
      return [];
    }
    maxErrors = Math.min(maxErrors, pattern.length);
    const matches = [];
    const w3 = 32;
    const bMax = Math.ceil(pattern.length / w3) - 1;
    const ctx = {
      P: new Uint32Array(bMax + 1),
      M: new Uint32Array(bMax + 1),
      lastRowMask: new Uint32Array(bMax + 1)
    };
    ctx.lastRowMask.fill(1 << 31);
    ctx.lastRowMask[bMax] = 1 << (pattern.length - 1) % w3;
    const emptyPeq = new Uint32Array(bMax + 1);
    const peq = /* @__PURE__ */ new Map();
    const asciiPeq = [];
    for (let i3 = 0; i3 < 256; i3++) {
      asciiPeq.push(emptyPeq);
    }
    for (let c3 = 0; c3 < pattern.length; c3 += 1) {
      const val = pattern.charCodeAt(c3);
      if (peq.has(val)) {
        continue;
      }
      const charPeq = new Uint32Array(bMax + 1);
      peq.set(val, charPeq);
      if (val < asciiPeq.length) {
        asciiPeq[val] = charPeq;
      }
      for (let b3 = 0; b3 <= bMax; b3 += 1) {
        charPeq[b3] = 0;
        for (let r3 = 0; r3 < w3; r3 += 1) {
          const idx = b3 * w3 + r3;
          if (idx >= pattern.length) {
            continue;
          }
          const match = pattern.charCodeAt(idx) === val;
          if (match) {
            charPeq[b3] |= 1 << r3;
          }
        }
      }
    }
    let y3 = Math.max(0, Math.ceil(maxErrors / w3) - 1);
    const score = new Uint32Array(bMax + 1);
    for (let b3 = 0; b3 <= y3; b3 += 1) {
      score[b3] = (b3 + 1) * w3;
    }
    score[bMax] = pattern.length;
    for (let b3 = 0; b3 <= y3; b3 += 1) {
      ctx.P[b3] = ~0;
      ctx.M[b3] = 0;
    }
    for (let j3 = 0; j3 < text.length; j3 += 1) {
      const charCode = text.charCodeAt(j3);
      let charPeq;
      if (charCode < asciiPeq.length) {
        charPeq = asciiPeq[charCode];
      } else {
        charPeq = peq.get(charCode);
        if (typeof charPeq === "undefined") {
          charPeq = emptyPeq;
        }
      }
      let carry = 0;
      for (let b3 = 0; b3 <= y3; b3 += 1) {
        carry = advanceBlock(ctx, charPeq, b3, carry);
        score[b3] += carry;
      }
      if (score[y3] - carry <= maxErrors && y3 < bMax && (charPeq[y3 + 1] & 1 || carry < 0)) {
        y3 += 1;
        ctx.P[y3] = ~0;
        ctx.M[y3] = 0;
        let maxBlockScore;
        if (y3 === bMax) {
          const remainder = pattern.length % w3;
          maxBlockScore = remainder === 0 ? w3 : remainder;
        } else {
          maxBlockScore = w3;
        }
        score[y3] = score[y3 - 1] + maxBlockScore - carry + advanceBlock(ctx, charPeq, y3, carry);
      } else {
        while (y3 > 0 && score[y3] >= maxErrors + w3) {
          y3 -= 1;
        }
      }
      if (y3 === bMax && score[y3] <= maxErrors) {
        if (score[y3] < maxErrors) {
          matches.splice(0, matches.length);
        }
        matches.push({
          start: -1,
          end: j3 + 1,
          errors: score[y3]
        });
        maxErrors = score[y3];
      }
    }
    return matches;
  }
  function search(text, pattern, maxErrors) {
    const matches = findMatchEnds(text, pattern, maxErrors);
    return findMatchStarts(text, pattern, matches);
  }

  // ../howdju-common/lib/approximateStringMatch.ts
  var MAX_ACCEPTABLE_ERRORS = 50;
  function approximateMatch(document2, query) {
    return search(document2, query, MAX_ACCEPTABLE_ERRORS);
  }

  // ../howdju-common/lib/arguments.js
  var import_forEach2 = __toESM(require_forEach());
  init_commonErrors();
  init_general();
  function requireArgs(requiredArgs) {
    const missing = [];
    (0, import_forEach2.default)(requiredArgs, (value, name) => {
      if (!isDefined(value)) {
        missing.push(name);
      }
    });
    if (missing.length > 0) {
      throw newProgrammingError(
        `Required arguments are undefined: ${missing.join(", ")}`
      );
    }
    return true;
  }

  // ../howdju-common/lib/apiModels.ts
  var ExternalJustificationSearchFilters = [
    "writQuoteId",
    "writId",
    // Justifications based on this PropositionCompound
    "propositionCompoundId",
    "mediaExcerptId",
    "sourceExcerptParaphraseId",
    // Justifications based on this proposition in a PropositionCompound
    "propositionId",
    "url"
  ];
  var MediaExcerptSearchFilterKeys = [
    "creatorUserId",
    "speakerPersorgId",
    "sourceId",
    "domain",
    /**
     * Returns MediaExcerpts having URLs matching url.
     *
     * Matching means that the two are equal after removing the query parameters and fragment and
     * ignoring the trailing slash. Both the `url` and `canonical_url` are considered.
     */
    "url"
  ];

  // ../howdju-common/lib/codes/apiErrorCodes.ts
  var apiErrorCodes = {
    /** The request lacks authentication credentials */
    UNAUTHENTICATED: "UNAUTHENTICATED",
    /** The data submitted was invalid */
    VALIDATION_ERROR: "VALIDATION_ERROR",
    /** The client sent an invalid request. The response should explain what was invalid. */
    INVALID_REQUEST: "INVALID_REQUEST",
    AUTHENTICATION_ERROR: "AUTHENTICATION_ERROR",
    /** The user tried to login with invalid login credentials */
    INVALID_LOGIN_CREDENTIALS: "INVALID_LOGIN_CREDENTIALS",
    /** The principle authenticated by the request lacks authority to perform the action */
    AUTHORIZATION_ERROR: "AUTHORIZATION_ERROR",
    /** The user account is inactive.  Should only respond with this if the correct password was provided */
    USER_IS_INACTIVE_ERROR: "USER_IS_INACTIVE_ERROR",
    /** The request would conflict with one or more other entities
     * (e.g. a user tries to update one proposition's text to a value equal to another proposition's text)
     */
    ENTITY_CONFLICT: "ENTITY_CONFLICT",
    /** The request would conflict with one or more other users' actions
     * (e.g. a user tries to edit a proposition after other users have added justifications to it)
     */
    USER_ACTIONS_CONFLICT: "USER_ACTIONS_CONFLICT",
    /** An entity whose existence was entailed by the request was not found.  The API may return information
     * about the type and identifier of the missing entity, but may not for privacy or security reasons
     */
    ENTITY_NOT_FOUND: "ENTITY_NOT_FOUND",
    /** The requested resource expired, or a dependent resource expired making fulfilling the request impossible */
    EXPIRED: "EXPIRED",
    /** The requested resource was already used */
    CONSUMED: "CONSUMED",
    /** The requested route was not found */
    ROUTE_NOT_FOUND: "ROUTE_NOT_FOUND",
    UNEXPECTED_ERROR: "UNEXPECTED_ERROR",
    /** A downstream service failed. */
    DOWNSTREAM_SERVICE_ERROR: "DOWNSTREAM_SERVICE_ERROR"
  };

  // ../howdju-common/lib/codes/authorizationErrorCodes.ts
  var authorizationErrorCodes = {
    CANNOT_MODIFY_OTHER_USERS_ENTITIES: "CANNOT_MODIFY_OTHER_USERS_ENTITIES"
  };

  // ../howdju-common/lib/codes/entityConflictCodes.ts
  var entityConflictCodes = {
    ANOTHER_PROPOSITION_HAS_EQUIVALENT_TEXT: "ANOTHER_PROPOSITION_HAS_EQUIVALENT_TEXT",
    ANOTHER_WRIT_HAS_EQUIVALENT_TITLE: "ANOTHER_WRIT_HAS_EQUIVALENT_TITLE",
    ANOTHER_WRIT_QUOTE_HAS_EQUIVALENT_QUOTE_TEXT: "ANOTHER_WRIT_QUOTE_HAS_EQUIVALENT_QUOTE_TEXT",
    ALREADY_EXISTS: "ALREADY_EXISTS"
  };

  // ../howdju-common/lib/codes/entityErrorCodes.ts
  var EntityErrorCodes = {
    /** Another user has registered this username */
    USERNAME_TAKEN: "USERNAME_TAKEN",
    /** Another user has registered this email */
    EMAIL_TAKEN: "EMAIL_TAKEN"
  };

  // ../howdju-common/lib/codes/modelErrorCodes.ts
  var modelErrorCodes = {
    MUST_BE_NONEMPTY: "MUST_BE_NONEMPTY",
    INVALID_VALUE: "INVALID_VALUE",
    IS_REQUIRED: "IS_REQUIRED",
    IF_PRESENT_MUST_BE_ARRAY: "IF_PRESENT_MUST_BE_ARRAY",
    IF_PRESENT_MUST_BE_NONEMPTY: "IF_PRESENT_MUST_BE_NONEMPTY",
    INVALID_URL: "INVALID_URL",
    PROPOSITION_JUSTIFICATION_MUST_HAVE_PROPOSITION_TARGET_TYPE: "PROPOSITION_JUSTIFICATION_MUST_HAVE_PROPOSITION_TARGET_TYPE",
    JUSTIFICATION_ROOT_PROPOSITION_ID_AND_TARGET_PROPOSITION_ID_MUST_BE_EQUAL: "JUSTIFICATION_ROOT_PROPOSITION_ID_AND_TARGET_PROPOSITION_ID_MUST_BE_EQUAL"
  };

  // ../howdju-common/lib/codes/userActionsConflictCodes.ts
  var userActionsConflictCodes = {
    OTHER_USERS_HAVE_ROOTED_JUSTIFICATIONS_IN_THIS_PROPOSITION: "OTHER_USERS_HAVE_ROOTED_JUSTIFICATIONS_IN_THIS_PROPOSITION",
    OTHER_USERS_HAVE_BASED_JUSTIFICATIONS_ON_THIS_PROPOSITION: "OTHER_USERS_HAVE_BASED_JUSTIFICATIONS_ON_THIS_PROPOSITION",
    OTHER_USERS_HAVE_BASED_JUSTIFICATIONS_ON_THIS_WRIT_QUOTE: "OTHER_USERS_HAVE_BASED_JUSTIFICATIONS_ON_THIS_WRIT_QUOTE",
    OTHER_USERS_HAVE_BASED_JUSTIFICATIONS_ON_THIS_WRIT: "OTHER_USERS_HAVE_BASED_JUSTIFICATIONS_ON_THIS_WRIT",
    OTHER_USERS_HAVE_VOTED_ON_JUSTIFICATIONS_ROOTED_IN_THIS_PROPOSITION: "OTHER_USERS_HAVE_VOTED_ON_JUSTIFICATIONS_ROOTED_IN_THIS_PROPOSITION",
    OTHER_USERS_HAVE_VOTED_ON_JUSTIFICATIONS_BASED_ON_THIS_WRIT_QUOTE: "OTHER_USERS_HAVE_VOTED_ON_JUSTIFICATIONS_BASED_ON_THIS_WRIT_QUOTE",
    OTHER_USERS_HAVE_VOTED_ON_JUSTIFICATIONS_BASED_ON_THIS_WRIT: "OTHER_USERS_HAVE_VOTED_ON_JUSTIFICATIONS_BASED_ON_THIS_WRIT",
    OTHER_USERS_HAVE_COUNTERED_JUSTIFICATIONS_BASED_ON_THIS_WRIT_QUOTE: "OTHER_USERS_HAVE_COUNTERED_JUSTIFICATIONS_BASED_ON_THIS_WRIT_QUOTE",
    OTHER_USERS_HAVE_COUNTERED_JUSTIFICATIONS_BASED_ON_THIS_WRIT: "OTHER_USERS_HAVE_COUNTERED_JUSTIFICATIONS_BASED_ON_THIS_WRIT"
  };

  // ../howdju-common/lib/index.ts
  init_commonErrors();
  __reExport(lib_exports, __toESM(require_commonPaths()));
  __reExport(lib_exports, __toESM(require_consts()));

  // ../howdju-common/lib/contextTrails.ts
  var import_lodash3 = __toESM(require_lodash());
  var contextTrailTypeByShortcut = {
    j: "JUSTIFICATION"
  };
  var contextTrailPolarityByShortcut = {
    p: "POSITIVE",
    n: "NEGATIVE",
    u: "NEUTRAL"
  };
  var contextTrailShortcutByPolarity = (0, import_lodash3.invert)(
    contextTrailPolarityByShortcut
  );
  var contextTrailShortcutByType = (0, import_lodash3.invert)(contextTrailTypeByShortcut);
  function serializeContextTrail(contextTrailItems) {
    const serializedItems = (0, import_lodash3.map)(
      contextTrailItems,
      (i3) => (0, import_lodash3.join)(
        [
          contextTrailShortcutByType[i3.connectingEntityType],
          i3.connectingEntityId,
          contextTrailShortcutByPolarity[i3.polarity]
        ],
        ","
      )
    );
    return (0, import_lodash3.join)(serializedItems, ";");
  }
  function parseContextTrail(serializedContextTrail) {
    const infoStrings = (0, import_lodash3.split)(serializedContextTrail, ";");
    const infos = [];
    const invalidInfos = [];
    for (const infoString of infoStrings) {
      const [typeShortcut, connectingEntityId, polarityShortcut] = (0, import_lodash3.split)(
        infoString,
        ","
      );
      if (!(typeShortcut in contextTrailTypeByShortcut)) {
        logger.error(
          `Invalid context trail type shortcut: ${typeShortcut} in ${serializedContextTrail}`
        );
        invalidInfos.push(infoString);
        continue;
      }
      if (!(polarityShortcut in contextTrailPolarityByShortcut)) {
        logger.error(
          `Invalid context trail polarity shortcut: ${polarityShortcut} in ${serializedContextTrail}`
        );
        invalidInfos.push(infoString);
        continue;
      }
      const connectingEntityType = contextTrailTypeByShortcut[typeShortcut];
      const polarity = contextTrailPolarityByShortcut[polarityShortcut];
      infos.push({
        connectingEntityType,
        connectingEntityId,
        polarity
      });
    }
    return { infos, invalidInfos, hasInvalidInfos: !!invalidInfos.length };
  }
  function areAdjacentConnectingEntities(prev, curr) {
    switch (curr.type) {
      case "JUSTIFICATION": {
        const type = curr.entity.target.type;
        const id = curr.entity.target.entity.id;
        return areValidTargetAndConnectingEntity({ type, id }, prev);
      }
    }
  }
  function areValidTargetAndConnectingEntity({ type, id }, prev) {
    switch (type) {
      case "JUSTIFICATION": {
        return prev.type === "JUSTIFICATION" && id === prev.entity.id;
      }
      case "PROPOSITION":
        switch (prev.type) {
          case "JUSTIFICATION":
            switch (prev.entity.basis.type) {
              case "PROPOSITION_COMPOUND":
                return (0, import_lodash3.some)(
                  prev.entity.basis.entity.atoms,
                  (a3) => a3.entity.id === id
                );
              case "WRIT_QUOTE":
              case "MEDIA_EXCERPT":
                return false;
            }
        }
      case "STATEMENT":
        return false;
    }
  }
  function getConnectingEntitySourceInfo(typedConnectingEntity) {
    switch (typedConnectingEntity.type) {
      case "JUSTIFICATION":
        return {
          id: typedConnectingEntity.entity.basis.entity.id,
          type: typedConnectingEntity.entity.basis.type
        };
    }
  }
  function nextContextTrailItem(connectingEntityType, connectingEntity, prevItemPolarity) {
    const polarity = contextTrailItemPolarity(
      connectingEntityType,
      connectingEntity,
      prevItemPolarity
    );
    return {
      connectingEntityType,
      connectingEntityId: connectingEntity.id,
      connectingEntity,
      polarity
    };
  }
  function contextTrailItemPolarity(connectingEntityType, connectingEntity, prevItemPolarity) {
    switch (connectingEntityType) {
      case "JUSTIFICATION": {
        switch (connectingEntity.target.type) {
          case "PROPOSITION":
          case "STATEMENT":
            return connectingEntity.polarity;
          case "JUSTIFICATION":
            return negateRelationPolarity(prevItemPolarity);
        }
      }
    }
  }
  function negateRelationPolarity(polarity) {
    switch (polarity) {
      case "POSITIVE":
        return "NEGATIVE";
      case "NEGATIVE":
        return "POSITIVE";
      case "NEUTRAL":
        return "NEUTRAL";
    }
  }

  // ../howdju-common/lib/domBibliographicInfo.ts
  var import_lodash4 = __toESM(require_lodash());
  var import_moment2 = __toESM(require_moment());
  var textQuote = __toESM(require_dom_anchor_text_quote());
  init_general();
  init_logger();
  function inferBibliographicInfo(doc) {
    const sourceDescription = getSourceDescription(doc);
    const authors = getAuthors(doc);
    return { sourceDescription, authors };
  }
  function getSourceDescription(doc) {
    for (const { test, transform } of sourceDescriptionFinders) {
      if (!test(doc)) {
        continue;
      }
      const sourceDescription = transform(doc);
      if (sourceDescription) {
        return sourceDescription;
      }
    }
    return inferDescriptionBasedOnTitle(doc);
  }
  var HYPHEN_TITLE_SEPARATOR = " - ";
  var BAR_TITLE_SEPARATOR = " | ";
  var LAST_RESORT_SOURCE_DESCRIPTION = "Untitled";
  function inferDescriptionBasedOnTitle(doc) {
    let separatorOffset;
    const lastHypen = doc.title.lastIndexOf(HYPHEN_TITLE_SEPARATOR);
    if (lastHypen !== -1) {
      separatorOffset = { separator: HYPHEN_TITLE_SEPARATOR, offset: lastHypen };
    }
    const lastVerticalBar = doc.title.lastIndexOf(" | ");
    if (lastVerticalBar !== -1) {
      separatorOffset = {
        separator: BAR_TITLE_SEPARATOR,
        offset: lastVerticalBar
      };
    }
    if (separatorOffset) {
      const { sourceTitle, sourcePublication } = separateTitleAndPublication(
        doc.title,
        separatorOffset
      );
      const date = extractDate(doc);
      const datePart = date ? ` (${date})` : "";
      return `\u201C${sourceTitle}\u201D ${sourcePublication}${datePart}`;
    }
    return doc.title || LAST_RESORT_SOURCE_DESCRIPTION;
  }
  function extractDate(doc) {
    var _a, _b;
    const publishedRaw = (_a = doc.querySelector('[class*="published" i]')) == null ? void 0 : _a.textContent;
    const publishedMoment = publishedRaw ? import_moment2.default.utc(publishedRaw) : void 0;
    if (publishedMoment && publishedMoment.isValid()) {
      return publishedMoment.format("YYYY-MM-DD");
    }
    const editedDatetimeMatch = (_b = doc.body.textContent) == null ? void 0 : _b.match(
      /This page was last edited on (\d{1,2} \w+ \d{4}), at (\d{2}:\d{2})\s\(UTC\)\./
    );
    if (editedDatetimeMatch) {
      const dateRaw = editedDatetimeMatch[1];
      const date = import_moment2.default.utc(dateRaw).format("YYYY-MM-DD");
      const time = editedDatetimeMatch[2];
      const editedMoment = import_moment2.default.utc(`${date}T${time}Z`);
      if (editedMoment.isValid()) {
        return editedMoment.format("YYYY-MM-DD HH:mm UTC");
      }
    }
    return void 0;
  }
  function separateTitleAndPublication(title, { separator, offset }) {
    const sourceTitle = title.slice(0, offset);
    const sourcePublication = title.slice(offset + separator.length);
    return { sourceTitle, sourcePublication };
  }
  function getAuthors(doc) {
    for (const { test, transform } of authorFinders) {
      if (!test(doc)) {
        continue;
      }
      const authors = transform(doc).filter(isDefined);
      if (authors && authors.length) {
        return authors;
      }
    }
    return void 0;
  }
  var sourceDescriptionFinders = [
    {
      // Google Scholar Indexing: https://www.google.com/intl/en/scholar/inclusion.html#indexing
      // https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1280342/
      test: (doc) => !!doc.querySelector('meta[name="citation_title"]'),
      transform: (doc) => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const journal = (_a = doc.querySelector('meta[name="citation_journal_title"]')) == null ? void 0 : _a.getAttribute("content");
        const title = (_b = doc.querySelector('meta[name="citation_title"]')) == null ? void 0 : _b.getAttribute("content");
        const rawPublicationDate = (_d = (_c = doc.querySelector('meta[name="citation_publication_date"]')) == null ? void 0 : _c.getAttribute("content")) == null ? void 0 : _d.replace("/", "-");
        const volume = (_e = doc.querySelector('meta[name="citation_volume"]')) == null ? void 0 : _e.getAttribute("content");
        const issue = (_f = doc.querySelector('meta[name="citation_issue"]')) == null ? void 0 : _f.getAttribute("content");
        const citationFirstpage = (_g = doc.querySelector('meta[name="citation_firstpage"]')) == null ? void 0 : _g.getAttribute("content");
        const doi = (_h = doc.querySelector('meta[name="citation_doi"]')) == null ? void 0 : _h.getAttribute("content");
        const issuePart = issue ? `,${issue}` : "";
        const volumePart = volume ? `vol. ${volume}${issuePart}` : "";
        const pagePart = citationFirstpage ? `: ${citationFirstpage}` : "";
        const publicationDate = (0, import_moment2.default)(rawPublicationDate).format("YYYY");
        const datePart = publicationDate ? ` (${publicationDate})` : "";
        const doiPart = doi ? `doi:${doi}` : "";
        const sourceDescription = `\u201C${title}\u201D ${journal} ${volumePart}${datePart}${pagePart}. ${doiPart}`;
        return sourceDescription.replace(/\s+/, " ").trim();
      }
    },
    {
      // NewsArticle JSON-LD: https://json-ld.org/, https://schema.org/NewsArticle
      // https://www.nytimes.com/live/2023/06/24/world/russia-ukraine-news
      test: (doc) => Array.from(
        doc.querySelectorAll('script[type="application/ld+json"]')
      ).some(
        (el) => {
          var _a, _b;
          return ((_b = JSON.parse((_a = el.textContent) != null ? _a : "")) == null ? void 0 : _b["@type"]) === "NewsArticle";
        }
      ),
      transform: (doc) => {
        var _a, _b, _c, _d;
        const lds = Array.from(
          doc.querySelectorAll('script[type="application/ld+json"]')
        ).map((el) => {
          var _a2;
          return JSON.parse((_a2 = el.textContent) != null ? _a2 : "null");
        }).filter((json) => !!json);
        const articleLd = lds.find((ld) => ld["@type"] === "NewsArticle");
        if (!articleLd) {
          return void 0;
        }
        const organizationLd = lds.find(
          (ld) => ld["@type"] === "NewsMediaOrganization"
        );
        const publisher = ((_a = articleLd.publisher) == null ? void 0 : _a.name) || (organizationLd == null ? void 0 : organizationLd.name);
        const title = articleLd.headline || ((_b = doc.querySelector('meta[property="og:title"]')) == null ? void 0 : _b.getAttribute("content")) || doc.title;
        const rawDate = articleLd.datePublished || ((_c = doc.querySelector('meta[property="article:published_time"]')) == null ? void 0 : _c.getAttribute("content")) || ((_d = doc.querySelector('meta[name="pdate"]')) == null ? void 0 : _d.getAttribute("content"));
        const datePublished = formatDate(rawDate);
        const publisherPart = publisher ? ` ${publisher}` : "";
        const datePart = datePublished ? ` (${datePublished})` : "";
        const sourceDescription = `\u201C${title}\u201D${publisherPart}${datePart}`;
        return sourceDescription.replace(/\s+/, " ").trim();
      }
    },
    {
      // Article JSON-LD: https://json-ld.org/, https://schema.org/Article
      // https://aeon.co/essays/what-crusaders-daggers-reveal-about-medieval-love-and-violence
      test: (doc) => (
        // Wikipedia's JSON-LD results in poor source descriptions:
        // `“American theoretical physicist (1918–1988)” Wikimedia Foundation, Inc. (2001-11-07)`
        !doc.title.match(/wikipedia/i) && Array.from(
          doc.querySelectorAll('script[type="application/ld+json"]')
        ).some((el) => {
          var _a, _b;
          return ((_b = JSON.parse((_a = el.textContent) != null ? _a : "")) == null ? void 0 : _b["@type"]) === "Article";
        })
      ),
      transform: (doc) => {
        var _a, _b, _c, _d;
        const lds = Array.from(
          doc.querySelectorAll('script[type="application/ld+json"]')
        ).map((el) => {
          var _a2;
          return JSON.parse((_a2 = el.textContent) != null ? _a2 : "null");
        }).filter((json) => !!json);
        const articleLd = lds.find((ld) => ld["@type"] === "Article");
        if (!articleLd) {
          return void 0;
        }
        const publisher = (_a = articleLd.publisher) == null ? void 0 : _a.name;
        let title = articleLd.headline || ((_b = doc.querySelector('meta[property="og:title"]')) == null ? void 0 : _b.getAttribute("content")) || doc.title;
        if (doc.title.match(/aeon/i)) {
          title = title.replace(/ \| Aeon Essays$/, "");
        }
        const rawDate = articleLd.datePublished || ((_c = doc.querySelector('meta[property="article:published_time"]')) == null ? void 0 : _c.getAttribute("content")) || ((_d = doc.querySelector('meta[name="pdate"]')) == null ? void 0 : _d.getAttribute("content"));
        const datePublished = formatDate(rawDate);
        const publisherPart = publisher ? ` ${publisher}` : "";
        const datePart = datePublished ? ` (${datePublished})` : "";
        const sourceDescription = `\u201C${title}\u201D${publisherPart}${datePart}`;
        return sourceDescription.replace(/\s+/, " ").trim();
      }
    },
    {
      // Open Graph Article: https://ogp.me/#type_article
      test: (doc) => !!doc.querySelector('meta[property="og:type"][content="article"]'),
      transform: (doc) => {
        var _a, _b, _c, _d;
        const publisher = (_a = doc.querySelector('meta[property="og:site_name"]')) == null ? void 0 : _a.getAttribute("content");
        const title = ((_b = doc.querySelector('meta[property="og:title"]')) == null ? void 0 : _b.getAttribute("content")) || doc.title;
        const rawDate = ((_c = doc.querySelector('meta[property="article:published_time"]')) == null ? void 0 : _c.getAttribute("content")) || ((_d = doc.querySelector('meta[name="pdate"]')) == null ? void 0 : _d.getAttribute("content"));
        const datePublished = rawDate && formatDate(rawDate);
        const publisherPart = publisher ? ` ${publisher}` : "";
        const datePart = datePublished ? ` (${datePublished})` : "";
        const sourceDescription = `\u201C${title}\u201D${publisherPart}${datePart}`;
        return sourceDescription.replace(/\s+/, " ").trim();
      }
    }
  ];
  function formatDate(rawDate) {
    const date = import_moment2.default.utc(rawDate);
    if (date.isValid()) {
      return date.format("YYYY-MM-DD");
    }
    return rawDate;
  }
  var ARTICLE_TYPES = /* @__PURE__ */ new Set(["NewsArticle", "Article"]);
  var authorFinders = [
    {
      // Article or NewsArticle JSON-LD
      test: (doc) => (
        // Wikipedia's JSON-LD lists "Contributors to Wikimedia projects" as the author, which is not
        // something we would include in a citation-like source description.
        !doc.title.match(/wikipedia/i) && Array.from(
          doc.querySelectorAll('script[type="application/ld+json"]')
        ).some((el) => {
          var _a;
          const ld = JSON.parse((_a = el.textContent) != null ? _a : "null");
          if (!ld) {
            return false;
          }
          return ARTICLE_TYPES.has(ld["@type"]) && ld.author;
        })
      ),
      transform: (doc) => {
        const lds = Array.from(
          doc.querySelectorAll('script[type="application/ld+json"]')
        ).map((el) => {
          var _a;
          return JSON.parse((_a = el.textContent) != null ? _a : "null");
        }).filter((ld) => ld && ARTICLE_TYPES.has(ld["@type"]));
        if (lds.length === 0) {
          return [];
        }
        if (lds.length > 1) {
          logger.warn(
            `Found ${lds.length} Articles/NewsArticle LDs, using the first one.`
          );
        }
        const articleLd = lds[0];
        if (!articleLd.author) {
          return [];
        }
        const authors = Array.isArray(articleLd.author) ? articleLd.author.map((author) => toPersorg(author)) : [toPersorg(articleLd.author)];
        return authors;
      }
    },
    {
      // HTML 'author' link type: https://html.spec.whatwg.org/multipage/links.html#link-type-author
      // NPR: https://www.npr.org/2023/06/22/1183653543/titan-submersible-missing-adventure-tourism-rescue-risk-cost
      test: (doc) => doc.querySelectorAll('a[rel="author"]').length > 0,
      transform: (doc) => Array.from(doc.querySelectorAll('a[rel="author"]')).map(
        (el) => el.textContent ? {
          name: el.textContent,
          isOrganization: false
        } : void 0
      )
    },
    {
      // Google Scholar Indexing: https://www.google.com/intl/en/scholar/inclusion.html#indexing
      // Pubmed: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1280342/
      test: (doc) => doc.querySelectorAll('meta[name="citation_author"]').length > 0,
      transform: (doc) => Array.from(doc.querySelectorAll('meta[name="citation_author"]')).map(
        (el) => {
          const content = el.getAttribute("content");
          if (!content) {
            return void 0;
          }
          return {
            name: content,
            isOrganization: false
          };
        }
      )
    },
    {
      // An NYT custom format?
      // https://www.nytimes.com/live/2023/06/24/world/russia-ukraine-news
      test: (doc) => doc.querySelectorAll('meta[name="byl"]').length > 0,
      transform: (doc) => Array.from(doc.querySelectorAll('meta[name="byl"]')).map((el) => {
        const content = el.getAttribute("content");
        if (!content) {
          return void 0;
        }
        return {
          name: content.replace(/^by /i, ""),
          isOrganization: false
        };
      })
    }
  ];
  function toPersorg(author) {
    const name = getPersorgNameFromAuthor(author);
    if (!name) {
      return void 0;
    }
    const isOrganization = getIsOrganizationFromAuthor(author);
    const knownFor = getKnownForFromAuthor(author);
    return {
      name,
      isOrganization,
      knownFor
    };
  }
  function getPersorgNameFromAuthor(author) {
    if ((0, import_lodash4.isString)(author)) {
      return author;
    }
    if (!("name" in author) || !author.name) {
      return void 0;
    }
    if ((0, import_lodash4.isString)(author.name)) {
      return author.name;
    }
    if ("textValue" in author.name && (0, import_lodash4.isString)(author.name.textValue)) {
      return author.name.textValue;
    }
    return void 0;
  }
  function getIsOrganizationFromAuthor(author) {
    if ((0, import_lodash4.isString)(author)) {
      return false;
    }
    if (!("@type" in author)) {
      return false;
    }
    return author["@type"] !== "Person";
  }
  function getKnownForFromAuthor(author) {
    if ((0, import_lodash4.isString)(author)) {
      return void 0;
    }
    if (!("description" in author) || !author.description) {
      return void 0;
    }
    if ((0, import_lodash4.isString)(author.description)) {
      return author.description;
    }
    if ("textValue" in author.description && (0, import_lodash4.isString)(author.description.textValue)) {
      return author.description.textValue;
    }
    return void 0;
  }
  function inferAnchoredBibliographicInfo(doc, quotation) {
    const bibliographicInfo = inferBibliographicInfo(doc);
    if (!quotation) {
      return bibliographicInfo;
    }
    const textPositionAnchor = textQuote.toTextPosition(doc.body, {
      exact: quotation
    });
    if (!textPositionAnchor) {
      return bibliographicInfo;
    }
    const textQuoteAnchor = textQuote.fromTextPosition(
      doc.body,
      textPositionAnchor
    );
    if (!textQuoteAnchor) {
      return bibliographicInfo;
    }
    const domAnchor = makeDomAnchor(textQuoteAnchor, textPositionAnchor);
    return __spreadProps(__spreadValues({}, bibliographicInfo), {
      anchors: [domAnchor]
    });
  }

  // ../howdju-common/lib/domCommon.ts
  var textPosition = __toESM(require_dom_anchor_text_position2());
  var textQuote2 = __toESM(require_dom_anchor_text_quote());
  var import_lodash5 = __toESM(require_lodash());
  init_logger();
  function nodeIsBefore(node1, node2) {
    return nodePositionCompare(node1, node2) < 0;
  }
  function nodeIsAfter(node1, node2) {
    return nodePositionCompare(node1, node2) > 0;
  }
  function nodeIsAfterOrSame(node1, node2) {
    return nodePositionCompare(node1, node2) >= 0;
  }
  function nodePositionCompare(node1, node2) {
    if (node1 === node2) {
      return 0;
    } else if (node1.contains(node2)) {
      return -1;
    } else if (node2.contains(node1)) {
      return 1;
    }
    let ancestor1 = node1;
    while (ancestor1.parentNode && !ancestor1.parentNode.contains(node2)) {
      ancestor1 = ancestor1.parentNode;
    }
    let ancestor2 = node2;
    while (ancestor2.parentNode && ancestor2.parentNode !== ancestor1.parentNode) {
      ancestor2 = ancestor2.parentNode;
    }
    let sibling = ancestor1.nextSibling;
    while (sibling) {
      if (sibling === ancestor2)
        return -1;
      sibling = sibling.nextSibling;
    }
    return 1;
  }
  function getTextWithin(doc, startText, endText, { prefix, suffix } = {
    prefix: void 0,
    suffix: void 0
  }) {
    const { range } = getRangeOfText(doc, startText, endText, {
      hint: 0,
      prefix,
      suffix
    });
    if (!range) {
      return void 0;
    }
    if (isRangeInsideScript(range)) {
      logger.error(
        `getTextWithin returning a range that is within a script tag for ${doc.location.href}`
      );
    }
    if (range.collapsed) {
      return void 0;
    }
    return toPlainTextContent(range);
  }
  function isRangeInsideScript(range) {
    return isNodeInsideScript(range.startContainer) || isNodeInsideScript(range.endContainer);
  }
  function isNodeInsideScript(node) {
    let currNode = node;
    while (currNode) {
      if (isScriptNode(currNode)) {
        return true;
      }
      currNode = currNode.parentNode;
    }
    return false;
  }
  function isScriptNode(node) {
    return node.nodeType === getNodeConstructor(node).ELEMENT_NODE && node.nodeName.toLowerCase() === "script";
  }
  function findTextInDoc(doc, text) {
    const range = getRangeOfTextInDoc(doc, text);
    if (!range) {
      return void 0;
    }
    return toPlainTextContent(range);
  }
  function getRangeOfTextInDoc(doc, quotation) {
    const matches = approximateMatch(doc.body.textContent || "", quotation);
    if (!matches.length) {
      return void 0;
    }
    const { start, end } = matches[0];
    return textPosition.toRange(doc.body, { start, end }) || void 0;
  }
  function getRangeOfText(doc, startText, endText, { prefix, suffix, hint }) {
    let startPosition = textQuote2.toTextPosition(
      doc.body,
      { exact: startText, prefix },
      hint !== void 0 ? { hint } : void 0
    );
    if (!startPosition) {
      return { range: void 0, end: void 0 };
    }
    let endPosition = textQuote2.toTextPosition(
      doc.body,
      { exact: endText, suffix },
      { hint: startPosition.end }
    );
    if (!endPosition) {
      return { range: void 0, end: void 0 };
    }
    if (startPosition.start >= endPosition.end) {
      const betterStartPosition = textQuote2.toTextPosition(
        doc.body,
        { exact: startText },
        { hint: endPosition.start }
      );
      const betterEndPosition = textQuote2.toTextPosition(
        doc.body,
        { exact: endText },
        { hint: startPosition.end }
      );
      const betterStartLength = betterStartPosition ? endPosition.start - betterStartPosition.end : Number.NEGATIVE_INFINITY;
      const betterEndLength = betterEndPosition ? betterEndPosition.start - startPosition.end : Number.NEGATIVE_INFINITY;
      const isValidBetterStart = betterStartPosition && betterStartLength > 0;
      const isValidBetterEnd = betterEndPosition && betterEndLength > 0;
      if (isValidBetterStart) {
        if (isValidBetterEnd) {
          if (betterStartLength < betterEndLength) {
            startPosition = betterStartPosition;
          } else {
            endPosition = betterEndPosition;
          }
        } else {
          startPosition = betterStartPosition;
        }
      } else if (isValidBetterEnd) {
        endPosition = betterEndPosition;
      }
      if (startPosition.start >= endPosition.end) {
        return { range: void 0, end: void 0 };
      }
    }
    const maybeCloserStartPosition = textQuote2.toTextPosition(
      doc.body,
      { exact: startText, prefix },
      { hint: endPosition.start }
    );
    if (maybeCloserStartPosition) {
      const maybeCloserStartPositionDistance = endPosition.start - maybeCloserStartPosition.end;
      if (maybeCloserStartPositionDistance > 0 && maybeCloserStartPositionDistance < endPosition.start - startPosition.end) {
        startPosition = maybeCloserStartPosition;
      }
    }
    const range = textPosition.toRange(doc.body, {
      start: startPosition.start,
      end: endPosition.end
    });
    return { range, end: endPosition.end };
  }
  function getNodeConstructor(node) {
    var _a;
    const window2 = "defaultView" in node ? node.defaultView : (_a = node.ownerDocument) == null ? void 0 : _a.defaultView;
    if (!window2) {
      throw new Error(
        `Unable to obtain window from node to get Node constructor.`
      );
    }
    return window2.Node;
  }
  function toPlainTextContent(range) {
    const textParts = [];
    const Node2 = getNodeConstructor(range.startContainer);
    walkRangeNodes(range, {
      enter: (node) => {
        var _a, _b, _c;
        if (node.nodeType === Node2.TEXT_NODE) {
          let text;
          if (node.isSameNode(range.startContainer)) {
            if (node.isSameNode(range.endContainer)) {
              text = (_a = node.textContent) == null ? void 0 : _a.substring(
                range.startOffset,
                range.endOffset
              );
            } else {
              text = (_b = node.textContent) == null ? void 0 : _b.substring(range.startOffset);
            }
          } else if (node.isSameNode(range.endContainer)) {
            text = (_c = node.textContent) == null ? void 0 : _c.substring(0, range.endOffset);
          } else {
            text = node.textContent;
          }
          text = text == null ? void 0 : text.trim();
          if (text) {
            textParts.push(text);
          }
        }
      },
      leave: (node) => {
        if (node.nodeType === Node2.ELEMENT_NODE && ["p", "div", "h1", "h2", "h3", "h4", "h5", "h6"].includes(
          node.nodeName.toLowerCase()
        )) {
          textParts.push("\n\n");
        }
      }
    });
    return textParts.join(" ").replace(/^\s+/gm, "").replace(/\s+$/gm, "\n").trim();
  }
  function isTextNode(node) {
    return node.nodeType === getNodeConstructor(node).TEXT_NODE;
  }
  function walkRangeNodes(range, { enter, leave }) {
    var _a;
    let node = isTextNode(range.startContainer) || range.startOffset == 0 ? range.startContainer : range.startContainer.childNodes[range.startOffset];
    while (node) {
      enter(node);
      if (node.firstChild) {
        node = node.firstChild;
        continue;
      }
      while (node && !node.nextSibling) {
        leave(node);
        if (node.isSameNode(range.endContainer)) {
          return;
        }
        node = node.parentNode;
      }
      if (!node) {
        logger.error(
          `Unexpectedly reached the root node without encountering the range's endContainer.`
        );
        return;
      }
      leave(node);
      node = node.nextSibling;
      if (!isTextNode(range.endContainer) && ((_a = node == null ? void 0 : node.parentNode) == null ? void 0 : _a.isSameNode(range.endContainer)) && (0, import_lodash5.indexOf)(node.parentNode.childNodes, node) >= range.endOffset) {
        return;
      }
      if (node && !range.endContainer.contains(node) && nodeIsAfter(node, range.endContainer)) {
        return;
      }
    }
  }

  // ../howdju-common/lib/enums.ts
  var ActionTypes2 = {
    /** The user created something */
    CREATE: "CREATE",
    /** The user tried to create something that was a duplicate of something existing; nothing was created */
    TRY_CREATE_DUPLICATE: "TRY_CREATE_DUPLICATE",
    UPDATE: "UPDATE",
    DELETE: "DELETE",
    ASSOCIATE: "ASSOCIATE",
    DISASSOCIATE: "DISASSOCIATE"
  };
  var ActionTargetTypes = {
    PROPOSITION: "PROPOSITION",
    PROPOSITION_COMPOUND: "PROPOSITION_COMPOUND",
    JUSTIFICATION: "JUSTIFICATION",
    JUSTIFICATION_BASIS_COMPOUND: "JUSTIFICATION_BASIS_COMPOUND",
    JUSTIFICATION_BASIS_COMPOUND_ATOM: "JUSTIFICATION_BASIS_COMPOUND_ATOM",
    SOURCE_EXCERPT_PARAPHRASE: "SOURCE_EXCERPT_PARAPHRASE",
    WRIT_QUOTE: "WRIT_QUOTE",
    WRIT: "WRIT",
    PIC_REGION: "PIC_REGION",
    PIC: "PIC",
    VID_SEGMENT: "VID_SEGMENT",
    VID: "VID",
    USER: "USER",
    URL: "URL"
  };
  var ActionSubjectTypes = {
    URL: "URL"
  };
  var JustificationBasisSourceTypes = {
    /* One or more propositions */
    PROPOSITION_COMPOUND: "PROPOSITION_COMPOUND",
    /** A quote
     *
     * @deprecated TODO(201)
     */
    WRIT_QUOTE: "WRIT_QUOTE",
    /**
     * One or more {@see JustificationBasisCompoundAtomTypes}
     *
     * @deprecated TODO(28)
     */
    JUSTIFICATION_BASIS_COMPOUND: "JUSTIFICATION_BASIS_COMPOUND",
    PROPOSITION: "PROPOSITION",
    /** @deprecated TODO(215) */
    SOURCE_EXCERPT_PARAPHRASE: "SOURCE_EXCERPT_PARAPHRASE",
    MEDIA_EXCERPT: "MEDIA_EXCERPT"
  };
  function isJustificationBasisSourceType(val) {
    return val in JustificationBasisSourceTypes;
  }
  var JustificationBasisCompoundAtomTypes = {
    PROPOSITION: "PROPOSITION",
    SOURCE_EXCERPT_PARAPHRASE: "SOURCE_EXCERPT_PARAPHRASE"
  };
  var SortDirections = {
    ASCENDING: "ascending",
    DESCENDING: "descending"
  };
  var JustificationScoreTypes = {
    GLOBAL_VOTE_SUM: "GLOBAL_VOTE_SUM"
  };
  var PropositionTagScoreTypes = {
    GLOBAL_VOTE_SUM: "GLOBAL_VOTE_SUM"
  };
  var JobHistoryStatuses = {
    SUCCESS: "SUCCESS",
    FAILURE: "FAILURE"
  };
  var PropositionCompoundAtomTypes = {
    // What was I thinking of adding here? Statements?
    PROPOSITION: "PROPOSITION"
  };

  // ../howdju-common/lib/index.ts
  init_general();

  // ../howdju-common/lib/httpMethods.ts
  var httpMethods = {
    GET: "GET",
    POST: "POST",
    PUT: "PUT",
    DELETE: "DELETE",
    OPTIONS: "OPTIONS"
  };

  // ../howdju-common/lib/httpStatusCodes.ts
  var httpStatusCodes = {
    OK: 200,
    /** There was nothing to do and nothing new to return (does not allow a body) */
    NO_CONTENT: 204,
    /** The parameters/body supplied for the endpoint are improper */
    BAD_REQUEST: 400,
    /** The user is not authenticated, or improperly authenticated */
    UNAUTHORIZED: 401,
    /** The user is authenticated but not authorized; not allowed to perform the requested action, lacks permission */
    FORBIDDEN: 403,
    /** The requested resource, or some required resource, was not found */
    NOT_FOUND: 404,
    /**
     * The request conflicts with the server state.
     *
     * E.g., tried to create a user having the same username.
     */
    CONFLICT: 409,
    /** The server is responsible for the error. */
    ERROR: 500
  };

  // ../howdju-common/lib/index.ts
  init_logger();

  // ../howdju-common/lib/models.ts
  var import_lodash7 = __toESM(require_lodash());
  var import_assign = __toESM(require_assign());
  var import_merge = __toESM(require_merge());
  var import_toString = __toESM(require_toString());
  init_commonErrors();
  init_general();
  init_zodSchemas();

  // ../howdju-common/lib/zodSchemaTypes.ts
  init_lib();
  init_commonErrors();
  init_logger();
  function isBareRef(o3) {
    const keys4 = Object.keys(o3);
    return keys4.length === 1 && keys4[0] === "id";
  }
  function isOnlyRef(o3, brand) {
    if (Object.keys(o3).length !== 1) {
      return false;
    }
    return "id" in o3 && mod.BRAND in o3 && (!brand || o3[mod.BRAND] === brand);
  }
  function isRef(e2) {
    const keys4 = Object.keys(e2);
    if (keys4.length === 1 && keys4[0] === "id") {
      if (!(mod.BRAND in e2)) {
        logger.warn(`Ref lacks z.BRAND property (id: ${e2.id}).`);
      }
      return true;
    }
    const isBranded = mod.BRAND in e2;
    if (isBranded && !e2.id) {
      throw newProgrammingError(
        `Ref has a BRAND but lacks an ID (BRAND: ${e2[mod.BRAND]}).`
      );
    }
    return isBranded;
  }
  function brandedParse(brandSchema, val) {
    return __spreadValues(__spreadValues({}, val), brandSchema.parse(val));
  }

  // ../howdju-common/lib/models.ts
  var isPositive = (j3) => j3.polarity === "POSITIVE";
  var isNegative = (j3) => j3.polarity === "NEGATIVE";
  var isRootPositive = (j3) => j3.rootPolarity === "POSITIVE";
  var isRootNegative = (j3) => j3.rootPolarity === "NEGATIVE";
  var isRootJustification = (j3) => {
    var _a, _b;
    return ((_a = j3.target) == null ? void 0 : _a.type) === j3.rootTargetType && ((_b = j3.target) == null ? void 0 : _b.entity.id) === j3.rootTarget.id;
  };
  var hasQuote = (j3) => j3.basis.type === "WRIT_QUOTE" && j3.basis.entity.quoteText;
  var isPropositionCompoundBased = (j3) => j3 ? j3.basis.type === "PROPOSITION_COMPOUND" : false;
  function isMediaExcerptBased(j3) {
    return j3.basis.type === "MEDIA_EXCERPT";
  }
  var isWritQuoteBased = (j3) => j3 ? j3.basis.type === "WRIT_QUOTE" : false;
  var negateJustificationVotePolarity = (polarity) => {
    switch (polarity) {
      case "POSITIVE":
        return "NEGATIVE";
      case "NEGATIVE":
        return "POSITIVE";
      default:
        throw newExhaustedEnumError(polarity);
    }
  };
  var negateRootPolarity = (rootPolarity) => {
    switch (rootPolarity) {
      case "POSITIVE":
        return "NEGATIVE";
      case "NEGATIVE":
        return "POSITIVE";
      default:
        throw newImpossibleError(rootPolarity);
    }
  };
  var makeCredentials = (props) => (0, import_assign.default)({ email: "", password: "" }, props);
  var makeCreateRegistrationRequestInput = (props) => {
    return (0, import_assign.default)({ email: "" }, props);
  };
  var makeCreateRegistrationRequest = (props) => (0, import_assign.default)(
    {
      email: ""
    },
    props
  );
  var makeCreateRegistrationConfirmationInput = (props) => (0, import_assign.default)(
    {
      registrationCode: "",
      username: "",
      shortName: "",
      longName: "",
      password: "",
      doesAcceptTerms: false,
      is13YearsOrOlder: false,
      hasMajorityConsent: false,
      isNotGdpr: false
    },
    props
  );
  var makeCreateRegistrationConfirmation = makeCreateRegistrationConfirmationInput;
  var makeAccountSettings = (props) => (0, import_assign.default)(
    {
      paidContributionsDisclosure: ""
    },
    props
  );
  var makeCreatePropositionCompoundInput = () => ({
    atoms: [makeCreatePropositionCompoundAtomInput()]
  });
  var makeCreatePropositionCompoundInputFromProposition = (proposition) => ({
    atoms: [{ entity: proposition }]
  });
  var makeCreatePropositionCompoundAtomInput = () => ({
    entity: makeCreatePropositionInput()
  });
  var makeUrl = (props) => (0, import_merge.default)({ url: "" }, props);
  var makeCreateUrl = (props) => (0, import_merge.default)({ url: "" }, props);
  var makeCreateUrlLocatorInput = (props) => (0, import_merge.default)({ url: makeCreateUrl() }, props);
  var makeCreateMediaExcerptSpeakerInput = (props) => (0, import_merge.default)(
    {
      persorg: makeCreatePersorg()
    },
    props
  );
  var makeCreatePersorg = () => ({
    isOrganization: false,
    name: "",
    knownFor: "",
    websiteUrl: void 0,
    twitterUrl: void 0,
    wikipediaUrl: void 0
  });
  var idEqual = (id1, id2) => isDefined(id1) && isDefined(id2) && (0, import_toString.default)(id1) === (0, import_toString.default)(id2);
  var makeTag = (props) => (0, import_merge.default)(
    {
      name: ""
    },
    props
  );
  var tagEqual = (tag1, tag2) => {
    if (idEqual(tag1.id, tag2.id)) {
      return true;
    }
    if (isRef(tag1) || isRef(tag2)) {
      return false;
    }
    return isDefined(tag1.name) && tag1.name === tag2.name;
  };
  var makePropositionTagVote = (props) => props;
  var doTargetSameRoot = (j1, j22) => idEqual(j1.rootTarget.id, j22.rootTarget.id) && j1.rootTargetType === j22.rootTargetType;
  var makeNewAccountSettings = () => ({});
  function makeVidSegment() {
    return {};
  }
  function makePicRegion() {
    return {};
  }
  var makeCreateJustifiedSentenceInput = (propositionProps = {}, justificationProps = {}) => ({
    proposition: makeCreatePropositionInput(propositionProps),
    speakers: [],
    justification: makeCreateJustificationInput(justificationProps),
    // whether to have the justification controls expanded and to create a justification along with the proposition
    doCreateJustification: !!justificationProps
  });
  var makeCreateStatementInput = (props) => (0, import_merge.default)(
    {
      speaker: makeCreatePersorg(),
      sentenceType: "PROPOSITION",
      sentence: makeCreatePropositionInput()
    },
    props
  );
  var makeCreatePropositionInput = (props) => (0, import_assign.default)({ text: "" }, props);
  var makeCreateJustificationInput = (props) => {
    const model = (0, import_merge.default)(
      {
        rootTargetType: "PROPOSITION",
        rootTarget: { text: "" },
        polarity: "POSITIVE",
        rootPolarity: "POSITIVE",
        target: {
          type: "PROPOSITION",
          proposition: makeCreatePropositionInput(),
          statement: makeCreateStatementInput(),
          // Must be undefined to prevent infinite recursion
          justification: void 0
        },
        basis: {
          type: "PROPOSITION_COMPOUND",
          propositionCompound: makeCreatePropositionCompoundInput(),
          mediaExcerpt: makeCreateMediaExcerptInput(),
          sourceExcerpt: makeCreateSourceExcerptInput(),
          writQuote: makeCreateWritQuoteInput()
        }
      },
      props
    );
    inferCreateJustificationInputRootTarget(model);
    return model;
  };
  function makeCreateMediaExcerptInput(props) {
    return (0, import_merge.default)(
      {
        localRep: {
          quotation: ""
        },
        locators: {
          urlLocators: []
        },
        citations: [{ source: { description: "" } }],
        speakers: []
      },
      props
    );
  }
  var makeWritInput = () => ({ title: "" });
  var makeUrlInput = () => ({ url: "" });
  var makeCreateWritQuoteInput = (props) => (0, import_merge.default)(
    {
      writ: makeWritInput(),
      quoteText: "",
      urls: [makeUrlInput()]
    },
    props
  );
  var makeCreatePicRegionInput = makePicRegion;
  var makeCreateVidSegmentInput = makeVidSegment;
  function inferCreateJustificationInputRootTarget(model) {
    let targetEntity = demuxCreateJustificationInputTarget(model.target).entity;
    let targetType = model.target.type;
    let rootPolarity = model.polarity;
    while (targetEntity && "target" in targetEntity) {
      rootPolarity = targetEntity.polarity;
      targetType = targetEntity.target.type;
      targetEntity = targetEntity.target.entity;
    }
    if (targetType === "JUSTIFICATION" || !targetEntity) {
      throw newProgrammingError(
        "Unable to infer justification root target. We ended up at a justification."
      );
    }
    model.rootTargetType = targetType;
    model.rootTarget = targetEntity;
    model.rootPolarity = rootPolarity;
  }
  function makeCreateSourceExcerptInput(props) {
    return (0, import_merge.default)(
      {
        type: "WRIT_QUOTE",
        writQuote: makeCreateWritQuoteInput(),
        picRegion: makeCreatePicRegionInput(),
        vidSegment: makeCreateVidSegmentInput()
      },
      props
    );
  }
  function makeCreateJustificationBasisCompoundInput() {
    return {};
  }
  var demuxCreateJustificationInputTarget = (target) => {
    switch (target.type) {
      case "PROPOSITION":
        return {
          type: "PROPOSITION",
          entity: target.proposition
        };
      case "STATEMENT":
        return {
          type: "STATEMENT",
          entity: target.statement
        };
      case "JUSTIFICATION":
        if (!target.justification) {
          throw newProgrammingError(
            "CreateJustificationInput.target must hold another CreateJustificationInput when type is JUSTIFICATION."
          );
        }
        return {
          type: "JUSTIFICATION",
          entity: isRef(target.justification) ? target.justification : demuxCreateJustificationInput(target.justification)
        };
      default:
        throw newExhaustedEnumError(target);
    }
  };
  function demuxCreateJustificationInput(input) {
    const basis = demuxCreateJustificationInputBasis(input.basis);
    const target = demuxCreateJustificationInputTarget(input.target);
    const creation = (0, import_assign.default)((0, import_lodash7.cloneDeep)(input), {
      target,
      basis
    });
    return creation;
  }
  var muxCreateJustificationErrors = (create, createErrors) => {
    const basis = createErrors.basis && muxCreateJustificationBasisErrors(create.basis, createErrors.basis);
    const target = createErrors.target && muxCreateJustificationTargetErrors(create.target, createErrors.target);
    const inputErrors = (0, import_assign.default)((0, import_lodash7.cloneDeep)(createErrors), {
      target,
      basis
    });
    return inputErrors;
  };
  function muxCreateJustificationTargetErrors(target, errors) {
    switch (target.type) {
      case "PROPOSITION":
        return {
          _errors: errors._errors,
          proposition: errors.entity
        };
      case "STATEMENT":
        return {
          _errors: errors._errors,
          statement: errors.entity
        };
      case "JUSTIFICATION":
        return {
          _errors: errors._errors,
          justification: "basis" in target.entity ? errors.entity && muxCreateJustificationErrors(target.entity, errors.entity) : errors.entity
        };
      default:
        throw newExhaustedEnumError(target);
    }
  }
  var muxCreateJustificationBasisErrors = (basis, errors) => {
    switch (basis.type) {
      case "PROPOSITION_COMPOUND":
        return {
          _errors: errors._errors,
          propositionCompound: errors.entity
        };
      case "MEDIA_EXCERPT":
        return {
          _errors: errors._errors,
          mediaExcerpt: errors.entity
        };
      case "WRIT_QUOTE":
        return {
          _errors: errors._errors,
          writQuote: errors.entity
        };
      case "SOURCE_EXCERPT":
        return {
          _errors: errors._errors,
          sourceExcerpt: isRef(basis.entity) ? errors.entity : errors.entity && muxCreateSourceExcerptErrors(basis.entity, errors.entity)
        };
      default:
        throw newExhaustedEnumError(basis);
    }
  };
  function muxCreateSourceExcerptErrors(create, createErrors) {
    switch (create.type) {
      case "WRIT_QUOTE":
        return {
          _errors: createErrors._errors,
          writQuote: createErrors.entity
        };
      case "PIC_REGION":
        return {
          _errors: createErrors._errors,
          picRegion: createErrors.entity
        };
      case "VID_SEGMENT":
        return {
          _errors: createErrors._errors,
          vidSegment: createErrors.entity
        };
    }
  }
  var demuxCreateJustificationInputBasis = (basis) => {
    switch (basis.type) {
      case "PROPOSITION_COMPOUND":
        return {
          type: "PROPOSITION_COMPOUND",
          entity: basis.propositionCompound
        };
      case "MEDIA_EXCERPT":
        if (!basis.mediaExcerpt) {
          throw newImpossibleError("Media excerpt must be defined.");
        }
        return {
          type: "MEDIA_EXCERPT",
          entity: basis.mediaExcerpt
        };
      case "WRIT_QUOTE":
        return {
          type: "WRIT_QUOTE",
          entity: basis.writQuote
        };
      case "SOURCE_EXCERPT":
        return {
          type: "SOURCE_EXCERPT",
          entity: demuxJustificationBasisSourceExcerptInput(basis.sourceExcerpt)
        };
      default:
        throw newExhaustedEnumError(basis);
    }
  };
  function demuxJustificationBasisSourceExcerptInput(sourceExcerpt) {
    if (isRef(sourceExcerpt)) {
      return sourceExcerpt;
    }
    switch (sourceExcerpt.type) {
      case "PIC_REGION":
        return {
          type: "PIC_REGION",
          entity: sourceExcerpt.picRegion
        };
      case "VID_SEGMENT":
        return {
          type: "VID_SEGMENT",
          entity: sourceExcerpt.vidSegment
        };
      case "WRIT_QUOTE":
        return {
          type: "WRIT_QUOTE",
          entity: sourceExcerpt.writQuote
        };
    }
  }
  function muxSourceExcerpt(sourceExcerpt) {
    const input = makeCreateSourceExcerptInput(sourceExcerpt);
    const muxEntity = muxSourceExcerptEntity(sourceExcerpt);
    return __spreadValues(__spreadValues({}, input), muxEntity);
  }
  function muxSourceExcerptEntity(sourceExcerpt) {
    switch (sourceExcerpt.type) {
      case "WRIT_QUOTE":
        return { writQuote: sourceExcerpt.entity };
      case "PIC_REGION":
        return { picRegion: sourceExcerpt.entity };
        break;
      case "VID_SEGMENT":
        return { vidSegment: sourceExcerpt.entity };
    }
  }
  var makeCreateCounterJustificationInput = (targetJustification) => ({
    rootPolarity: negateRootPolarity(targetJustification.rootPolarity),
    target: {
      type: "JUSTIFICATION",
      justification: targetJustification.id ? JustificationRef.parse(targetJustification) : targetJustification
    },
    basis: {
      type: "PROPOSITION_COMPOUND",
      propositionCompound: makeCreatePropositionCompoundInput()
    },
    polarity: "NEGATIVE"
  });
  var makeCreateJustificationInputTargetingRoot = (targetType, targetId, polarity) => {
    let targetEntityProperty;
    switch (targetType) {
      case "PROPOSITION":
        targetEntityProperty = "proposition";
        break;
      case "STATEMENT":
        targetEntityProperty = "statement";
        break;
      default:
        throw newExhaustedEnumError(targetType);
    }
    return makeCreateJustificationInput({
      rootTargetType: targetType,
      rootTarget: { id: targetId },
      polarity,
      target: { type: targetType, [targetEntityProperty]: { id: targetId } }
    });
  };

  // ../howdju-common/lib/moment.ts
  var import_moment4 = __toESM(require_moment());
  var MomentConstructor = import_moment4.default;

  // ../howdju-common/lib/index.ts
  init_schemas();
  init_schemaValidation();
  __reExport(lib_exports, __toESM(require_standaloneValidation()));

  // ../howdju-common/lib/serialization.ts
  var import_cloneDeep = __toESM(require_cloneDeep());
  function decircularizeJustification(justification) {
    const decircularized = (0, import_cloneDeep.default)(justification);
    if (decircularized.rootTarget.id) {
      decircularized.rootTarget = { id: decircularized.rootTarget.id };
    }
    if (justification.counterJustifications) {
      decircularized.counterJustifications = justification.counterJustifications.map(
        (j3) => "counterJustifications" in j3 ? decircularizeJustification(j3) : j3
      );
    }
    if (decircularized.target.entity.id) {
      decircularized.target.entity = { id: decircularized.target.entity.id };
    }
    return decircularized;
  }
  var decircularizeSourceExcerpt = (sourceExcerpt) => {
    return sourceExcerpt;
  };
  var decircularizeProposition = (proposition) => {
    return proposition;
  };

  // ../howdju-common/lib/services/TopicMessage.ts
  init_lib();
  var TopicMessage = mod.discriminatedUnion("type", [
    /** Send an email. */
    mod.object({
      type: mod.literal("SEND_EMAIL"),
      params: mod.object({
        // Email senders must be preconfigured in AWS SES.
        from: mod.string().email().optional(),
        to: mod.union([mod.string().email(), mod.array(mod.string().email())]),
        subject: mod.string(),
        bodyHtml: mod.string(),
        bodyText: mod.string(),
        tags: mod.object({}).passthrough().optional()
      })
    }),
    /** Check whether a UrlLocator accurately reflects its MediaExcerpt's localRep. */
    mod.object({
      type: mod.literal("AUTO_CONFIRM_URL_LOCATOR"),
      params: mod.object({
        urlLocatorId: mod.string()
      })
    }),
    /** Confirm that urlId's canonicalUrl reflects what its HTML says. */
    mod.object({
      type: mod.literal("CONFIRM_CANONICAL_URL"),
      params: mod.object({
        urlId: mod.string()
      })
    })
  ]);

  // ../howdju-common/lib/index.ts
  init_urls();

  // ../howdju-common/lib/urlTextFragments.ts
  var FRAGMENT_DIRECTIVE = ":~:";
  function toUrlWithFragmentFromQuotation(url, quotation) {
    if (!quotation) {
      return url;
    }
    const urlObj = new URL(url);
    const fragmentDirectiveIndex = urlObj.hash.indexOf(FRAGMENT_DIRECTIVE);
    if (fragmentDirectiveIndex > -1) {
      logger.error(`URL should not already have a text fragment: ${url}`);
    }
    const hash = (
      // remove an existing text fragment
      fragmentDirectiveIndex > -1 ? urlObj.hash.substring(0, fragmentDirectiveIndex) : urlObj.hash
    );
    urlObj.hash = hash + FRAGMENT_DIRECTIVE + "text=" + cleanTextFragmentParameter(quotation);
    return urlObj.toString();
  }
  function toUrlWithFragmentFromAnchors(urlLocator, useContext = false) {
    var _a;
    const urlObj = new URL(urlLocator.url.url);
    const fragmentDirectiveIndex = urlObj.hash.indexOf(FRAGMENT_DIRECTIVE);
    if (fragmentDirectiveIndex > -1) {
      logger.warn(
        `URL ${urlLocator.url.url} already contains a fragment. It will be overwritten.`
      );
    }
    const documentFragment = (
      // substring from 1 to remove the leading #.
      fragmentDirectiveIndex > -1 ? urlObj.hash.substring(1, fragmentDirectiveIndex) : urlObj.hash.substring(1)
    );
    const textDirectives = (_a = urlLocator.anchors) == null ? void 0 : _a.map((a3) => {
      const parameters = [];
      if (useContext && a3.prefixText) {
        parameters.push(cleanTextFragmentParameter(a3.prefixText) + "-");
      }
      parameters.push(cleanTextFragmentParameter(a3.exactText));
      if (useContext && a3.suffixText) {
        parameters.push("-" + cleanTextFragmentParameter(a3.suffixText));
      }
      return `text=${parameters.join(",")}`;
    });
    const newHash = (textDirectives == null ? void 0 : textDirectives.length) ? `${documentFragment}${FRAGMENT_DIRECTIVE}${textDirectives.join("&")}` : documentFragment ? `${documentFragment}` : "";
    urlObj.hash = newHash;
    return urlObj.toString();
  }
  function cleanTextFragmentParameter(textParameter) {
    return encodeTextFragmentParameter(textParameter.replace(/\n/g, ""));
  }
  function encodeTextFragmentParameter(textParameter) {
    return encodeURIComponent(textParameter).replace(/-/g, "%2D");
  }
  var defaultOptions = {
    doc: void 0,
    textDirectiveDelimiter: "\u2026",
    textParameterStartEndDelimiter: "\u2026"
  };
  function extractQuotationFromTextFragment(url, options = defaultOptions) {
    const urlObj = new URL(url);
    const fragmentMatch = urlObj.hash.match(/:~:(.*)$/);
    if (!fragmentMatch) {
      return void 0;
    }
    const fragmentDirective = fragmentMatch[1];
    const fragmentDirectiveParts = fragmentDirective.split("&");
    const quoteParts = fragmentDirectiveParts.map((directive) => {
      var _a, _b;
      if (!directive.startsWith("text=")) {
        logger.error(`Text directive must start with "text=": ${directive}`);
        return void 0;
      }
      const textParameters = directive.replace(/^text=/, "").split(",").map(decodeURIComponent);
      if (textParameters.length < 1 || textParameters.length > 4) {
        logger.error(`Text directive must have 1\u20134 parameters: ${directive}`);
        return void 0;
      }
      if (textParameters.length === 1) {
        return textParameters[0];
      }
      if (textParameters.length === 4) {
        if (options.doc) {
          const [prefix, startText, endText, suffix] = textParameters;
          const textWithin = getTextWithin(options.doc, startText, endText, {
            prefix: prefix.replace(/-$/, ""),
            suffix: suffix.replace(/^-/, "")
          });
          if (textWithin) {
            return textWithin;
          }
        }
        const textParameterStartEndDelimiter = (_a = options.textParameterStartEndDelimiter) != null ? _a : defaultOptions.textParameterStartEndDelimiter;
        return textParameters[1] + textParameterStartEndDelimiter + textParameters[2];
      }
      let start = 0;
      let end = textParameters.length - 1;
      if (textParameters[0].endsWith("-")) {
        start += 1;
      }
      if (textParameters[textParameters.length - 1].startsWith("-")) {
        end -= 1;
      }
      if (end - start > 1) {
        logger.error(
          `Text directive with three parameters must have a prefix or suffix: ${directive}`
        );
        return void 0;
      }
      if (options.doc) {
        const startText = textParameters[start];
        const endText = textParameters[end];
        const prefix = start === 1 ? textParameters[0] : void 0;
        const suffix = end < textParameters.length - 1 ? textParameters[textParameters.length - 1] : void 0;
        const textWithin = getTextWithin(options.doc, startText, endText, {
          prefix: prefix == null ? void 0 : prefix.replace(/-$/, ""),
          suffix: suffix == null ? void 0 : suffix.replace(/^-/, "")
        });
        if (textWithin) {
          return textWithin;
        }
      }
      const textDirectiveDelimiter = (_b = options.textDirectiveDelimiter) != null ? _b : defaultOptions.textDirectiveDelimiter;
      return textParameters.slice(start, end + 1).join(textDirectiveDelimiter);
    });
    return quoteParts.filter(isDefined).join(options.textDirectiveDelimiter);
  }

  // ../howdju-common/lib/validation.ts
  var import_lodash11 = __toESM(require_lodash());
  init_logger();
  var EmptyBespokeValidationErrors = {
    hasErrors: false,
    modelErrors: [],
    fieldErrors: {}
  };
  function newBespokeValidationErrors() {
    return (0, import_lodash11.cloneDeep)(
      EmptyBespokeValidationErrors
    );
  }
  var onlyFieldError = (fieldError, code) => {
    const errors = (0, import_lodash11.filter)(fieldError, (fe) => (0, import_lodash11.isObject)(fe) && fe.code === code);
    if (errors.length > 1) {
      logger.error(`Multiple field errors have the code ${code}.`);
    }
    return (0, import_lodash11.head)(errors);
  };

  // ../howdju-common/lib/index.ts
  init_zodError();
  init_zodRefinements();
  init_zodSchemas();

  // ../howdju-client-common/lib/actions.ts
  var str = (ac) => ac.toString();
  var extension = {
    highlightTarget: createAction(
      "EXTENSION/HIGHLIGHT_TARGET",
      (justification, url) => ({
        payload: {
          justification: decircularizeJustification(
            justification
          ),
          url
        }
      })
    ),
    messageHandlerReady: createAction("EXTENSION/MESSAGE_HANDLER_READY")
  };
  var extensionFrame = {
    beginEditOfMediaExcerptFromInfo: createAction(
      "EXTENSION_FRAME/BEGIN_EDIT_OF_MEDIA_EXCERPT_FROM_INFO",
      (mediaExcerptInfo) => ({
        payload: mediaExcerptInfo
      })
    ),
    gotoJustification: createAction(
      "EXTENSION_FRAME/GOTO_JUSTIFICATION",
      (justification) => ({
        payload: { justification }
      })
    ),
    ackMessage: createAction("EXTENSION_FRAME/ACK_MESSAGE")
  };

  // ../howdju-client-common/lib/dom.ts
  function isTextNode2(node) {
    return node.nodeType === Node.TEXT_NODE;
  }
  function getNextLeafNode(node) {
    let nextLeafNode = node;
    while (nextLeafNode && !nextLeafNode.nextSibling) {
      nextLeafNode = nextLeafNode.parentNode;
    }
    if (!nextLeafNode) {
      logger.error(
        "Unable to return next leaf node because we exhausted parents while looking for a next sibling."
      );
      return null;
    }
    nextLeafNode = nextLeafNode.nextSibling;
    while (nextLeafNode && nextLeafNode.childNodes.length) {
      nextLeafNode = nextLeafNode.childNodes[0];
    }
    return nextLeafNode;
  }
  function getPreviousLeafNode(node) {
    let prevLeafNode = node;
    while (prevLeafNode && !prevLeafNode.previousSibling) {
      prevLeafNode = prevLeafNode.parentNode;
    }
    if (!prevLeafNode) {
      logger.error(
        "Unable to return previous leaf node because we exhausted parents while looking for a previous sibling."
      );
      return null;
    }
    prevLeafNode = prevLeafNode.previousSibling;
    while (prevLeafNode && prevLeafNode.childNodes.length) {
      prevLeafNode = prevLeafNode.childNodes[prevLeafNode.childNodes.length - 1];
    }
    return prevLeafNode;
  }
  function normalizeContentRange(range) {
    var _a;
    if (!range.startContainer || !range.endContainer) {
      throw new Error(
        "Unable to normalize range because one or both nodes are missing."
      );
    }
    const normalRange = range.cloneRange();
    if (range.startContainer === range.endContainer) {
      if (range.startOffset > range.endOffset) {
        normalRange.setStart(range.startContainer, range.endOffset);
        normalRange.setEnd(range.endContainer, range.startOffset);
      }
      return normalRange;
    }
    if (nodeIsAfter(range.startContainer, range.endContainer)) {
      normalRange.setStart(range.endContainer, range.endOffset);
      normalRange.setEnd(range.startContainer, range.startOffset);
    }
    if (isTextNode2(range.startContainer) && range.startOffset === ((_a = range.startContainer.textContent) == null ? void 0 : _a.length)) {
      let nextLeafNode = getNextLeafNode(range.startContainer);
      while (nextLeafNode && isEmptyTextContent(nextLeafNode.textContent)) {
        nextLeafNode = getNextLeafNode(nextLeafNode);
      }
      if (nextLeafNode) {
        normalRange.setStart(nextLeafNode, 0);
      }
    }
    if (!isTextNode2(range.endContainer) || range.endOffset === 0) {
      let prevLeafNode = getPreviousLeafNode(range.endContainer);
      while (prevLeafNode && isEmptyTextContent(prevLeafNode.textContent)) {
        prevLeafNode = getPreviousLeafNode(prevLeafNode);
      }
      if (prevLeafNode) {
        normalRange.setEnd(
          prevLeafNode,
          prevLeafNode.nodeValue ? prevLeafNode.nodeValue.length : 0
        );
      }
    }
    return normalRange;
  }
  function isEmptyTextContent(text) {
    return text === null || text.trim().length === 0;
  }

  // ../howdju-client-common/lib/extension.ts
  var Extension = class {
    constructor(extension3) {
      this.extension = extension3;
    }
    sendRuntimeMessage(message, responseCallback) {
      this.extension.runtime.sendMessage(message, responseCallback);
    }
    createTab(details) {
      return __async(this, null, function* () {
        return this.extension.tabs.create(details);
      });
    }
    queryTabs(queryInfo, callback) {
      this.extension.tabs.query(queryInfo, callback);
    }
    sendTabMessage(tabId, message, responseCallback) {
      this.extension.tabs.sendMessage(tabId, message, responseCallback);
    }
    addRuntimeOnMessageListener(listener2) {
      this.extension.runtime.onMessage.addListener(listener2);
    }
    addWebNavigationOnDOMContentLoadedListener(listener2) {
      this.extension.webNavigation.onDOMContentLoaded.addListener(listener2);
    }
    addRuntimeOnInstalledListener(listener2) {
      this.extension.runtime.onInstalled.addListener(listener2);
    }
    addBrowserActionOnClickedListener(listener2) {
      this.extension.browserAction.onClicked.addListener(listener2);
    }
    createContextMenus(createProperties, callback) {
      return this.extension.contextMenus.create(createProperties, callback);
    }
    executeScript(tabId, details, callback) {
      this.extension.tabs.executeScript(tabId, details, callback);
    }
    insertCSS(tabId, details) {
      return __async(this, null, function* () {
        yield this.extension.tabs.insertCSS(tabId, details);
      });
    }
    hasLastError() {
      return this.extension.extension.lastError;
    }
    getLastErrorMessage() {
      return this.extension.extension.lastError.message;
    }
    addWebRequestOnHeadersReceivedListener(listener2, filter3, extraInfoSpec) {
      this.extension.webRequest.onHeadersReceived.addListener(
        listener2,
        filter3,
        extraInfoSpec
      );
    }
    setStorageLocal(items, callback) {
      this.extension.storage.local.set(items, callback);
    }
    getStorageLocal(keys4, callback) {
      this.extension.storage.local.get(keys4, callback);
    }
    getStorage(storageArea, keys4, callback) {
      this.extension.storage[storageArea].get(keys4, callback);
    }
  };
  var FakeExtension = class {
    constructor() {
      this.runtime = makeCallableProxy2();
      this.tabs = makeCallableProxy2();
      this.webNavigation = makeCallableProxy2();
      this.browserAction = makeCallableProxy2();
      this.storage = makeCallableProxy2();
      this.contextMenus = makeCallableProxy2();
      this.extension = makeCallableProxy2();
      this.webRequest = makeCallableProxy2();
    }
  };
  var extension2 = makeExtension();
  function makeExtension() {
    if ("chrome" in window) {
      return new Extension(window.chrome);
    } else if ("browser" in window) {
      return new Extension(window.browser);
    } else {
      if (false) {
        logger2.warn("Unsupported extension environment.");
      }
      return new Extension(new FakeExtension());
    }
  }
  function callableProxyTarget2() {
  }
  function makeCallableProxy2() {
    const names = [];
    return new Proxy(callableProxyTarget2, {
      get(_target, name, receiver) {
        names.push(name);
        return receiver;
      },
      apply(_target, _thisArg, args) {
        console.log(`Extension proxy called ${names.join(".")}(${args})}`);
      }
    });
  }

  // ../howdju-client-common/lib/models.ts
  var import_merge2 = __toESM(require_merge());
  var import_lodash12 = __toESM(require_lodash());

  // ../howdju-client-common/lib/target.ts
  var textPosition2 = __toESM(require_dom_anchor_text_position2());
  var textQuote3 = __toESM(require_dom_anchor_text_quote());

  // src/rangeToFragment.ts
  O(null);
  function rangeToFragment(range) {
    const selection = selectTextOfRange(range);
    return x(selection);
  }
  function selectTextOfRange(range) {
    const selection = window.getSelection();
    if (!selection) {
      throw new Error("unable to get selection");
    }
    const normalRange = normalizeContentRange(range);
    selection.removeAllRanges();
    selection.addRange(normalRange);
    return selection;
  }
  window.rangeToFragment = rangeToFragment;
})();
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

index-of/index.js:
  (*!
   * index-of <https://github.com/jonschlinkert/index-of>
   *
   * Copyright (c) 2014-2015 Jon Schlinkert.
   * Licensed under the MIT license.
   *)

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)
*/
